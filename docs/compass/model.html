<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>compass.model API documentation</title>
<meta name="description" content="The Model class which initialises the system and all of its components." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>compass.model</code></h1>
</header>
<section id="section-intro">
<p>The Model class which initialises the system and all of its components.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Model class which initialises the system and all of its components.
&#34;&#34;&#34;
import contextlib
from datetime import datetime
import os
import sys
from typing import List, Dict, Generator
import numpy as np
from mesa import Model
from mesa.space import ContinuousSpace
import ijson
import pandas as pd
import geopandas as gpd
from scipy.ndimage import convolve
from scipy.stats import truncnorm
from shapely.geometry import Point, box
from .household import Household
from .school import School
from .neighbourhood import Neighbourhood
from .scheduler import ThreeStagedActivation
from .utils import Measurements
from .functions import calc_comp_utility


@contextlib.contextmanager
def record_time(name: str) -&gt; Generator:
    try:
        start_time = datetime.now()
        yield
    finally:
        print(&#34;\n%s: %f&#34; % (name, (datetime.now() - start_time).total_seconds()))


def read_households(path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    A fast and efficient parser to read household data from a GeoJSON file.
    Arguments
        path    File to open, passed directly to open()
    Returns
        households (pd.DataFrame) [pos, category, neighbourhood_id]
    &#34;&#34;&#34;

    # open in binary mode for ijson
    geofile = open(path, &#34;rb&#34;)

    # assume floats are good enough,
    # no need for aribrary precision Decimal objects
    geo_households = ijson.items(geofile, &#34;features.item&#34;, use_float=True)

    # normal python lists, because appending is fast for them,
    # and we need the columns to create a pandas DataFrame
    coordinates = []
    groups = []
    neighbourhood_ids = []

    for feature in geo_households:
        coordinates.append(feature[&#34;geometry&#34;][&#34;coordinates&#34;])
        groups.append(feature[&#34;properties&#34;][&#34;group&#34;])
        neighbourhood_ids.append(feature[&#34;properties&#34;][&#34;neighbourhood_id&#34;])
    geofile.close()

    return pd.DataFrame(
        {&#34;pos&#34;: coordinates, &#34;category&#34;: groups, &#34;neighbourhood_id&#34;: neighbourhood_ids}
    )


def trunc_normal_sample(means: List, scale: float, size: int, seed=None) -&gt; List[np.ndarray]:
    &#34;&#34;&#34;
    Samples from a set of truncated normal distributions.
    Arguments:
        means  [n_means] of float
        scale  float
        size   float
    Output:
        sample [n_means] of np.ndarray [size]
    &#34;&#34;&#34;
    truncnorm._random_state = seed

    sample = [0] * len(means)
    for index, mu in enumerate(means):
        if scale == 0:
            # All samples are equal if the scale is zero.
            sample[index] = np.ones(size) * mu
        else:
            sample[index] = truncnorm.rvs(
                (0 - mu) / scale, (1 - mu) / scale, loc=mu, scale=scale, size=size
            )
    return sample


class CompassModel(Model):
    &#34;&#34;&#34;
    Model class for school segregation dynamics.
    Args:
        params (Argparser): containing all parameter values.
    Attributes:
        params (dict):
        grid (MultiGrid): MultiGrid object from Mesa.
        scheduler (ThreeStagedActivation): ThreeStagedActivation object.
        agents (list): all agents in the model.
        measurements (Measurements): Measurements object.
        global_composition (dict): containing the total system compositions.
        distance_matrix (list): all the Euclidean distances from one grid cell
            to another.
        nearness_matrix (list): same as above but with normalized distances.
        alpha np.ndarray[n_households]
        temperature float
        utility_at_max np.ndarray[n_households]
        optimal_fraction np.ndarray [n_households]
        neighbourhood_mixture np.ndarray [n_households]
        chosen_indices np.ndarray [n_households]
        school_ended boolean
        res_ended boolean
    Cached attributes:
        kernel (ndarray)
            set: calc_residential_compositions
            used: calc_residential_compositions
        local_compositions (list, ndarray) [n_households, ndarray]
            set: set_agent_parameters, overwritten in load_agents, update_residential
            used: calc_res_utilities
        normalized_compositions (ndarray) [width, height, len(params[&#39;group_types&#39;][0])]
            set: calc_residential_compositions
            used: set_agent_parameters
        neighbourhood_compositions (list, ndarray) [n_households]
            set: set_agent_parameters, update_residential
            used: load_agents, calc_res_utilities
        school_compositions (ndarray, float32) [n_households]
            set: set_agent_parameters, calc_school_compositions, update_school
            used: calc_school_utilities
        alpha (ndarray, float32) [n_households]
            set: set_agent_parameters
            used: calc_school_utilities, calc_school_rankings
        temperature (float?)
            set: set_agent_parameters
            used: (calc_school_rankings, residential_ranking but from params)
        utility_at_max (ndarray, float32) [n_households]
            set: set_agent_parameters
            used: calc_res_utilities, calc_school_utilities , calc_school_rankings
            (residential_utility, but from params)
        optimal_fraction (ndarray, float32) [n_households]
            set: set_agent_parameters
            used: calc_res_utilities, calc_school_utilities, calc_school_rankings
        neighbourhood_mixture (ndarray, int) [n_households]  TODO: np.ushort?
            set: set_agent_parameters
            used: calc_res_utilities
        distance_utilities(ndarray) [n_households, n_schools]
            set: set_agent_parameters
            used: calc_school_rankings, update_school
        all_distances:  (ndarray) [n_households, n_schools] FIXME
        household_attrs (ndarray, float) [width, height, len(params[&#39;group_types&#39;][0])]
        compositions (ndarray, float32)  as household_attrs
    &#34;&#34;&#34;

    def __init__(self, export: bool = False, **params: dict):

        super().__init__()

        # Use random from the numpy package for extra functionality
        self.random = np.random.RandomState(self._seed)

        # define various arrays TODO: sort/document those
        self.local_compositions: List = []
        self.neighbourhood_compositions: List = []
        self.alpha: np.ndarray = np.ndarray([])
        self.temperature: float = 0.0
        self.utility_at_max: np.ndarray = np.ndarray([])
        self.optimal_fraction: np.ndarray = np.ndarray([])
        self.neighbourhood_mixture: np.ndarray = np.ndarray([])
        self.school_compositions: np.ndarray = np.ndarray([])
        self.school_ended: bool = False
        self.res_ended: bool = False
        self.distance_utilities: np.ndarray = np.ndarray([])
        self.chosen_indices: np.ndarray = np.ndarray([])

        self.household_attrs: np.ndarray = np.ndarray([])
        self.compositions: np.ndarray = np.ndarray([])
        self.normalized_compositions: np.ndarray = np.ndarray([])

        self.all_distances: np.ndarray = np.ndarray([])
        self.kernel: np.ndarray = np.ndarray([])

        # Initialise the model attributes
        self.set_attributes(params=params, export=export)

        if self.params[&#34;case&#34;].lower() != &#34;lattice&#34;:
            self.load_agents(self.params[&#34;case&#34;].lower())
        else:
            self.create_agents()

        # Get values of the initial configuration
        self.measurements.end_step(residential=True)

        # Calculate global compositions for the segregation calculations
        self.global_composition = self.measurements.neighbourhoods[0, :, :2].sum(axis=0)

        if self.verbose:
            text = f&#34;&#34;&#34; Model initialised:
                NR AGENTS:
                Households: {self.params[&#39;n_households&#39;]}
                Neighbourhoods: {self.params[&#39;n_neighbourhoods&#39;]}
                Schools: {self.params[&#39;n_schools&#39;]}
                In scheduler: {self.scheduler.get_agent_count()}&#34;&#34;&#34;
            print(text)

    def set_attributes(self, params: dict, export=False) -&gt; None:
        &#34;&#34;&#34;
        Sets or calculates all attributes used in the Compass class.
        Args:
            params (Argparser): containing all parameter values.
            export (bool): True if the data needs to be exported or not.
        &#34;&#34;&#34;

        # Calculate number of households and students
        params[&#34;n_households&#34;] = int(
            params[&#34;household_density&#34;]
            * (
                params[&#34;width&#34;] * params[&#34;height&#34;]
                - params[&#34;n_neighbourhoods&#34;]
                - params[&#34;n_schools&#34;]
            )
        )
        params[&#34;n_students&#34;] = int(params[&#34;n_households&#34;] * params[&#34;student_density&#34;])
        self.params = dict(params)

        # Set tracking attributes
        self.export = export
        # Track segregation over time
        self.segregation: List[float] = []
        self.res_ended = False
        self.school_ended = False
        self.verbose = self.params[&#34;verbose&#34;]
        self.agents: Dict[str, List[object]] = {
            &#34;amount&#34;: 0,
            &#34;households&#34;: [],
            &#34;schools&#34;: [],
            &#34;neighbourhoods&#34;: [],
        }

        # Initialise other objects
        self.measurements = Measurements(self)
        self.scheduler = ThreeStagedActivation(self)
        self.grid = ContinuousSpace(
            self.params[&#34;width&#34;], self.params[&#34;height&#34;], torus=self.params[&#34;torus&#34;]
        )

    def create_agents(self) -&gt; None:
        &#34;&#34;&#34;
        Creates the agents when no case study is provided.
        &#34;&#34;&#34;
        self.neighbourhoods()
        self.schools()
        self.location_to_agent()

        # Compute closest neighbourhoods
        self.closest_neighbourhoods = self.compute_closest_neighbourhoods()

        # Create households
        self.households()

    def set_agent_parameters(self, params: dict) -&gt; None:
        &#34;&#34;&#34;
        Puts the agent parameters in numpy arrays for faster computations.
        Args:
            params (dict): Model parameters which could differ from
                the agent params!
        Todo:
            Parameters should be imported from a config file in the future.
        &#34;&#34;&#34;
        households = self.get_agents(&#34;households&#34;)
        n_households = len(households)

        dtype = &#34;float32&#34;
        self.alpha = np.zeros(n_households, dtype=dtype)
        self.temperature = self.params[
            &#34;temperature&#34;
        ]  # FIXME: different temp per agent?
        self.utility_at_max = np.zeros(n_households, dtype=dtype)
        self.optimal_fraction = np.zeros(n_households, dtype=dtype)
        self.neighbourhood_mixture = np.ones(n_households, dtype=int)

        optimal_fractions = trunc_normal_sample(
            params[&#34;optimal_fraction&#34;][0],
            scale=params[&#34;homophily_std&#34;],
            size=n_households,
            seed=self.random
        )
        alphas = trunc_normal_sample(
            [params[&#34;alpha&#34;], params[&#34;alpha&#34;]],
            scale=params[&#34;homophily_std&#34;],
            size=n_households,
            seed=self.random
        )
        utility_at_maxs = trunc_normal_sample(
            params[&#34;utility_at_max&#34;][0],
            scale=params[&#34;homophily_std&#34;],
            size=n_households,
            seed=self.random
        )

        for household in households:
            x, y = household.pos

            # Fill arrays with agent parameter values for faster computations
            self.optimal_fraction[household.idx] = optimal_fractions[
                household.category
            ][household.idx]
            self.alpha[household.idx] = alphas[household.category][household.idx]
            self.utility_at_max[household.idx] = utility_at_maxs[household.category][
                household.idx
            ]

            # Currently only convolution (assumes every household has the same
            # radius) for composition calculations within the lattice case.
            if params[&#34;case&#34;].lower() == &#34;lattice&#34;:
                self.local_compositions.append(
                    self.normalized_compositions[x, y, household.category]
                )
            else:
                household.params[&#34;neighbourhood_mixture&#34;] = 1

            if household.neighbourhood.total &gt; 0:
                norm = 1.0 / household.neighbourhood.total
            else:
                norm = 1.0
            self.neighbourhood_compositions.append(
                household.neighbourhood.composition[household.category] * norm
            )

        # These are filled with the actual distance and composition utilities
        # of the household and the school (singular!) they attend

        # SHOULD BE CALLED DIFFERENTLY CAUSE NOW IT OVERWRITES AN ATTRIBUTE!!!
        self.school_compositions = np.zeros(n_households, dtype=dtype)

        # Distance utilities based on sigmoid function
        if self.params[&#34;case&#34;].lower() != &#34;lattice&#34;:
            p = self.params[&#34;p&#34;]
            q = self.params[&#34;q&#34;]
            self.distance_utilities = 1.0 / (1 + (self.all_distances / p) ** q)

    def neighbourhoods(self) -&gt; None:
        &#34;&#34;&#34;
        Adds the neighbourhood objects to the environment.
        &#34;&#34;&#34;

        n_neighs = self.params[&#34;n_neighbourhoods&#34;]

        # Add neighbourhoods if necessary
        if n_neighs:
            locations = self.choose_locations(
                n_neighs, self.params[&#34;neighbourhoods_placement&#34;]
            )
            for location in locations:
                size = self.params[&#34;width&#34;] / float(n_neighs**0.5 * 2)
                minx, miny = location[0] - size, location[1] - size
                maxx, maxy = location[0] + size, location[1] + size
                shape = box(minx, miny, maxx, maxy)

                # Create the Neighbourhood object and place it on the grid and
                # add it to the scheduler
                neighbourhood = Neighbourhood(
                    self.get_agents(&#34;amount&#34;), location, shape, self, self.params
                )
                self.agents[&#34;neighbourhoods&#34;].append(neighbourhood)
                self.scheduler.add(neighbourhood)
                self.grid.place_agent(neighbourhood, location)

    def schools(self) -&gt; None:
        &#34;&#34;&#34;
        Adds the school objects to the environment.
        &#34;&#34;&#34;

        School.reset()

        # Add schools if necessary
        if self.params[&#34;n_schools&#34;]:
            locations = self.choose_locations(
                self.params[&#34;n_schools&#34;], self.params[&#34;schools_placement&#34;]
            )
            for location in locations:
                # Create the School object and place it on the grid and add it
                # to the scheduler
                school = School(self.get_agents(&#34;amount&#34;), location, self, self.params)
                self.agents[&#34;schools&#34;].append(school)
                self.scheduler.add(school)
                self.grid.place_agent(school, location)

    def households(self) -&gt; None:
        &#34;&#34;&#34;
        Adds the household objects to the environment.
        Todo:
            * Place household specific parameters in a attribute called params
        &#34;&#34;&#34;

        params = self.params
        self.chosen_indices = None  # Only matters for case studies
        self.household_attrs = np.zeros(
            shape=(params[&#34;width&#34;], params[&#34;height&#34;], len(params[&#34;group_types&#34;][0])),
            dtype=&#34;float32&#34;,
        )

        # Create group types, empty spots and shuffle them both
        n_groups = len(params[&#34;group_categories&#34;])
        groups = [
            self.random.choice(
                list(range(0, len(params[&#34;group_types&#34;][i]))),
                size=params[&#34;n_households&#34;],
                p=params[&#34;group_dist&#34;][i],
            )
            for i in range(n_groups)
        ]

        self.grid.empties = set(
            [(x, y) for x in range(params[&#34;width&#34;]) for y in range(params[&#34;height&#34;])]
        )
        empties = list(self.grid.empties)
        self.random.shuffle(empties)

        # pre-allocate storage for the Housholds
        Household.reset(max_households=params[&#34;n_households&#34;])

        for i, position in enumerate(empties[0 : params[&#34;n_households&#34;]]):
            household = Household(
                self.get_agents(&#34;amount&#34;), position, self, params, groups[0][i]
            )

            # Place households on the grid and add them to the scheduler
            self.agents[&#34;households&#34;].append(household)
            self.grid.place_agent(household, position)
            self.grid.empties.discard(position)
            self.scheduler.add(household)
            self.household_attrs[position[0], position[1], :] = household.attributes

        # Calculate AFTER all agents are placed
        self.calc_residential_compositions()
        self.set_agent_parameters(params)
        self.calc_res_utilities()

    def load_agents(self, case=&#34;Amsterdam&#34;) -&gt; None:
        &#34;&#34;&#34;
        Load the agents from several files.
        Note:
            This function is in progress and works only for the
            Amsterdam case now.
        &#34;&#34;&#34;

        dirname = os.path.dirname(__file__)
        if case.lower() == &#34;amsterdam&#34;:
            path = dirname + &#34;/maps/amsterdam&#34;
        elif case.lower() == &#34;south-london&#34;:
            path = dirname + &#34;/maps/south-london&#34;
        elif case.lower() == &#34;london&#34;:
            path = dirname + &#34;/maps/london&#34;

        # Load GeoDataFrames
        school_frame = gpd.read_file(path + &#34;/schools.geojson&#34;)
        household_frame = read_households(path + &#34;/households.geojson&#34;)
        neighbourhood_frame = gpd.read_file(path + &#34;/neighbourhoods.geojson&#34;)

        # Create grid
        self.params[&#34;torus&#34;] = 0
        self.params[&#34;max_res_steps&#34;] = 0
        xmin, ymin, xmax, ymax = neighbourhood_frame.total_bounds
        self.grid = ContinuousSpace(xmax, ymax, self.params[&#34;torus&#34;], xmin, ymin)
        self.grid.empties = [(0, 0)]

        # In the file more households could be available to sample from,
        # but only use the actual amount
        data = np.load(path + &#34;/distances_perc_of_actual.npz&#34;)
        perc_of_actual = data[&#34;perc_of_actual&#34;]
        self.all_distances = data[&#34;distances&#34;]

        self.scheduler = ThreeStagedActivation(self)

        # More agents are simulated to sample from them and incorporate some
        # randomness in the type and spatial distribution
        total_households = len(household_frame)
        actual_households = int(total_households / perc_of_actual)
        self.params[&#34;n_households&#34;] = actual_households
        self.params[&#34;n_students&#34;] = int(
            self.params[&#34;n_households&#34;] * self.params[&#34;student_density&#34;]
        )

        # Create neighbourhoods
        self.create_neighbourhoods(neighbourhood_frame)

        # Create schools
        self.create_schools(school_frame)

        # Create households
        self.create_households(household_frame, actual_households)

        if self.verbose:
            print(&#34;Setting agent parameters...&#34;)
        self.set_agent_parameters(self.params)

        self.local_compositions = self.neighbourhood_compositions
        self.calc_res_utilities()

        if self.verbose:
            print(&#34;Model loaded!&#34;)

    def create_neighbourhoods(self, neighbourhood_frame: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Given a GeoDataFrame, this creates all the neighbourhood objects
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Creating neighbourhoods...&#34;)

        self.params[&#34;n_neighbourhoods&#34;] = len(neighbourhood_frame)
        for index, row in neighbourhood_frame.iterrows():
            neighbourhood = Neighbourhood(
                unique_id=index,
                pos=(row.geometry.centroid.xy[0][0], row.geometry.centroid.xy[1][0]),
                shape=row.geometry,
                model=self,
                params=self.params,
            )
            self.agents[&#34;neighbourhoods&#34;].append(neighbourhood)
            self.scheduler.add(neighbourhood)
            self.grid.place_agent(neighbourhood, neighbourhood.pos)

    def create_schools(self, school_frame: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Given a GeoDataFrame, this creates all the school objects
        &#34;&#34;&#34;

        School.reset()

        if self.verbose:
            print(&#34;Creating schools...&#34;)

        self.params[&#34;n_schools&#34;] = len(school_frame)
        n_neighbourhoods = self.params[&#34;n_neighbourhoods&#34;]
        for index, row in school_frame.iterrows():
            school = School(
                unique_id=index + n_neighbourhoods,
                pos=(row.geometry.xy[0][0], row.geometry.xy[1][0]),
                model=self,
                params=self.params,
            )
            school.capacity = 1 + int(
                self.params[&#34;school_capacity&#34;]
                * self.params[&#34;n_students&#34;]
                / self.params[&#34;n_schools&#34;]
            )
            self.agents[&#34;schools&#34;].append(school)
            self.scheduler.add(school)
            self.grid.place_agent(school, school.pos)

    def create_households(
        self, household_frame: pd.DataFrame, actual_households: int
    ) -&gt; None:
        &#34;&#34;&#34;
        Given a GeoDataFrame, this creates household objects by randomly
        drawing (without replacement) household metadata rows from the frame.
        Arguments
            actual_households (int)
                The number of households to create.
        Parameters used
            params[&#39;random_residential&#39;]
        Parameters set
            params[&#39;n_households&#39;]
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Creating households...&#34;)

        self.chosen_indices = self.random.choice(
            len(household_frame), size=actual_households, replace=False
        )
        households_sample = household_frame.iloc[self.chosen_indices]

        if self.params[&#34;random_residential&#34;]:
            # Randomly shuffle the group of the household
            shuffled = households_sample[&#34;group&#34;].values
            self.random.shuffle(shuffled)
            households_sample[&#34;group&#34;] = shuffled

        self.params[&#34;n_households&#34;] = actual_households
        n_agents = self.params[&#34;n_neighbourhoods&#34;] + self.params[&#34;n_schools&#34;]
        neighbourhoods = self.get_agents(&#34;neighbourhoods&#34;)

        self.all_distances = self.all_distances[self.chosen_indices, :]

        # pre-allocate storage for the Housholds
        Household.reset(max_households=actual_households)

        # DataFrame.iterrows() is very slow, dont use it!
        # the current code uses only iterates (no copies)
        # and should be memory-friendly and performant:
        # accumulated time for create_households:
        # for the testcase with  60K households from 9.10 to 2.60 seconds
        # for the testcase with 210K households from 30.0 to 9.27 seconds
        for index, row in enumerate(
            zip(
                households_sample[&#34;pos&#34;],
                households_sample[&#34;category&#34;],
                households_sample[&#34;neighbourhood_id&#34;],
            )
        ):
            household = Household(
                unique_id=index + n_agents,
                pos=row[0],
                model=self,
                params=self.params,
                category=row[1],
                nhood=neighbourhoods[row[2]],
            )
            self.agents[&#34;households&#34;].append(household)
            self.scheduler.add(household)
            self.grid.place_agent(household, household.pos)

        self.location_to_agent()

    def location_to_agent(self) -&gt; None:
        &#34;&#34;&#34;
        Creates a dictionary with the location of the neighbourhoods as key and
        the object itself as value. Schools are not included as they can have
        the same position as a neighbourhood (centroid).
        &#34;&#34;&#34;
        agents = self.get_agents(&#34;neighbourhoods&#34;)
        self.location_to_agent = {str(agent.pos): agent for agent in agents}

    def calc_residential_compositions(self) -&gt; None:
        &#34;&#34;&#34;
        Updates all local residential compositions assuming all households have
        the SAME RADIUS.
        &#34;&#34;&#34;

        # Determine the kernel of the convolution
        radius = self.params[&#34;radius&#34;]
        dim = radius * 2 + 1
        self.kernel = np.ones((dim, dim))
        self.kernel[radius, radius] = 0

        # Should it wrap around the edges or not?
        if self.params[&#34;torus&#34;]:
            mode = &#34;wrap&#34;
        else:
            mode = &#34;constant&#34;

        summed = 0
        num_attrs = self.household_attrs.shape[2]
        compositions = np.zeros(shape=self.household_attrs.shape, dtype=&#34;float32&#34;)

        # Convolution for every household attribute.
        for attr in range(num_attrs):
            compositions[:, :, attr] = convolve(
                self.household_attrs[:, :, attr], self.kernel, mode=mode
            )
            summed += compositions[:, :, attr]
        self.compositions = compositions
        self.normalized_compositions = np.nan_to_num(
            compositions / np.repeat(summed[:, :, np.newaxis], num_attrs, axis=2)
        )

    def calc_school_compositions(self) -&gt; None:
        &#34;&#34;&#34;
        Calculate the new school compositions for every household and only for
        the first student!
        Note:
            Currently only for the first student!!!
        &#34;&#34;&#34;

        households = self.get_agents(&#34;households&#34;)
        for household in households:
            category = household.category
            idx = household.idx
            school = household.school
            if school.total:
                self.school_compositions[idx] = (
                    school.composition[category] / school.total
                )
            else:
                self.school_compositions[idx] = 0.0

    def calc_res_utilities(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates residential utility at a household its current position and
        given its parameter values.
        &#34;&#34;&#34;

        b = self.neighbourhood_mixture
        f = self.optimal_fraction
        M = self.utility_at_max
        x = (1 - b) * self.local_compositions + b * self.neighbourhood_compositions

        calc_comp_utility(Household._household_res_utility, x, M, f)

    def calc_school_utilities(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates school utilities at a student its current school, given
        distance and its other parameter values.
        &#34;&#34;&#34;

        alpha = self.alpha
        f = self.optimal_fraction
        M = self.utility_at_max
        x = self.school_compositions

        calc_comp_utility(Household._household_school_utility_comp, x, M, f)

        # TODO: This needs to be correct, what distances to use?
        Household._household_school_utility = (
            Household._household_school_utility_comp * alpha
        ) + (Household._household_distance * (1 - alpha))

    def calc_school_rankings(
        self, households: List[Household], schools: List[School]
    ) -&gt; None:
        &#34;&#34;&#34;
        Ranks the schools according to utility.
        Note: this is probably a performance bottleneck; one of the array is
        of size [n_households_moving, n_of_schools].
        Args:
            households (list): list of households the rankings need to be
                calculated for.
            schools (list): list of schools that need to be ranked.
        Todo:
            Schools can differ per household if we only want to look at the
            n-closest schools for example?
        &#34;&#34;&#34;
        if len(schools) == 0 or len(households) == 0:
            return

        zeros = np.zeros(len(self.params[&#34;group_types&#34;][0]))
        compositions = np.array(
            [
                school.composition / school.total if school.total &gt; 0 else zeros
                for school in schools
            ],
            dtype=&#34;float32&#34;,
        )

        households_data = np.array(
            [(h.idx, h.category) for h in households], dtype=int
        ).T
        households_indices = households_data[0, :]
        households_categories = households_data[1, :]

        # Composition utility calculations
        t = np.take(self.optimal_fraction, households_indices)  # [n_indices]
        M = np.take(self.utility_at_max, households_indices)  # [n_indices]
        x = np.take(
            compositions, households_categories, axis=1
        )  # [n_schools, n_indices]
        composition_utilities = np.where(x &lt;= t, x / t, M + (1 - x) * (1 - M) / (1 - t))

        # Combined (THIS SHOULD BE GENERALISED TO INCLUDE MORE FACTORS)
        utilities = (
            composition_utilities * self.alpha[np.newaxis, households_indices]
            + (
                np.take(self.distance_utilities, households_indices, axis=0)
                * (1 - self.alpha[households_indices, np.newaxis])
            ).T
        )
        # utilities.shape = (len(schools), len(households))

        # Rank the schools according to the household utilities
        # TODO: is this the right utility? ie. residential=False?
        households_utilities = np.take(
            Household._household_school_utility, households_indices
        )

        method = self.params[&#34;ranking_method&#34;].lower()
        if method == &#34;proportional&#34;:
            differences = utilities - households_utilities[np.newaxis, :]
            exp_utilities = np.exp(self.temperature * differences)
            transformed = exp_utilities / exp_utilities.sum(axis=0)[np.newaxis, :]

        elif method == &#34;highest&#34;:
            transformed = utilities

        else:
            print(&#34;Method not implementd.&#34;)
            sys.exit()

        # instead of reversing the list, sort the negative values in the list
        ranked_indices = (-transformed).argsort(axis=0, kind=&#39;quicksort&#39;)

        # necessary to allow indexing with the argsort result
        schools = np.array(schools)

        for i, household in enumerate(households):
            ranking = schools[ranked_indices[:, i]]

            # TODO: can we make school preference a Household property,
            # instead of a Student property? gives ~10% extra speedup
            for student in household.students:
                student.set_school_preference(ranking)

    def get_attributes(self, pos: tuple[float, float]) -&gt; np.ndarray:

        &#34;&#34;&#34;
        Returns the attribute vector of a given position
        Args:
            pos (tuple): (x,y) coordinates.
        Returns:
            Numpy array: containing all the attributes (all zeros if empty)
        &#34;&#34;&#34;
        return self.household_attrs[pos[0], pos[1], :]

    def switch_attrs(
        self, pos1: tuple[float, float], pos2: tuple[float, float]
    ) -&gt; None:
        &#34;&#34;&#34;
        Switches two attribute vectors in the attribute grid by making a copy.
        Args:
            pos1 (tuple): (x,y) coordinates.
            pos2 (tuple): (x,y) coordinates.
        &#34;&#34;&#34;
        temp = np.copy(self.household_attrs[pos1])
        self.household_attrs[pos1] = self.household_attrs[pos2]
        self.household_attrs[pos2] = temp

    def step(self, residential: bool = False, initial_schools: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Perform model steps.
        Args:
            residential (bool): True if a residential step needs to be done,
                False (default) means a school step.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;

        # Perform school or residential step.
        self.scheduler.step(residential=residential, initial_schools=initial_schools)

    def simulate(self, res_steps: int = None, school_steps: int = None) -&gt; None:
        &#34;&#34;&#34;
        Performs #res_steps of residential steps and #school_steps of school
        steps.
        Args:
            res_steps (int): Number of residential steps.
            school_steps (int): Number of school steps.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;

        if not res_steps:
            res_steps = self.params[&#34;max_res_steps&#34;]

        if not school_steps:
            school_steps = self.params[&#34;max_school_steps&#34;]

        while self.scheduler.get_time(&#34;residential&#34;) &lt; res_steps and not self.res_ended:

            if self.verbose:
                f = (
                    &#34;Residential process: step &#34;
                    + str(self.scheduler.get_time(&#34;residential&#34;) + 1)
                    + &#34; from &#34;
                    + str(res_steps)
                )
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()

            self.res_ended = self.convergence_check()
            if not self.res_ended:
                self.step(residential=True)
            else:
                break

        if self.verbose:
            print()

        while (
            self.scheduler.get_time(&#34;school&#34;) &lt; school_steps and not self.school_ended
        ):

            if self.verbose:
                f = (
                    &#34;School process: step &#34;
                    + str(self.scheduler.get_time(&#34;school&#34;) + 1)
                    + &#34; from &#34;
                    + str(school_steps)
                )
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()

            self.school_ended = self.convergence_check()

            if self.scheduler.school_steps == 0:
                self.step(residential=False, initial_schools=True)
            else:
                if not self.school_ended:
                    self.step(residential=False, initial_schools=False)
                else:
                    break

        if self.verbose:
            print()
            print(&#34;Processes ended&#34;)
        self.export_data(self.export)

    def convergence_check(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the processes have converged.
        Returns: True if converged.
        &#34;&#34;&#34;
        window_size = self.params[&#34;window_size&#34;]
        time = self.scheduler.get_time()
        school_time = self.scheduler.get_time(&#34;school&#34;)

        # Check what type of segregation to calculate (i.e., which of the
        # processes is running)
        if not self.res_ended:
            self.segregation.append(
                self.measurements.calculate_segregation(
                    type=&#34;bounded_neighbourhood&#34;, index=&#34;Theil&#34;
                )
            )
        else:
            self.segregation.append(
                self.measurements.calculate_segregation(type=&#34;school&#34;, index=&#34;Theil&#34;)
            )

        # Wait until there is enough steps in the school process
        if self.res_ended and school_time &lt; window_size:
            return False

        # Check all metrics in the window size and check if they are below
        # the convergence threshold
        if time &gt;= window_size - 1:
            utilities = self.measurements.households[
                time - window_size + 1 : time + 1, :, 4
            ]
            means = utilities.mean(axis=1)
            stds = utilities.std(axis=1)

            metrics = np.vstack(
                (means, stds, self.segregation[time - window_size + 1 : time + 1])
            )

            metric_means = np.repeat(
                metrics.mean(axis=1)[:, np.newaxis], window_size, axis=1
            )
            mad = np.abs(metrics - metric_means)
            if np.all(mad &lt; self.params[&#34;conv_threshold&#34;]):
                # Start over if the residential process has converged
                self.res_ended = True
                return True

        return False

    def choose_locations(
        self, amount: int, method: str = &#34;evenly_spaced&#34;
    ) -&gt; List[tuple[float, float]]:
        &#34;&#34;&#34;
        Compute a number of locations to place school and neighbourhood objects.
        Args:
            amount (int): the number of agents to place.
            method (str): one of &#39;evenly_spaced&#39;, &#39;random&#39;, &#39;random_per_neighbourhood&#39;
        Returns:
            list: containing all the locations in tuple (x,y) format.
        &#34;&#34;&#34;

        if amount == 0:
            return []

        if method == &#34;evenly_spaced&#34;:
            per_side = np.sqrt(amount)
            if per_side % 1 != 0:
                print(&#34;Unable to place amount of locations using given method&#34;)
                sys.exit(1)

            # Compute locations
            per_side = int(per_side)
            xs = np.linspace(0, self.params[&#34;width&#34;], per_side * 2 + 1)[1::2]
            ys = np.linspace(0, self.params[&#34;height&#34;], per_side * 2 + 1)[1::2]
            return [(x, y) for x in xs for y in ys]

        elif method == &#34;random&#34;:
            locations = []
            i = 0
            while i &lt; amount:
                x_coord = self.random.randint(low=0, high=self.params[&#34;width&#34;])
                y_coord = self.random.randint(low=0, high=self.params[&#34;height&#34;])
                if (x_coord, y_coord) not in locations:
                    locations.append((x_coord, y_coord))
                    i += 1
            return locations

        elif method == &#34;random_per_neighbourhood&#34;:
            locations = []
            width, height = self.params[&#34;width&#34;], self.params[&#34;height&#34;]
            n_schools = self.params[&#34;n_schools&#34;]
            n_neighbourhoods = self.params[&#34;n_neighbourhoods&#34;]
            per_side = int(np.sqrt(n_neighbourhoods))
            location_width = width / per_side
            location_height = height / per_side

            # Draw a random sample per neighbourhood as long as there are
            # schools to place
            i = 0
            while i &lt; max(n_neighbourhoods, n_schools):
                y_low = 0
                for col in range(per_side):
                    x_low = 0
                    y_high = int((1 + col) * location_height)

                    for row in range(per_side):

                        x_high = int((1 + row) * location_width)

                        if x_high &gt;= width:
                            x_high = width - 1
                        elif y_high &gt;= height:
                            y_high = height - 1

                        x_coord = self.random.randint(low=x_low, high=x_high)
                        y_coord = self.random.randint(low=y_low, high=y_high)

                        # Check if the coordinates haven&#39;t already been sampled
                        while (x_coord, y_coord) in locations:
                            x_coord = self.random.randint(low=x_low, high=x_high)
                            y_coord = self.random.randint(low=y_low, high=y_high)

                        locations.append((x_coord, y_coord))
                        x_low = x_high + 1
                        i += 1
                    y_low = y_high + 1

            # Shuffle all locations if n_schools &lt;= n_neighbourhoods, otherwise
            # shuffle only the remainder
            if n_schools &lt;= n_neighbourhoods:
                self.random.shuffle(locations)
            else:
                divider = int(n_schools / n_neighbourhoods)
                remainder = n_schools % n_neighbourhoods
                first_locations = locations[: n_neighbourhoods * divider]
                rest_locations = locations[n_neighbourhoods * divider :]
                self.random.shuffle(rest_locations)
                locations = first_locations + rest_locations[:remainder]

            return locations

        print(f&#34;Unknown method in choose_locations {method} __file__:__line__&#34;)
        sys.exit(-1)

    def compute_closest_neighbourhoods(self) -&gt; dict:
        &#34;&#34;&#34;
        Compute distance from all grid cells to all schools and all
        neighbourhood objects.
        Returns:
            dict: of dicts containing all Euclidean distances
        &#34;&#34;&#34;

        EPS = 1.2e-6
        closest_neighbourhoods = {}
        neighbourhoods = self.get_agents(&#34;neighbourhoods&#34;)

        for x in range(self.params[&#34;width&#34;]):
            for y in range(self.params[&#34;height&#34;]):

                # Loop over all neighbourhoods, calculate distance and save
                # closest
                point = Point(x, y)
                for neighbourhood in neighbourhoods:
                    shape = neighbourhood.shape.buffer(EPS)
                    if shape.contains(point):
                        closest_neighbourhoods[str((x, y))] = str(neighbourhood.pos)
                        break

        return closest_neighbourhoods

    def compute_school_distances(self) -&gt; None:
        &#34;&#34;&#34;
        Computes school distances.
        &#34;&#34;&#34;
        self.all_distances = np.zeros(
            (self.params[&#34;n_households&#34;], self.params[&#34;n_schools&#34;])
        )
        school_frame = gpd.GeoSeries(
            [Point(school.pos) for school in self.get_agents(&#34;schools&#34;)]
        )
        for household in self.get_agents(&#34;households&#34;):
            self.all_distances[household.idx, :] = school_frame.distance(
                Point(household.pos)
            )

    def get_agents(self, agent_type: str) -&gt; List[object]:
        &#34;&#34;&#34;
        Returns list of agents of given type.
        Args:
            agent_type (str): either &#39;School&#39;, &#39;Neighbourhood&#39;, &#39;Household&#39; or
            &#39;Student&#39;.
        Returns:
            list: containing all the objects of the specified type.
        &#34;&#34;&#34;
        return self.agents[agent_type]

    def export_data(self, export=False) -&gt; None:
        &#34;&#34;&#34;
        Export data for visualization.
        &#34;&#34;&#34;
        if export:
            self.measurements.export_data()

    def increment_agent_count(self) -&gt; None:
        &#34;&#34;&#34;
        Increment agent count by one.
        &#34;&#34;&#34;
        self.agents[&#34;amount&#34;] += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="compass.model.read_households"><code class="name flex">
<span>def <span class="ident">read_households</span></span>(<span>path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>A fast and efficient parser to read household data from a GeoJSON file.
Arguments
path
File to open, passed directly to open()
Returns
households (pd.DataFrame) [pos, category, neighbourhood_id]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_households(path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    A fast and efficient parser to read household data from a GeoJSON file.
    Arguments
        path    File to open, passed directly to open()
    Returns
        households (pd.DataFrame) [pos, category, neighbourhood_id]
    &#34;&#34;&#34;

    # open in binary mode for ijson
    geofile = open(path, &#34;rb&#34;)

    # assume floats are good enough,
    # no need for aribrary precision Decimal objects
    geo_households = ijson.items(geofile, &#34;features.item&#34;, use_float=True)

    # normal python lists, because appending is fast for them,
    # and we need the columns to create a pandas DataFrame
    coordinates = []
    groups = []
    neighbourhood_ids = []

    for feature in geo_households:
        coordinates.append(feature[&#34;geometry&#34;][&#34;coordinates&#34;])
        groups.append(feature[&#34;properties&#34;][&#34;group&#34;])
        neighbourhood_ids.append(feature[&#34;properties&#34;][&#34;neighbourhood_id&#34;])
    geofile.close()

    return pd.DataFrame(
        {&#34;pos&#34;: coordinates, &#34;category&#34;: groups, &#34;neighbourhood_id&#34;: neighbourhood_ids}
    )</code></pre>
</details>
</dd>
<dt id="compass.model.record_time"><code class="name flex">
<span>def <span class="ident">record_time</span></span>(<span>name: str) ‑> Generator</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def record_time(name: str) -&gt; Generator:
    try:
        start_time = datetime.now()
        yield
    finally:
        print(&#34;\n%s: %f&#34; % (name, (datetime.now() - start_time).total_seconds()))</code></pre>
</details>
</dd>
<dt id="compass.model.trunc_normal_sample"><code class="name flex">
<span>def <span class="ident">trunc_normal_sample</span></span>(<span>means: List, scale: float, size: int, seed=None) ‑> List[numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Samples from a set of truncated normal distributions.</p>
<h2 id="arguments">Arguments</h2>
<p>means
[n_means] of float
scale
float
size
float</p>
<h2 id="output">Output</h2>
<p>sample [n_means] of np.ndarray [size]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trunc_normal_sample(means: List, scale: float, size: int, seed=None) -&gt; List[np.ndarray]:
    &#34;&#34;&#34;
    Samples from a set of truncated normal distributions.
    Arguments:
        means  [n_means] of float
        scale  float
        size   float
    Output:
        sample [n_means] of np.ndarray [size]
    &#34;&#34;&#34;
    truncnorm._random_state = seed

    sample = [0] * len(means)
    for index, mu in enumerate(means):
        if scale == 0:
            # All samples are equal if the scale is zero.
            sample[index] = np.ones(size) * mu
        else:
            sample[index] = truncnorm.rvs(
                (0 - mu) / scale, (1 - mu) / scale, loc=mu, scale=scale, size=size
            )
    return sample</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="compass.model.CompassModel"><code class="flex name class">
<span>class <span class="ident">CompassModel</span></span>
<span>(</span><span>export: bool = False, **params: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Model class for school segregation dynamics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>Argparser</code></dt>
<dd>containing all parameter values.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>params (dict):</dt>
<dt><strong><code>grid</code></strong> :&ensp;<code>MultiGrid</code></dt>
<dd>MultiGrid object from Mesa.</dd>
<dt><strong><code>scheduler</code></strong> :&ensp;<code>ThreeStagedActivation</code></dt>
<dd>ThreeStagedActivation object.</dd>
<dt><strong><code>agents</code></strong> :&ensp;<code>list</code></dt>
<dd>all agents in the model.</dd>
<dt><strong><code>measurements</code></strong> :&ensp;<code>Measurements</code></dt>
<dd>Measurements object.</dd>
<dt><strong><code>global_composition</code></strong> :&ensp;<code>dict</code></dt>
<dd>containing the total system compositions.</dd>
<dt><strong><code>distance_matrix</code></strong> :&ensp;<code>list</code></dt>
<dd>all the Euclidean distances from one grid cell
to another.</dd>
<dt><strong><code>nearness_matrix</code></strong> :&ensp;<code>list</code></dt>
<dd>same as above but with normalized distances.</dd>
</dl>
<p>alpha np.ndarray[n_households]
temperature float
utility_at_max np.ndarray[n_households]
optimal_fraction np.ndarray [n_households]
neighbourhood_mixture np.ndarray [n_households]
chosen_indices np.ndarray [n_households]
school_ended boolean
res_ended boolean
Cached attributes:
kernel (ndarray)
set: calc_residential_compositions
used: calc_residential_compositions
local_compositions (list, ndarray) [n_households, ndarray]
set: set_agent_parameters, overwritten in load_agents, update_residential
used: calc_res_utilities
normalized_compositions (ndarray) [width, height, len(params['group_types'][0])]
set: calc_residential_compositions
used: set_agent_parameters
neighbourhood_compositions (list, ndarray) [n_households]
set: set_agent_parameters, update_residential
used: load_agents, calc_res_utilities
school_compositions (ndarray, float32) [n_households]
set: set_agent_parameters, calc_school_compositions, update_school
used: calc_school_utilities
alpha (ndarray, float32) [n_households]
set: set_agent_parameters
used: calc_school_utilities, calc_school_rankings
temperature (float?)
set: set_agent_parameters
used: (calc_school_rankings, residential_ranking but from params)
utility_at_max (ndarray, float32) [n_households]
set: set_agent_parameters
used: calc_res_utilities, calc_school_utilities , calc_school_rankings
(residential_utility, but from params)
optimal_fraction (ndarray, float32) [n_households]
set: set_agent_parameters
used: calc_res_utilities, calc_school_utilities, calc_school_rankings
neighbourhood_mixture (ndarray, int) [n_households]
TODO: np.ushort?
set: set_agent_parameters
used: calc_res_utilities
distance_utilities(ndarray) [n_households, n_schools]
set: set_agent_parameters
used: calc_school_rankings, update_school
all_distances:
(ndarray) [n_households, n_schools] FIXME
household_attrs (ndarray, float) [width, height, len(params['group_types'][0])]
compositions (ndarray, float32)
as household_attrs</p>
<p>Create a new model. Overload this method with the actual code to
start the model.</p>
<h2 id="attributes_1">Attributes</h2>
<dl>
<dt><strong><code>schedule</code></strong></dt>
<dd>schedule object</dd>
<dt><strong><code>running</code></strong></dt>
<dd>a bool indicating if the model should continue running</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompassModel(Model):
    &#34;&#34;&#34;
    Model class for school segregation dynamics.
    Args:
        params (Argparser): containing all parameter values.
    Attributes:
        params (dict):
        grid (MultiGrid): MultiGrid object from Mesa.
        scheduler (ThreeStagedActivation): ThreeStagedActivation object.
        agents (list): all agents in the model.
        measurements (Measurements): Measurements object.
        global_composition (dict): containing the total system compositions.
        distance_matrix (list): all the Euclidean distances from one grid cell
            to another.
        nearness_matrix (list): same as above but with normalized distances.
        alpha np.ndarray[n_households]
        temperature float
        utility_at_max np.ndarray[n_households]
        optimal_fraction np.ndarray [n_households]
        neighbourhood_mixture np.ndarray [n_households]
        chosen_indices np.ndarray [n_households]
        school_ended boolean
        res_ended boolean
    Cached attributes:
        kernel (ndarray)
            set: calc_residential_compositions
            used: calc_residential_compositions
        local_compositions (list, ndarray) [n_households, ndarray]
            set: set_agent_parameters, overwritten in load_agents, update_residential
            used: calc_res_utilities
        normalized_compositions (ndarray) [width, height, len(params[&#39;group_types&#39;][0])]
            set: calc_residential_compositions
            used: set_agent_parameters
        neighbourhood_compositions (list, ndarray) [n_households]
            set: set_agent_parameters, update_residential
            used: load_agents, calc_res_utilities
        school_compositions (ndarray, float32) [n_households]
            set: set_agent_parameters, calc_school_compositions, update_school
            used: calc_school_utilities
        alpha (ndarray, float32) [n_households]
            set: set_agent_parameters
            used: calc_school_utilities, calc_school_rankings
        temperature (float?)
            set: set_agent_parameters
            used: (calc_school_rankings, residential_ranking but from params)
        utility_at_max (ndarray, float32) [n_households]
            set: set_agent_parameters
            used: calc_res_utilities, calc_school_utilities , calc_school_rankings
            (residential_utility, but from params)
        optimal_fraction (ndarray, float32) [n_households]
            set: set_agent_parameters
            used: calc_res_utilities, calc_school_utilities, calc_school_rankings
        neighbourhood_mixture (ndarray, int) [n_households]  TODO: np.ushort?
            set: set_agent_parameters
            used: calc_res_utilities
        distance_utilities(ndarray) [n_households, n_schools]
            set: set_agent_parameters
            used: calc_school_rankings, update_school
        all_distances:  (ndarray) [n_households, n_schools] FIXME
        household_attrs (ndarray, float) [width, height, len(params[&#39;group_types&#39;][0])]
        compositions (ndarray, float32)  as household_attrs
    &#34;&#34;&#34;

    def __init__(self, export: bool = False, **params: dict):

        super().__init__()

        # Use random from the numpy package for extra functionality
        self.random = np.random.RandomState(self._seed)

        # define various arrays TODO: sort/document those
        self.local_compositions: List = []
        self.neighbourhood_compositions: List = []
        self.alpha: np.ndarray = np.ndarray([])
        self.temperature: float = 0.0
        self.utility_at_max: np.ndarray = np.ndarray([])
        self.optimal_fraction: np.ndarray = np.ndarray([])
        self.neighbourhood_mixture: np.ndarray = np.ndarray([])
        self.school_compositions: np.ndarray = np.ndarray([])
        self.school_ended: bool = False
        self.res_ended: bool = False
        self.distance_utilities: np.ndarray = np.ndarray([])
        self.chosen_indices: np.ndarray = np.ndarray([])

        self.household_attrs: np.ndarray = np.ndarray([])
        self.compositions: np.ndarray = np.ndarray([])
        self.normalized_compositions: np.ndarray = np.ndarray([])

        self.all_distances: np.ndarray = np.ndarray([])
        self.kernel: np.ndarray = np.ndarray([])

        # Initialise the model attributes
        self.set_attributes(params=params, export=export)

        if self.params[&#34;case&#34;].lower() != &#34;lattice&#34;:
            self.load_agents(self.params[&#34;case&#34;].lower())
        else:
            self.create_agents()

        # Get values of the initial configuration
        self.measurements.end_step(residential=True)

        # Calculate global compositions for the segregation calculations
        self.global_composition = self.measurements.neighbourhoods[0, :, :2].sum(axis=0)

        if self.verbose:
            text = f&#34;&#34;&#34; Model initialised:
                NR AGENTS:
                Households: {self.params[&#39;n_households&#39;]}
                Neighbourhoods: {self.params[&#39;n_neighbourhoods&#39;]}
                Schools: {self.params[&#39;n_schools&#39;]}
                In scheduler: {self.scheduler.get_agent_count()}&#34;&#34;&#34;
            print(text)

    def set_attributes(self, params: dict, export=False) -&gt; None:
        &#34;&#34;&#34;
        Sets or calculates all attributes used in the Compass class.
        Args:
            params (Argparser): containing all parameter values.
            export (bool): True if the data needs to be exported or not.
        &#34;&#34;&#34;

        # Calculate number of households and students
        params[&#34;n_households&#34;] = int(
            params[&#34;household_density&#34;]
            * (
                params[&#34;width&#34;] * params[&#34;height&#34;]
                - params[&#34;n_neighbourhoods&#34;]
                - params[&#34;n_schools&#34;]
            )
        )
        params[&#34;n_students&#34;] = int(params[&#34;n_households&#34;] * params[&#34;student_density&#34;])
        self.params = dict(params)

        # Set tracking attributes
        self.export = export
        # Track segregation over time
        self.segregation: List[float] = []
        self.res_ended = False
        self.school_ended = False
        self.verbose = self.params[&#34;verbose&#34;]
        self.agents: Dict[str, List[object]] = {
            &#34;amount&#34;: 0,
            &#34;households&#34;: [],
            &#34;schools&#34;: [],
            &#34;neighbourhoods&#34;: [],
        }

        # Initialise other objects
        self.measurements = Measurements(self)
        self.scheduler = ThreeStagedActivation(self)
        self.grid = ContinuousSpace(
            self.params[&#34;width&#34;], self.params[&#34;height&#34;], torus=self.params[&#34;torus&#34;]
        )

    def create_agents(self) -&gt; None:
        &#34;&#34;&#34;
        Creates the agents when no case study is provided.
        &#34;&#34;&#34;
        self.neighbourhoods()
        self.schools()
        self.location_to_agent()

        # Compute closest neighbourhoods
        self.closest_neighbourhoods = self.compute_closest_neighbourhoods()

        # Create households
        self.households()

    def set_agent_parameters(self, params: dict) -&gt; None:
        &#34;&#34;&#34;
        Puts the agent parameters in numpy arrays for faster computations.
        Args:
            params (dict): Model parameters which could differ from
                the agent params!
        Todo:
            Parameters should be imported from a config file in the future.
        &#34;&#34;&#34;
        households = self.get_agents(&#34;households&#34;)
        n_households = len(households)

        dtype = &#34;float32&#34;
        self.alpha = np.zeros(n_households, dtype=dtype)
        self.temperature = self.params[
            &#34;temperature&#34;
        ]  # FIXME: different temp per agent?
        self.utility_at_max = np.zeros(n_households, dtype=dtype)
        self.optimal_fraction = np.zeros(n_households, dtype=dtype)
        self.neighbourhood_mixture = np.ones(n_households, dtype=int)

        optimal_fractions = trunc_normal_sample(
            params[&#34;optimal_fraction&#34;][0],
            scale=params[&#34;homophily_std&#34;],
            size=n_households,
            seed=self.random
        )
        alphas = trunc_normal_sample(
            [params[&#34;alpha&#34;], params[&#34;alpha&#34;]],
            scale=params[&#34;homophily_std&#34;],
            size=n_households,
            seed=self.random
        )
        utility_at_maxs = trunc_normal_sample(
            params[&#34;utility_at_max&#34;][0],
            scale=params[&#34;homophily_std&#34;],
            size=n_households,
            seed=self.random
        )

        for household in households:
            x, y = household.pos

            # Fill arrays with agent parameter values for faster computations
            self.optimal_fraction[household.idx] = optimal_fractions[
                household.category
            ][household.idx]
            self.alpha[household.idx] = alphas[household.category][household.idx]
            self.utility_at_max[household.idx] = utility_at_maxs[household.category][
                household.idx
            ]

            # Currently only convolution (assumes every household has the same
            # radius) for composition calculations within the lattice case.
            if params[&#34;case&#34;].lower() == &#34;lattice&#34;:
                self.local_compositions.append(
                    self.normalized_compositions[x, y, household.category]
                )
            else:
                household.params[&#34;neighbourhood_mixture&#34;] = 1

            if household.neighbourhood.total &gt; 0:
                norm = 1.0 / household.neighbourhood.total
            else:
                norm = 1.0
            self.neighbourhood_compositions.append(
                household.neighbourhood.composition[household.category] * norm
            )

        # These are filled with the actual distance and composition utilities
        # of the household and the school (singular!) they attend

        # SHOULD BE CALLED DIFFERENTLY CAUSE NOW IT OVERWRITES AN ATTRIBUTE!!!
        self.school_compositions = np.zeros(n_households, dtype=dtype)

        # Distance utilities based on sigmoid function
        if self.params[&#34;case&#34;].lower() != &#34;lattice&#34;:
            p = self.params[&#34;p&#34;]
            q = self.params[&#34;q&#34;]
            self.distance_utilities = 1.0 / (1 + (self.all_distances / p) ** q)

    def neighbourhoods(self) -&gt; None:
        &#34;&#34;&#34;
        Adds the neighbourhood objects to the environment.
        &#34;&#34;&#34;

        n_neighs = self.params[&#34;n_neighbourhoods&#34;]

        # Add neighbourhoods if necessary
        if n_neighs:
            locations = self.choose_locations(
                n_neighs, self.params[&#34;neighbourhoods_placement&#34;]
            )
            for location in locations:
                size = self.params[&#34;width&#34;] / float(n_neighs**0.5 * 2)
                minx, miny = location[0] - size, location[1] - size
                maxx, maxy = location[0] + size, location[1] + size
                shape = box(minx, miny, maxx, maxy)

                # Create the Neighbourhood object and place it on the grid and
                # add it to the scheduler
                neighbourhood = Neighbourhood(
                    self.get_agents(&#34;amount&#34;), location, shape, self, self.params
                )
                self.agents[&#34;neighbourhoods&#34;].append(neighbourhood)
                self.scheduler.add(neighbourhood)
                self.grid.place_agent(neighbourhood, location)

    def schools(self) -&gt; None:
        &#34;&#34;&#34;
        Adds the school objects to the environment.
        &#34;&#34;&#34;

        School.reset()

        # Add schools if necessary
        if self.params[&#34;n_schools&#34;]:
            locations = self.choose_locations(
                self.params[&#34;n_schools&#34;], self.params[&#34;schools_placement&#34;]
            )
            for location in locations:
                # Create the School object and place it on the grid and add it
                # to the scheduler
                school = School(self.get_agents(&#34;amount&#34;), location, self, self.params)
                self.agents[&#34;schools&#34;].append(school)
                self.scheduler.add(school)
                self.grid.place_agent(school, location)

    def households(self) -&gt; None:
        &#34;&#34;&#34;
        Adds the household objects to the environment.
        Todo:
            * Place household specific parameters in a attribute called params
        &#34;&#34;&#34;

        params = self.params
        self.chosen_indices = None  # Only matters for case studies
        self.household_attrs = np.zeros(
            shape=(params[&#34;width&#34;], params[&#34;height&#34;], len(params[&#34;group_types&#34;][0])),
            dtype=&#34;float32&#34;,
        )

        # Create group types, empty spots and shuffle them both
        n_groups = len(params[&#34;group_categories&#34;])
        groups = [
            self.random.choice(
                list(range(0, len(params[&#34;group_types&#34;][i]))),
                size=params[&#34;n_households&#34;],
                p=params[&#34;group_dist&#34;][i],
            )
            for i in range(n_groups)
        ]

        self.grid.empties = set(
            [(x, y) for x in range(params[&#34;width&#34;]) for y in range(params[&#34;height&#34;])]
        )
        empties = list(self.grid.empties)
        self.random.shuffle(empties)

        # pre-allocate storage for the Housholds
        Household.reset(max_households=params[&#34;n_households&#34;])

        for i, position in enumerate(empties[0 : params[&#34;n_households&#34;]]):
            household = Household(
                self.get_agents(&#34;amount&#34;), position, self, params, groups[0][i]
            )

            # Place households on the grid and add them to the scheduler
            self.agents[&#34;households&#34;].append(household)
            self.grid.place_agent(household, position)
            self.grid.empties.discard(position)
            self.scheduler.add(household)
            self.household_attrs[position[0], position[1], :] = household.attributes

        # Calculate AFTER all agents are placed
        self.calc_residential_compositions()
        self.set_agent_parameters(params)
        self.calc_res_utilities()

    def load_agents(self, case=&#34;Amsterdam&#34;) -&gt; None:
        &#34;&#34;&#34;
        Load the agents from several files.
        Note:
            This function is in progress and works only for the
            Amsterdam case now.
        &#34;&#34;&#34;

        dirname = os.path.dirname(__file__)
        if case.lower() == &#34;amsterdam&#34;:
            path = dirname + &#34;/maps/amsterdam&#34;
        elif case.lower() == &#34;south-london&#34;:
            path = dirname + &#34;/maps/south-london&#34;
        elif case.lower() == &#34;london&#34;:
            path = dirname + &#34;/maps/london&#34;

        # Load GeoDataFrames
        school_frame = gpd.read_file(path + &#34;/schools.geojson&#34;)
        household_frame = read_households(path + &#34;/households.geojson&#34;)
        neighbourhood_frame = gpd.read_file(path + &#34;/neighbourhoods.geojson&#34;)

        # Create grid
        self.params[&#34;torus&#34;] = 0
        self.params[&#34;max_res_steps&#34;] = 0
        xmin, ymin, xmax, ymax = neighbourhood_frame.total_bounds
        self.grid = ContinuousSpace(xmax, ymax, self.params[&#34;torus&#34;], xmin, ymin)
        self.grid.empties = [(0, 0)]

        # In the file more households could be available to sample from,
        # but only use the actual amount
        data = np.load(path + &#34;/distances_perc_of_actual.npz&#34;)
        perc_of_actual = data[&#34;perc_of_actual&#34;]
        self.all_distances = data[&#34;distances&#34;]

        self.scheduler = ThreeStagedActivation(self)

        # More agents are simulated to sample from them and incorporate some
        # randomness in the type and spatial distribution
        total_households = len(household_frame)
        actual_households = int(total_households / perc_of_actual)
        self.params[&#34;n_households&#34;] = actual_households
        self.params[&#34;n_students&#34;] = int(
            self.params[&#34;n_households&#34;] * self.params[&#34;student_density&#34;]
        )

        # Create neighbourhoods
        self.create_neighbourhoods(neighbourhood_frame)

        # Create schools
        self.create_schools(school_frame)

        # Create households
        self.create_households(household_frame, actual_households)

        if self.verbose:
            print(&#34;Setting agent parameters...&#34;)
        self.set_agent_parameters(self.params)

        self.local_compositions = self.neighbourhood_compositions
        self.calc_res_utilities()

        if self.verbose:
            print(&#34;Model loaded!&#34;)

    def create_neighbourhoods(self, neighbourhood_frame: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Given a GeoDataFrame, this creates all the neighbourhood objects
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Creating neighbourhoods...&#34;)

        self.params[&#34;n_neighbourhoods&#34;] = len(neighbourhood_frame)
        for index, row in neighbourhood_frame.iterrows():
            neighbourhood = Neighbourhood(
                unique_id=index,
                pos=(row.geometry.centroid.xy[0][0], row.geometry.centroid.xy[1][0]),
                shape=row.geometry,
                model=self,
                params=self.params,
            )
            self.agents[&#34;neighbourhoods&#34;].append(neighbourhood)
            self.scheduler.add(neighbourhood)
            self.grid.place_agent(neighbourhood, neighbourhood.pos)

    def create_schools(self, school_frame: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Given a GeoDataFrame, this creates all the school objects
        &#34;&#34;&#34;

        School.reset()

        if self.verbose:
            print(&#34;Creating schools...&#34;)

        self.params[&#34;n_schools&#34;] = len(school_frame)
        n_neighbourhoods = self.params[&#34;n_neighbourhoods&#34;]
        for index, row in school_frame.iterrows():
            school = School(
                unique_id=index + n_neighbourhoods,
                pos=(row.geometry.xy[0][0], row.geometry.xy[1][0]),
                model=self,
                params=self.params,
            )
            school.capacity = 1 + int(
                self.params[&#34;school_capacity&#34;]
                * self.params[&#34;n_students&#34;]
                / self.params[&#34;n_schools&#34;]
            )
            self.agents[&#34;schools&#34;].append(school)
            self.scheduler.add(school)
            self.grid.place_agent(school, school.pos)

    def create_households(
        self, household_frame: pd.DataFrame, actual_households: int
    ) -&gt; None:
        &#34;&#34;&#34;
        Given a GeoDataFrame, this creates household objects by randomly
        drawing (without replacement) household metadata rows from the frame.
        Arguments
            actual_households (int)
                The number of households to create.
        Parameters used
            params[&#39;random_residential&#39;]
        Parameters set
            params[&#39;n_households&#39;]
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Creating households...&#34;)

        self.chosen_indices = self.random.choice(
            len(household_frame), size=actual_households, replace=False
        )
        households_sample = household_frame.iloc[self.chosen_indices]

        if self.params[&#34;random_residential&#34;]:
            # Randomly shuffle the group of the household
            shuffled = households_sample[&#34;group&#34;].values
            self.random.shuffle(shuffled)
            households_sample[&#34;group&#34;] = shuffled

        self.params[&#34;n_households&#34;] = actual_households
        n_agents = self.params[&#34;n_neighbourhoods&#34;] + self.params[&#34;n_schools&#34;]
        neighbourhoods = self.get_agents(&#34;neighbourhoods&#34;)

        self.all_distances = self.all_distances[self.chosen_indices, :]

        # pre-allocate storage for the Housholds
        Household.reset(max_households=actual_households)

        # DataFrame.iterrows() is very slow, dont use it!
        # the current code uses only iterates (no copies)
        # and should be memory-friendly and performant:
        # accumulated time for create_households:
        # for the testcase with  60K households from 9.10 to 2.60 seconds
        # for the testcase with 210K households from 30.0 to 9.27 seconds
        for index, row in enumerate(
            zip(
                households_sample[&#34;pos&#34;],
                households_sample[&#34;category&#34;],
                households_sample[&#34;neighbourhood_id&#34;],
            )
        ):
            household = Household(
                unique_id=index + n_agents,
                pos=row[0],
                model=self,
                params=self.params,
                category=row[1],
                nhood=neighbourhoods[row[2]],
            )
            self.agents[&#34;households&#34;].append(household)
            self.scheduler.add(household)
            self.grid.place_agent(household, household.pos)

        self.location_to_agent()

    def location_to_agent(self) -&gt; None:
        &#34;&#34;&#34;
        Creates a dictionary with the location of the neighbourhoods as key and
        the object itself as value. Schools are not included as they can have
        the same position as a neighbourhood (centroid).
        &#34;&#34;&#34;
        agents = self.get_agents(&#34;neighbourhoods&#34;)
        self.location_to_agent = {str(agent.pos): agent for agent in agents}

    def calc_residential_compositions(self) -&gt; None:
        &#34;&#34;&#34;
        Updates all local residential compositions assuming all households have
        the SAME RADIUS.
        &#34;&#34;&#34;

        # Determine the kernel of the convolution
        radius = self.params[&#34;radius&#34;]
        dim = radius * 2 + 1
        self.kernel = np.ones((dim, dim))
        self.kernel[radius, radius] = 0

        # Should it wrap around the edges or not?
        if self.params[&#34;torus&#34;]:
            mode = &#34;wrap&#34;
        else:
            mode = &#34;constant&#34;

        summed = 0
        num_attrs = self.household_attrs.shape[2]
        compositions = np.zeros(shape=self.household_attrs.shape, dtype=&#34;float32&#34;)

        # Convolution for every household attribute.
        for attr in range(num_attrs):
            compositions[:, :, attr] = convolve(
                self.household_attrs[:, :, attr], self.kernel, mode=mode
            )
            summed += compositions[:, :, attr]
        self.compositions = compositions
        self.normalized_compositions = np.nan_to_num(
            compositions / np.repeat(summed[:, :, np.newaxis], num_attrs, axis=2)
        )

    def calc_school_compositions(self) -&gt; None:
        &#34;&#34;&#34;
        Calculate the new school compositions for every household and only for
        the first student!
        Note:
            Currently only for the first student!!!
        &#34;&#34;&#34;

        households = self.get_agents(&#34;households&#34;)
        for household in households:
            category = household.category
            idx = household.idx
            school = household.school
            if school.total:
                self.school_compositions[idx] = (
                    school.composition[category] / school.total
                )
            else:
                self.school_compositions[idx] = 0.0

    def calc_res_utilities(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates residential utility at a household its current position and
        given its parameter values.
        &#34;&#34;&#34;

        b = self.neighbourhood_mixture
        f = self.optimal_fraction
        M = self.utility_at_max
        x = (1 - b) * self.local_compositions + b * self.neighbourhood_compositions

        calc_comp_utility(Household._household_res_utility, x, M, f)

    def calc_school_utilities(self) -&gt; None:
        &#34;&#34;&#34;
        Calculates school utilities at a student its current school, given
        distance and its other parameter values.
        &#34;&#34;&#34;

        alpha = self.alpha
        f = self.optimal_fraction
        M = self.utility_at_max
        x = self.school_compositions

        calc_comp_utility(Household._household_school_utility_comp, x, M, f)

        # TODO: This needs to be correct, what distances to use?
        Household._household_school_utility = (
            Household._household_school_utility_comp * alpha
        ) + (Household._household_distance * (1 - alpha))

    def calc_school_rankings(
        self, households: List[Household], schools: List[School]
    ) -&gt; None:
        &#34;&#34;&#34;
        Ranks the schools according to utility.
        Note: this is probably a performance bottleneck; one of the array is
        of size [n_households_moving, n_of_schools].
        Args:
            households (list): list of households the rankings need to be
                calculated for.
            schools (list): list of schools that need to be ranked.
        Todo:
            Schools can differ per household if we only want to look at the
            n-closest schools for example?
        &#34;&#34;&#34;
        if len(schools) == 0 or len(households) == 0:
            return

        zeros = np.zeros(len(self.params[&#34;group_types&#34;][0]))
        compositions = np.array(
            [
                school.composition / school.total if school.total &gt; 0 else zeros
                for school in schools
            ],
            dtype=&#34;float32&#34;,
        )

        households_data = np.array(
            [(h.idx, h.category) for h in households], dtype=int
        ).T
        households_indices = households_data[0, :]
        households_categories = households_data[1, :]

        # Composition utility calculations
        t = np.take(self.optimal_fraction, households_indices)  # [n_indices]
        M = np.take(self.utility_at_max, households_indices)  # [n_indices]
        x = np.take(
            compositions, households_categories, axis=1
        )  # [n_schools, n_indices]
        composition_utilities = np.where(x &lt;= t, x / t, M + (1 - x) * (1 - M) / (1 - t))

        # Combined (THIS SHOULD BE GENERALISED TO INCLUDE MORE FACTORS)
        utilities = (
            composition_utilities * self.alpha[np.newaxis, households_indices]
            + (
                np.take(self.distance_utilities, households_indices, axis=0)
                * (1 - self.alpha[households_indices, np.newaxis])
            ).T
        )
        # utilities.shape = (len(schools), len(households))

        # Rank the schools according to the household utilities
        # TODO: is this the right utility? ie. residential=False?
        households_utilities = np.take(
            Household._household_school_utility, households_indices
        )

        method = self.params[&#34;ranking_method&#34;].lower()
        if method == &#34;proportional&#34;:
            differences = utilities - households_utilities[np.newaxis, :]
            exp_utilities = np.exp(self.temperature * differences)
            transformed = exp_utilities / exp_utilities.sum(axis=0)[np.newaxis, :]

        elif method == &#34;highest&#34;:
            transformed = utilities

        else:
            print(&#34;Method not implementd.&#34;)
            sys.exit()

        # instead of reversing the list, sort the negative values in the list
        ranked_indices = (-transformed).argsort(axis=0, kind=&#39;quicksort&#39;)

        # necessary to allow indexing with the argsort result
        schools = np.array(schools)

        for i, household in enumerate(households):
            ranking = schools[ranked_indices[:, i]]

            # TODO: can we make school preference a Household property,
            # instead of a Student property? gives ~10% extra speedup
            for student in household.students:
                student.set_school_preference(ranking)

    def get_attributes(self, pos: tuple[float, float]) -&gt; np.ndarray:

        &#34;&#34;&#34;
        Returns the attribute vector of a given position
        Args:
            pos (tuple): (x,y) coordinates.
        Returns:
            Numpy array: containing all the attributes (all zeros if empty)
        &#34;&#34;&#34;
        return self.household_attrs[pos[0], pos[1], :]

    def switch_attrs(
        self, pos1: tuple[float, float], pos2: tuple[float, float]
    ) -&gt; None:
        &#34;&#34;&#34;
        Switches two attribute vectors in the attribute grid by making a copy.
        Args:
            pos1 (tuple): (x,y) coordinates.
            pos2 (tuple): (x,y) coordinates.
        &#34;&#34;&#34;
        temp = np.copy(self.household_attrs[pos1])
        self.household_attrs[pos1] = self.household_attrs[pos2]
        self.household_attrs[pos2] = temp

    def step(self, residential: bool = False, initial_schools: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Perform model steps.
        Args:
            residential (bool): True if a residential step needs to be done,
                False (default) means a school step.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;

        # Perform school or residential step.
        self.scheduler.step(residential=residential, initial_schools=initial_schools)

    def simulate(self, res_steps: int = None, school_steps: int = None) -&gt; None:
        &#34;&#34;&#34;
        Performs #res_steps of residential steps and #school_steps of school
        steps.
        Args:
            res_steps (int): Number of residential steps.
            school_steps (int): Number of school steps.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;

        if not res_steps:
            res_steps = self.params[&#34;max_res_steps&#34;]

        if not school_steps:
            school_steps = self.params[&#34;max_school_steps&#34;]

        while self.scheduler.get_time(&#34;residential&#34;) &lt; res_steps and not self.res_ended:

            if self.verbose:
                f = (
                    &#34;Residential process: step &#34;
                    + str(self.scheduler.get_time(&#34;residential&#34;) + 1)
                    + &#34; from &#34;
                    + str(res_steps)
                )
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()

            self.res_ended = self.convergence_check()
            if not self.res_ended:
                self.step(residential=True)
            else:
                break

        if self.verbose:
            print()

        while (
            self.scheduler.get_time(&#34;school&#34;) &lt; school_steps and not self.school_ended
        ):

            if self.verbose:
                f = (
                    &#34;School process: step &#34;
                    + str(self.scheduler.get_time(&#34;school&#34;) + 1)
                    + &#34; from &#34;
                    + str(school_steps)
                )
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()

            self.school_ended = self.convergence_check()

            if self.scheduler.school_steps == 0:
                self.step(residential=False, initial_schools=True)
            else:
                if not self.school_ended:
                    self.step(residential=False, initial_schools=False)
                else:
                    break

        if self.verbose:
            print()
            print(&#34;Processes ended&#34;)
        self.export_data(self.export)

    def convergence_check(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the processes have converged.
        Returns: True if converged.
        &#34;&#34;&#34;
        window_size = self.params[&#34;window_size&#34;]
        time = self.scheduler.get_time()
        school_time = self.scheduler.get_time(&#34;school&#34;)

        # Check what type of segregation to calculate (i.e., which of the
        # processes is running)
        if not self.res_ended:
            self.segregation.append(
                self.measurements.calculate_segregation(
                    type=&#34;bounded_neighbourhood&#34;, index=&#34;Theil&#34;
                )
            )
        else:
            self.segregation.append(
                self.measurements.calculate_segregation(type=&#34;school&#34;, index=&#34;Theil&#34;)
            )

        # Wait until there is enough steps in the school process
        if self.res_ended and school_time &lt; window_size:
            return False

        # Check all metrics in the window size and check if they are below
        # the convergence threshold
        if time &gt;= window_size - 1:
            utilities = self.measurements.households[
                time - window_size + 1 : time + 1, :, 4
            ]
            means = utilities.mean(axis=1)
            stds = utilities.std(axis=1)

            metrics = np.vstack(
                (means, stds, self.segregation[time - window_size + 1 : time + 1])
            )

            metric_means = np.repeat(
                metrics.mean(axis=1)[:, np.newaxis], window_size, axis=1
            )
            mad = np.abs(metrics - metric_means)
            if np.all(mad &lt; self.params[&#34;conv_threshold&#34;]):
                # Start over if the residential process has converged
                self.res_ended = True
                return True

        return False

    def choose_locations(
        self, amount: int, method: str = &#34;evenly_spaced&#34;
    ) -&gt; List[tuple[float, float]]:
        &#34;&#34;&#34;
        Compute a number of locations to place school and neighbourhood objects.
        Args:
            amount (int): the number of agents to place.
            method (str): one of &#39;evenly_spaced&#39;, &#39;random&#39;, &#39;random_per_neighbourhood&#39;
        Returns:
            list: containing all the locations in tuple (x,y) format.
        &#34;&#34;&#34;

        if amount == 0:
            return []

        if method == &#34;evenly_spaced&#34;:
            per_side = np.sqrt(amount)
            if per_side % 1 != 0:
                print(&#34;Unable to place amount of locations using given method&#34;)
                sys.exit(1)

            # Compute locations
            per_side = int(per_side)
            xs = np.linspace(0, self.params[&#34;width&#34;], per_side * 2 + 1)[1::2]
            ys = np.linspace(0, self.params[&#34;height&#34;], per_side * 2 + 1)[1::2]
            return [(x, y) for x in xs for y in ys]

        elif method == &#34;random&#34;:
            locations = []
            i = 0
            while i &lt; amount:
                x_coord = self.random.randint(low=0, high=self.params[&#34;width&#34;])
                y_coord = self.random.randint(low=0, high=self.params[&#34;height&#34;])
                if (x_coord, y_coord) not in locations:
                    locations.append((x_coord, y_coord))
                    i += 1
            return locations

        elif method == &#34;random_per_neighbourhood&#34;:
            locations = []
            width, height = self.params[&#34;width&#34;], self.params[&#34;height&#34;]
            n_schools = self.params[&#34;n_schools&#34;]
            n_neighbourhoods = self.params[&#34;n_neighbourhoods&#34;]
            per_side = int(np.sqrt(n_neighbourhoods))
            location_width = width / per_side
            location_height = height / per_side

            # Draw a random sample per neighbourhood as long as there are
            # schools to place
            i = 0
            while i &lt; max(n_neighbourhoods, n_schools):
                y_low = 0
                for col in range(per_side):
                    x_low = 0
                    y_high = int((1 + col) * location_height)

                    for row in range(per_side):

                        x_high = int((1 + row) * location_width)

                        if x_high &gt;= width:
                            x_high = width - 1
                        elif y_high &gt;= height:
                            y_high = height - 1

                        x_coord = self.random.randint(low=x_low, high=x_high)
                        y_coord = self.random.randint(low=y_low, high=y_high)

                        # Check if the coordinates haven&#39;t already been sampled
                        while (x_coord, y_coord) in locations:
                            x_coord = self.random.randint(low=x_low, high=x_high)
                            y_coord = self.random.randint(low=y_low, high=y_high)

                        locations.append((x_coord, y_coord))
                        x_low = x_high + 1
                        i += 1
                    y_low = y_high + 1

            # Shuffle all locations if n_schools &lt;= n_neighbourhoods, otherwise
            # shuffle only the remainder
            if n_schools &lt;= n_neighbourhoods:
                self.random.shuffle(locations)
            else:
                divider = int(n_schools / n_neighbourhoods)
                remainder = n_schools % n_neighbourhoods
                first_locations = locations[: n_neighbourhoods * divider]
                rest_locations = locations[n_neighbourhoods * divider :]
                self.random.shuffle(rest_locations)
                locations = first_locations + rest_locations[:remainder]

            return locations

        print(f&#34;Unknown method in choose_locations {method} __file__:__line__&#34;)
        sys.exit(-1)

    def compute_closest_neighbourhoods(self) -&gt; dict:
        &#34;&#34;&#34;
        Compute distance from all grid cells to all schools and all
        neighbourhood objects.
        Returns:
            dict: of dicts containing all Euclidean distances
        &#34;&#34;&#34;

        EPS = 1.2e-6
        closest_neighbourhoods = {}
        neighbourhoods = self.get_agents(&#34;neighbourhoods&#34;)

        for x in range(self.params[&#34;width&#34;]):
            for y in range(self.params[&#34;height&#34;]):

                # Loop over all neighbourhoods, calculate distance and save
                # closest
                point = Point(x, y)
                for neighbourhood in neighbourhoods:
                    shape = neighbourhood.shape.buffer(EPS)
                    if shape.contains(point):
                        closest_neighbourhoods[str((x, y))] = str(neighbourhood.pos)
                        break

        return closest_neighbourhoods

    def compute_school_distances(self) -&gt; None:
        &#34;&#34;&#34;
        Computes school distances.
        &#34;&#34;&#34;
        self.all_distances = np.zeros(
            (self.params[&#34;n_households&#34;], self.params[&#34;n_schools&#34;])
        )
        school_frame = gpd.GeoSeries(
            [Point(school.pos) for school in self.get_agents(&#34;schools&#34;)]
        )
        for household in self.get_agents(&#34;households&#34;):
            self.all_distances[household.idx, :] = school_frame.distance(
                Point(household.pos)
            )

    def get_agents(self, agent_type: str) -&gt; List[object]:
        &#34;&#34;&#34;
        Returns list of agents of given type.
        Args:
            agent_type (str): either &#39;School&#39;, &#39;Neighbourhood&#39;, &#39;Household&#39; or
            &#39;Student&#39;.
        Returns:
            list: containing all the objects of the specified type.
        &#34;&#34;&#34;
        return self.agents[agent_type]

    def export_data(self, export=False) -&gt; None:
        &#34;&#34;&#34;
        Export data for visualization.
        &#34;&#34;&#34;
        if export:
            self.measurements.export_data()

    def increment_agent_count(self) -&gt; None:
        &#34;&#34;&#34;
        Increment agent count by one.
        &#34;&#34;&#34;
        self.agents[&#34;amount&#34;] += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mesa.model.Model</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="compass.model.CompassModel.calc_res_utilities"><code class="name flex">
<span>def <span class="ident">calc_res_utilities</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates residential utility at a household its current position and
given its parameter values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_res_utilities(self) -&gt; None:
    &#34;&#34;&#34;
    Calculates residential utility at a household its current position and
    given its parameter values.
    &#34;&#34;&#34;

    b = self.neighbourhood_mixture
    f = self.optimal_fraction
    M = self.utility_at_max
    x = (1 - b) * self.local_compositions + b * self.neighbourhood_compositions

    calc_comp_utility(Household._household_res_utility, x, M, f)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_residential_compositions"><code class="name flex">
<span>def <span class="ident">calc_residential_compositions</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates all local residential compositions assuming all households have
the SAME RADIUS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_residential_compositions(self) -&gt; None:
    &#34;&#34;&#34;
    Updates all local residential compositions assuming all households have
    the SAME RADIUS.
    &#34;&#34;&#34;

    # Determine the kernel of the convolution
    radius = self.params[&#34;radius&#34;]
    dim = radius * 2 + 1
    self.kernel = np.ones((dim, dim))
    self.kernel[radius, radius] = 0

    # Should it wrap around the edges or not?
    if self.params[&#34;torus&#34;]:
        mode = &#34;wrap&#34;
    else:
        mode = &#34;constant&#34;

    summed = 0
    num_attrs = self.household_attrs.shape[2]
    compositions = np.zeros(shape=self.household_attrs.shape, dtype=&#34;float32&#34;)

    # Convolution for every household attribute.
    for attr in range(num_attrs):
        compositions[:, :, attr] = convolve(
            self.household_attrs[:, :, attr], self.kernel, mode=mode
        )
        summed += compositions[:, :, attr]
    self.compositions = compositions
    self.normalized_compositions = np.nan_to_num(
        compositions / np.repeat(summed[:, :, np.newaxis], num_attrs, axis=2)
    )</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_school_compositions"><code class="name flex">
<span>def <span class="ident">calc_school_compositions</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the new school compositions for every household and only for
the first student!</p>
<h2 id="note">Note</h2>
<p>Currently only for the first student!!!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_school_compositions(self) -&gt; None:
    &#34;&#34;&#34;
    Calculate the new school compositions for every household and only for
    the first student!
    Note:
        Currently only for the first student!!!
    &#34;&#34;&#34;

    households = self.get_agents(&#34;households&#34;)
    for household in households:
        category = household.category
        idx = household.idx
        school = household.school
        if school.total:
            self.school_compositions[idx] = (
                school.composition[category] / school.total
            )
        else:
            self.school_compositions[idx] = 0.0</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_school_rankings"><code class="name flex">
<span>def <span class="ident">calc_school_rankings</span></span>(<span>self, households: List[<a title="compass.household.Household" href="household.html#compass.household.Household">Household</a>], schools: List[<a title="compass.school.School" href="school.html#compass.school.School">School</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Ranks the schools according to utility.
Note: this is probably a performance bottleneck; one of the array is
of size [n_households_moving, n_of_schools].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>households</code></strong> :&ensp;<code>list</code></dt>
<dd>list of households the rankings need to be
calculated for.</dd>
<dt><strong><code>schools</code></strong> :&ensp;<code>list</code></dt>
<dd>list of schools that need to be ranked.</dd>
</dl>
<h2 id="todo">Todo</h2>
<p>Schools can differ per household if we only want to look at the
n-closest schools for example?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_school_rankings(
    self, households: List[Household], schools: List[School]
) -&gt; None:
    &#34;&#34;&#34;
    Ranks the schools according to utility.
    Note: this is probably a performance bottleneck; one of the array is
    of size [n_households_moving, n_of_schools].
    Args:
        households (list): list of households the rankings need to be
            calculated for.
        schools (list): list of schools that need to be ranked.
    Todo:
        Schools can differ per household if we only want to look at the
        n-closest schools for example?
    &#34;&#34;&#34;
    if len(schools) == 0 or len(households) == 0:
        return

    zeros = np.zeros(len(self.params[&#34;group_types&#34;][0]))
    compositions = np.array(
        [
            school.composition / school.total if school.total &gt; 0 else zeros
            for school in schools
        ],
        dtype=&#34;float32&#34;,
    )

    households_data = np.array(
        [(h.idx, h.category) for h in households], dtype=int
    ).T
    households_indices = households_data[0, :]
    households_categories = households_data[1, :]

    # Composition utility calculations
    t = np.take(self.optimal_fraction, households_indices)  # [n_indices]
    M = np.take(self.utility_at_max, households_indices)  # [n_indices]
    x = np.take(
        compositions, households_categories, axis=1
    )  # [n_schools, n_indices]
    composition_utilities = np.where(x &lt;= t, x / t, M + (1 - x) * (1 - M) / (1 - t))

    # Combined (THIS SHOULD BE GENERALISED TO INCLUDE MORE FACTORS)
    utilities = (
        composition_utilities * self.alpha[np.newaxis, households_indices]
        + (
            np.take(self.distance_utilities, households_indices, axis=0)
            * (1 - self.alpha[households_indices, np.newaxis])
        ).T
    )
    # utilities.shape = (len(schools), len(households))

    # Rank the schools according to the household utilities
    # TODO: is this the right utility? ie. residential=False?
    households_utilities = np.take(
        Household._household_school_utility, households_indices
    )

    method = self.params[&#34;ranking_method&#34;].lower()
    if method == &#34;proportional&#34;:
        differences = utilities - households_utilities[np.newaxis, :]
        exp_utilities = np.exp(self.temperature * differences)
        transformed = exp_utilities / exp_utilities.sum(axis=0)[np.newaxis, :]

    elif method == &#34;highest&#34;:
        transformed = utilities

    else:
        print(&#34;Method not implementd.&#34;)
        sys.exit()

    # instead of reversing the list, sort the negative values in the list
    ranked_indices = (-transformed).argsort(axis=0, kind=&#39;quicksort&#39;)

    # necessary to allow indexing with the argsort result
    schools = np.array(schools)

    for i, household in enumerate(households):
        ranking = schools[ranked_indices[:, i]]

        # TODO: can we make school preference a Household property,
        # instead of a Student property? gives ~10% extra speedup
        for student in household.students:
            student.set_school_preference(ranking)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_school_utilities"><code class="name flex">
<span>def <span class="ident">calc_school_utilities</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates school utilities at a student its current school, given
distance and its other parameter values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_school_utilities(self) -&gt; None:
    &#34;&#34;&#34;
    Calculates school utilities at a student its current school, given
    distance and its other parameter values.
    &#34;&#34;&#34;

    alpha = self.alpha
    f = self.optimal_fraction
    M = self.utility_at_max
    x = self.school_compositions

    calc_comp_utility(Household._household_school_utility_comp, x, M, f)

    # TODO: This needs to be correct, what distances to use?
    Household._household_school_utility = (
        Household._household_school_utility_comp * alpha
    ) + (Household._household_distance * (1 - alpha))</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.choose_locations"><code class="name flex">
<span>def <span class="ident">choose_locations</span></span>(<span>self, amount: int, method: str = 'evenly_spaced') ‑> List[tuple[float, float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a number of locations to place school and neighbourhood objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of agents to place.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'evenly_spaced', 'random', 'random_per_neighbourhood'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing all the locations in tuple (x,y) format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_locations(
    self, amount: int, method: str = &#34;evenly_spaced&#34;
) -&gt; List[tuple[float, float]]:
    &#34;&#34;&#34;
    Compute a number of locations to place school and neighbourhood objects.
    Args:
        amount (int): the number of agents to place.
        method (str): one of &#39;evenly_spaced&#39;, &#39;random&#39;, &#39;random_per_neighbourhood&#39;
    Returns:
        list: containing all the locations in tuple (x,y) format.
    &#34;&#34;&#34;

    if amount == 0:
        return []

    if method == &#34;evenly_spaced&#34;:
        per_side = np.sqrt(amount)
        if per_side % 1 != 0:
            print(&#34;Unable to place amount of locations using given method&#34;)
            sys.exit(1)

        # Compute locations
        per_side = int(per_side)
        xs = np.linspace(0, self.params[&#34;width&#34;], per_side * 2 + 1)[1::2]
        ys = np.linspace(0, self.params[&#34;height&#34;], per_side * 2 + 1)[1::2]
        return [(x, y) for x in xs for y in ys]

    elif method == &#34;random&#34;:
        locations = []
        i = 0
        while i &lt; amount:
            x_coord = self.random.randint(low=0, high=self.params[&#34;width&#34;])
            y_coord = self.random.randint(low=0, high=self.params[&#34;height&#34;])
            if (x_coord, y_coord) not in locations:
                locations.append((x_coord, y_coord))
                i += 1
        return locations

    elif method == &#34;random_per_neighbourhood&#34;:
        locations = []
        width, height = self.params[&#34;width&#34;], self.params[&#34;height&#34;]
        n_schools = self.params[&#34;n_schools&#34;]
        n_neighbourhoods = self.params[&#34;n_neighbourhoods&#34;]
        per_side = int(np.sqrt(n_neighbourhoods))
        location_width = width / per_side
        location_height = height / per_side

        # Draw a random sample per neighbourhood as long as there are
        # schools to place
        i = 0
        while i &lt; max(n_neighbourhoods, n_schools):
            y_low = 0
            for col in range(per_side):
                x_low = 0
                y_high = int((1 + col) * location_height)

                for row in range(per_side):

                    x_high = int((1 + row) * location_width)

                    if x_high &gt;= width:
                        x_high = width - 1
                    elif y_high &gt;= height:
                        y_high = height - 1

                    x_coord = self.random.randint(low=x_low, high=x_high)
                    y_coord = self.random.randint(low=y_low, high=y_high)

                    # Check if the coordinates haven&#39;t already been sampled
                    while (x_coord, y_coord) in locations:
                        x_coord = self.random.randint(low=x_low, high=x_high)
                        y_coord = self.random.randint(low=y_low, high=y_high)

                    locations.append((x_coord, y_coord))
                    x_low = x_high + 1
                    i += 1
                y_low = y_high + 1

        # Shuffle all locations if n_schools &lt;= n_neighbourhoods, otherwise
        # shuffle only the remainder
        if n_schools &lt;= n_neighbourhoods:
            self.random.shuffle(locations)
        else:
            divider = int(n_schools / n_neighbourhoods)
            remainder = n_schools % n_neighbourhoods
            first_locations = locations[: n_neighbourhoods * divider]
            rest_locations = locations[n_neighbourhoods * divider :]
            self.random.shuffle(rest_locations)
            locations = first_locations + rest_locations[:remainder]

        return locations

    print(f&#34;Unknown method in choose_locations {method} __file__:__line__&#34;)
    sys.exit(-1)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.compute_closest_neighbourhoods"><code class="name flex">
<span>def <span class="ident">compute_closest_neighbourhoods</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Compute distance from all grid cells to all schools and all
neighbourhood objects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>of dicts containing all Euclidean distances</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_closest_neighbourhoods(self) -&gt; dict:
    &#34;&#34;&#34;
    Compute distance from all grid cells to all schools and all
    neighbourhood objects.
    Returns:
        dict: of dicts containing all Euclidean distances
    &#34;&#34;&#34;

    EPS = 1.2e-6
    closest_neighbourhoods = {}
    neighbourhoods = self.get_agents(&#34;neighbourhoods&#34;)

    for x in range(self.params[&#34;width&#34;]):
        for y in range(self.params[&#34;height&#34;]):

            # Loop over all neighbourhoods, calculate distance and save
            # closest
            point = Point(x, y)
            for neighbourhood in neighbourhoods:
                shape = neighbourhood.shape.buffer(EPS)
                if shape.contains(point):
                    closest_neighbourhoods[str((x, y))] = str(neighbourhood.pos)
                    break

    return closest_neighbourhoods</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.compute_school_distances"><code class="name flex">
<span>def <span class="ident">compute_school_distances</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Computes school distances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_school_distances(self) -&gt; None:
    &#34;&#34;&#34;
    Computes school distances.
    &#34;&#34;&#34;
    self.all_distances = np.zeros(
        (self.params[&#34;n_households&#34;], self.params[&#34;n_schools&#34;])
    )
    school_frame = gpd.GeoSeries(
        [Point(school.pos) for school in self.get_agents(&#34;schools&#34;)]
    )
    for household in self.get_agents(&#34;households&#34;):
        self.all_distances[household.idx, :] = school_frame.distance(
            Point(household.pos)
        )</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.convergence_check"><code class="name flex">
<span>def <span class="ident">convergence_check</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the processes have converged.
Returns: True if converged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convergence_check(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the processes have converged.
    Returns: True if converged.
    &#34;&#34;&#34;
    window_size = self.params[&#34;window_size&#34;]
    time = self.scheduler.get_time()
    school_time = self.scheduler.get_time(&#34;school&#34;)

    # Check what type of segregation to calculate (i.e., which of the
    # processes is running)
    if not self.res_ended:
        self.segregation.append(
            self.measurements.calculate_segregation(
                type=&#34;bounded_neighbourhood&#34;, index=&#34;Theil&#34;
            )
        )
    else:
        self.segregation.append(
            self.measurements.calculate_segregation(type=&#34;school&#34;, index=&#34;Theil&#34;)
        )

    # Wait until there is enough steps in the school process
    if self.res_ended and school_time &lt; window_size:
        return False

    # Check all metrics in the window size and check if they are below
    # the convergence threshold
    if time &gt;= window_size - 1:
        utilities = self.measurements.households[
            time - window_size + 1 : time + 1, :, 4
        ]
        means = utilities.mean(axis=1)
        stds = utilities.std(axis=1)

        metrics = np.vstack(
            (means, stds, self.segregation[time - window_size + 1 : time + 1])
        )

        metric_means = np.repeat(
            metrics.mean(axis=1)[:, np.newaxis], window_size, axis=1
        )
        mad = np.abs(metrics - metric_means)
        if np.all(mad &lt; self.params[&#34;conv_threshold&#34;]):
            # Start over if the residential process has converged
            self.res_ended = True
            return True

    return False</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.create_agents"><code class="name flex">
<span>def <span class="ident">create_agents</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the agents when no case study is provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_agents(self) -&gt; None:
    &#34;&#34;&#34;
    Creates the agents when no case study is provided.
    &#34;&#34;&#34;
    self.neighbourhoods()
    self.schools()
    self.location_to_agent()

    # Compute closest neighbourhoods
    self.closest_neighbourhoods = self.compute_closest_neighbourhoods()

    # Create households
    self.households()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.create_households"><code class="name flex">
<span>def <span class="ident">create_households</span></span>(<span>self, household_frame: pandas.core.frame.DataFrame, actual_households: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Given a GeoDataFrame, this creates household objects by randomly
drawing (without replacement) household metadata rows from the frame.
Arguments
actual_households (int)
The number of households to create.
Parameters used
params['random_residential']
Parameters set
params['n_households']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_households(
    self, household_frame: pd.DataFrame, actual_households: int
) -&gt; None:
    &#34;&#34;&#34;
    Given a GeoDataFrame, this creates household objects by randomly
    drawing (without replacement) household metadata rows from the frame.
    Arguments
        actual_households (int)
            The number of households to create.
    Parameters used
        params[&#39;random_residential&#39;]
    Parameters set
        params[&#39;n_households&#39;]
    &#34;&#34;&#34;
    if self.verbose:
        print(&#34;Creating households...&#34;)

    self.chosen_indices = self.random.choice(
        len(household_frame), size=actual_households, replace=False
    )
    households_sample = household_frame.iloc[self.chosen_indices]

    if self.params[&#34;random_residential&#34;]:
        # Randomly shuffle the group of the household
        shuffled = households_sample[&#34;group&#34;].values
        self.random.shuffle(shuffled)
        households_sample[&#34;group&#34;] = shuffled

    self.params[&#34;n_households&#34;] = actual_households
    n_agents = self.params[&#34;n_neighbourhoods&#34;] + self.params[&#34;n_schools&#34;]
    neighbourhoods = self.get_agents(&#34;neighbourhoods&#34;)

    self.all_distances = self.all_distances[self.chosen_indices, :]

    # pre-allocate storage for the Housholds
    Household.reset(max_households=actual_households)

    # DataFrame.iterrows() is very slow, dont use it!
    # the current code uses only iterates (no copies)
    # and should be memory-friendly and performant:
    # accumulated time for create_households:
    # for the testcase with  60K households from 9.10 to 2.60 seconds
    # for the testcase with 210K households from 30.0 to 9.27 seconds
    for index, row in enumerate(
        zip(
            households_sample[&#34;pos&#34;],
            households_sample[&#34;category&#34;],
            households_sample[&#34;neighbourhood_id&#34;],
        )
    ):
        household = Household(
            unique_id=index + n_agents,
            pos=row[0],
            model=self,
            params=self.params,
            category=row[1],
            nhood=neighbourhoods[row[2]],
        )
        self.agents[&#34;households&#34;].append(household)
        self.scheduler.add(household)
        self.grid.place_agent(household, household.pos)

    self.location_to_agent()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.create_neighbourhoods"><code class="name flex">
<span>def <span class="ident">create_neighbourhoods</span></span>(<span>self, neighbourhood_frame: pandas.core.frame.DataFrame) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Given a GeoDataFrame, this creates all the neighbourhood objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_neighbourhoods(self, neighbourhood_frame: pd.DataFrame) -&gt; None:
    &#34;&#34;&#34;
    Given a GeoDataFrame, this creates all the neighbourhood objects
    &#34;&#34;&#34;
    if self.verbose:
        print(&#34;Creating neighbourhoods...&#34;)

    self.params[&#34;n_neighbourhoods&#34;] = len(neighbourhood_frame)
    for index, row in neighbourhood_frame.iterrows():
        neighbourhood = Neighbourhood(
            unique_id=index,
            pos=(row.geometry.centroid.xy[0][0], row.geometry.centroid.xy[1][0]),
            shape=row.geometry,
            model=self,
            params=self.params,
        )
        self.agents[&#34;neighbourhoods&#34;].append(neighbourhood)
        self.scheduler.add(neighbourhood)
        self.grid.place_agent(neighbourhood, neighbourhood.pos)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.create_schools"><code class="name flex">
<span>def <span class="ident">create_schools</span></span>(<span>self, school_frame: pandas.core.frame.DataFrame) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Given a GeoDataFrame, this creates all the school objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_schools(self, school_frame: pd.DataFrame) -&gt; None:
    &#34;&#34;&#34;
    Given a GeoDataFrame, this creates all the school objects
    &#34;&#34;&#34;

    School.reset()

    if self.verbose:
        print(&#34;Creating schools...&#34;)

    self.params[&#34;n_schools&#34;] = len(school_frame)
    n_neighbourhoods = self.params[&#34;n_neighbourhoods&#34;]
    for index, row in school_frame.iterrows():
        school = School(
            unique_id=index + n_neighbourhoods,
            pos=(row.geometry.xy[0][0], row.geometry.xy[1][0]),
            model=self,
            params=self.params,
        )
        school.capacity = 1 + int(
            self.params[&#34;school_capacity&#34;]
            * self.params[&#34;n_students&#34;]
            / self.params[&#34;n_schools&#34;]
        )
        self.agents[&#34;schools&#34;].append(school)
        self.scheduler.add(school)
        self.grid.place_agent(school, school.pos)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.export_data"><code class="name flex">
<span>def <span class="ident">export_data</span></span>(<span>self, export=False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Export data for visualization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_data(self, export=False) -&gt; None:
    &#34;&#34;&#34;
    Export data for visualization.
    &#34;&#34;&#34;
    if export:
        self.measurements.export_data()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_agents"><code class="name flex">
<span>def <span class="ident">get_agents</span></span>(<span>self, agent_type: str) ‑> List[object]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of agents of given type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent_type</code></strong> :&ensp;<code>str</code></dt>
<dd>either 'School', 'Neighbourhood', 'Household' or</dd>
</dl>
<p>'Student'.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing all the objects of the specified type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_agents(self, agent_type: str) -&gt; List[object]:
    &#34;&#34;&#34;
    Returns list of agents of given type.
    Args:
        agent_type (str): either &#39;School&#39;, &#39;Neighbourhood&#39;, &#39;Household&#39; or
        &#39;Student&#39;.
    Returns:
        list: containing all the objects of the specified type.
    &#34;&#34;&#34;
    return self.agents[agent_type]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self, pos: tuple[float, float]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the attribute vector of a given position</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Numpy array</code></dt>
<dd>containing all the attributes (all zeros if empty)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self, pos: tuple[float, float]) -&gt; np.ndarray:

    &#34;&#34;&#34;
    Returns the attribute vector of a given position
    Args:
        pos (tuple): (x,y) coordinates.
    Returns:
        Numpy array: containing all the attributes (all zeros if empty)
    &#34;&#34;&#34;
    return self.household_attrs[pos[0], pos[1], :]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.households"><code class="name flex">
<span>def <span class="ident">households</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the household objects to the environment.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>Place household specific parameters in a attribute called params</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def households(self) -&gt; None:
    &#34;&#34;&#34;
    Adds the household objects to the environment.
    Todo:
        * Place household specific parameters in a attribute called params
    &#34;&#34;&#34;

    params = self.params
    self.chosen_indices = None  # Only matters for case studies
    self.household_attrs = np.zeros(
        shape=(params[&#34;width&#34;], params[&#34;height&#34;], len(params[&#34;group_types&#34;][0])),
        dtype=&#34;float32&#34;,
    )

    # Create group types, empty spots and shuffle them both
    n_groups = len(params[&#34;group_categories&#34;])
    groups = [
        self.random.choice(
            list(range(0, len(params[&#34;group_types&#34;][i]))),
            size=params[&#34;n_households&#34;],
            p=params[&#34;group_dist&#34;][i],
        )
        for i in range(n_groups)
    ]

    self.grid.empties = set(
        [(x, y) for x in range(params[&#34;width&#34;]) for y in range(params[&#34;height&#34;])]
    )
    empties = list(self.grid.empties)
    self.random.shuffle(empties)

    # pre-allocate storage for the Housholds
    Household.reset(max_households=params[&#34;n_households&#34;])

    for i, position in enumerate(empties[0 : params[&#34;n_households&#34;]]):
        household = Household(
            self.get_agents(&#34;amount&#34;), position, self, params, groups[0][i]
        )

        # Place households on the grid and add them to the scheduler
        self.agents[&#34;households&#34;].append(household)
        self.grid.place_agent(household, position)
        self.grid.empties.discard(position)
        self.scheduler.add(household)
        self.household_attrs[position[0], position[1], :] = household.attributes

    # Calculate AFTER all agents are placed
    self.calc_residential_compositions()
    self.set_agent_parameters(params)
    self.calc_res_utilities()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.increment_agent_count"><code class="name flex">
<span>def <span class="ident">increment_agent_count</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Increment agent count by one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_agent_count(self) -&gt; None:
    &#34;&#34;&#34;
    Increment agent count by one.
    &#34;&#34;&#34;
    self.agents[&#34;amount&#34;] += 1</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.load_agents"><code class="name flex">
<span>def <span class="ident">load_agents</span></span>(<span>self, case='Amsterdam') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load the agents from several files.</p>
<h2 id="note">Note</h2>
<p>This function is in progress and works only for the
Amsterdam case now.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_agents(self, case=&#34;Amsterdam&#34;) -&gt; None:
    &#34;&#34;&#34;
    Load the agents from several files.
    Note:
        This function is in progress and works only for the
        Amsterdam case now.
    &#34;&#34;&#34;

    dirname = os.path.dirname(__file__)
    if case.lower() == &#34;amsterdam&#34;:
        path = dirname + &#34;/maps/amsterdam&#34;
    elif case.lower() == &#34;south-london&#34;:
        path = dirname + &#34;/maps/south-london&#34;
    elif case.lower() == &#34;london&#34;:
        path = dirname + &#34;/maps/london&#34;

    # Load GeoDataFrames
    school_frame = gpd.read_file(path + &#34;/schools.geojson&#34;)
    household_frame = read_households(path + &#34;/households.geojson&#34;)
    neighbourhood_frame = gpd.read_file(path + &#34;/neighbourhoods.geojson&#34;)

    # Create grid
    self.params[&#34;torus&#34;] = 0
    self.params[&#34;max_res_steps&#34;] = 0
    xmin, ymin, xmax, ymax = neighbourhood_frame.total_bounds
    self.grid = ContinuousSpace(xmax, ymax, self.params[&#34;torus&#34;], xmin, ymin)
    self.grid.empties = [(0, 0)]

    # In the file more households could be available to sample from,
    # but only use the actual amount
    data = np.load(path + &#34;/distances_perc_of_actual.npz&#34;)
    perc_of_actual = data[&#34;perc_of_actual&#34;]
    self.all_distances = data[&#34;distances&#34;]

    self.scheduler = ThreeStagedActivation(self)

    # More agents are simulated to sample from them and incorporate some
    # randomness in the type and spatial distribution
    total_households = len(household_frame)
    actual_households = int(total_households / perc_of_actual)
    self.params[&#34;n_households&#34;] = actual_households
    self.params[&#34;n_students&#34;] = int(
        self.params[&#34;n_households&#34;] * self.params[&#34;student_density&#34;]
    )

    # Create neighbourhoods
    self.create_neighbourhoods(neighbourhood_frame)

    # Create schools
    self.create_schools(school_frame)

    # Create households
    self.create_households(household_frame, actual_households)

    if self.verbose:
        print(&#34;Setting agent parameters...&#34;)
    self.set_agent_parameters(self.params)

    self.local_compositions = self.neighbourhood_compositions
    self.calc_res_utilities()

    if self.verbose:
        print(&#34;Model loaded!&#34;)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.location_to_agent"><code class="name flex">
<span>def <span class="ident">location_to_agent</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dictionary with the location of the neighbourhoods as key and
the object itself as value. Schools are not included as they can have
the same position as a neighbourhood (centroid).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def location_to_agent(self) -&gt; None:
    &#34;&#34;&#34;
    Creates a dictionary with the location of the neighbourhoods as key and
    the object itself as value. Schools are not included as they can have
    the same position as a neighbourhood (centroid).
    &#34;&#34;&#34;
    agents = self.get_agents(&#34;neighbourhoods&#34;)
    self.location_to_agent = {str(agent.pos): agent for agent in agents}</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.neighbourhoods"><code class="name flex">
<span>def <span class="ident">neighbourhoods</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the neighbourhood objects to the environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbourhoods(self) -&gt; None:
    &#34;&#34;&#34;
    Adds the neighbourhood objects to the environment.
    &#34;&#34;&#34;

    n_neighs = self.params[&#34;n_neighbourhoods&#34;]

    # Add neighbourhoods if necessary
    if n_neighs:
        locations = self.choose_locations(
            n_neighs, self.params[&#34;neighbourhoods_placement&#34;]
        )
        for location in locations:
            size = self.params[&#34;width&#34;] / float(n_neighs**0.5 * 2)
            minx, miny = location[0] - size, location[1] - size
            maxx, maxy = location[0] + size, location[1] + size
            shape = box(minx, miny, maxx, maxy)

            # Create the Neighbourhood object and place it on the grid and
            # add it to the scheduler
            neighbourhood = Neighbourhood(
                self.get_agents(&#34;amount&#34;), location, shape, self, self.params
            )
            self.agents[&#34;neighbourhoods&#34;].append(neighbourhood)
            self.scheduler.add(neighbourhood)
            self.grid.place_agent(neighbourhood, location)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.schools"><code class="name flex">
<span>def <span class="ident">schools</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the school objects to the environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schools(self) -&gt; None:
    &#34;&#34;&#34;
    Adds the school objects to the environment.
    &#34;&#34;&#34;

    School.reset()

    # Add schools if necessary
    if self.params[&#34;n_schools&#34;]:
        locations = self.choose_locations(
            self.params[&#34;n_schools&#34;], self.params[&#34;schools_placement&#34;]
        )
        for location in locations:
            # Create the School object and place it on the grid and add it
            # to the scheduler
            school = School(self.get_agents(&#34;amount&#34;), location, self, self.params)
            self.agents[&#34;schools&#34;].append(school)
            self.scheduler.add(school)
            self.grid.place_agent(school, location)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.set_agent_parameters"><code class="name flex">
<span>def <span class="ident">set_agent_parameters</span></span>(<span>self, params: dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Puts the agent parameters in numpy arrays for faster computations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Model parameters which could differ from
the agent params!</dd>
</dl>
<h2 id="todo">Todo</h2>
<p>Parameters should be imported from a config file in the future.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_agent_parameters(self, params: dict) -&gt; None:
    &#34;&#34;&#34;
    Puts the agent parameters in numpy arrays for faster computations.
    Args:
        params (dict): Model parameters which could differ from
            the agent params!
    Todo:
        Parameters should be imported from a config file in the future.
    &#34;&#34;&#34;
    households = self.get_agents(&#34;households&#34;)
    n_households = len(households)

    dtype = &#34;float32&#34;
    self.alpha = np.zeros(n_households, dtype=dtype)
    self.temperature = self.params[
        &#34;temperature&#34;
    ]  # FIXME: different temp per agent?
    self.utility_at_max = np.zeros(n_households, dtype=dtype)
    self.optimal_fraction = np.zeros(n_households, dtype=dtype)
    self.neighbourhood_mixture = np.ones(n_households, dtype=int)

    optimal_fractions = trunc_normal_sample(
        params[&#34;optimal_fraction&#34;][0],
        scale=params[&#34;homophily_std&#34;],
        size=n_households,
        seed=self.random
    )
    alphas = trunc_normal_sample(
        [params[&#34;alpha&#34;], params[&#34;alpha&#34;]],
        scale=params[&#34;homophily_std&#34;],
        size=n_households,
        seed=self.random
    )
    utility_at_maxs = trunc_normal_sample(
        params[&#34;utility_at_max&#34;][0],
        scale=params[&#34;homophily_std&#34;],
        size=n_households,
        seed=self.random
    )

    for household in households:
        x, y = household.pos

        # Fill arrays with agent parameter values for faster computations
        self.optimal_fraction[household.idx] = optimal_fractions[
            household.category
        ][household.idx]
        self.alpha[household.idx] = alphas[household.category][household.idx]
        self.utility_at_max[household.idx] = utility_at_maxs[household.category][
            household.idx
        ]

        # Currently only convolution (assumes every household has the same
        # radius) for composition calculations within the lattice case.
        if params[&#34;case&#34;].lower() == &#34;lattice&#34;:
            self.local_compositions.append(
                self.normalized_compositions[x, y, household.category]
            )
        else:
            household.params[&#34;neighbourhood_mixture&#34;] = 1

        if household.neighbourhood.total &gt; 0:
            norm = 1.0 / household.neighbourhood.total
        else:
            norm = 1.0
        self.neighbourhood_compositions.append(
            household.neighbourhood.composition[household.category] * norm
        )

    # These are filled with the actual distance and composition utilities
    # of the household and the school (singular!) they attend

    # SHOULD BE CALLED DIFFERENTLY CAUSE NOW IT OVERWRITES AN ATTRIBUTE!!!
    self.school_compositions = np.zeros(n_households, dtype=dtype)

    # Distance utilities based on sigmoid function
    if self.params[&#34;case&#34;].lower() != &#34;lattice&#34;:
        p = self.params[&#34;p&#34;]
        q = self.params[&#34;q&#34;]
        self.distance_utilities = 1.0 / (1 + (self.all_distances / p) ** q)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.set_attributes"><code class="name flex">
<span>def <span class="ident">set_attributes</span></span>(<span>self, params: dict, export=False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets or calculates all attributes used in the Compass class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>Argparser</code></dt>
<dd>containing all parameter values.</dd>
<dt><strong><code>export</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the data needs to be exported or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attributes(self, params: dict, export=False) -&gt; None:
    &#34;&#34;&#34;
    Sets or calculates all attributes used in the Compass class.
    Args:
        params (Argparser): containing all parameter values.
        export (bool): True if the data needs to be exported or not.
    &#34;&#34;&#34;

    # Calculate number of households and students
    params[&#34;n_households&#34;] = int(
        params[&#34;household_density&#34;]
        * (
            params[&#34;width&#34;] * params[&#34;height&#34;]
            - params[&#34;n_neighbourhoods&#34;]
            - params[&#34;n_schools&#34;]
        )
    )
    params[&#34;n_students&#34;] = int(params[&#34;n_households&#34;] * params[&#34;student_density&#34;])
    self.params = dict(params)

    # Set tracking attributes
    self.export = export
    # Track segregation over time
    self.segregation: List[float] = []
    self.res_ended = False
    self.school_ended = False
    self.verbose = self.params[&#34;verbose&#34;]
    self.agents: Dict[str, List[object]] = {
        &#34;amount&#34;: 0,
        &#34;households&#34;: [],
        &#34;schools&#34;: [],
        &#34;neighbourhoods&#34;: [],
    }

    # Initialise other objects
    self.measurements = Measurements(self)
    self.scheduler = ThreeStagedActivation(self)
    self.grid = ContinuousSpace(
        self.params[&#34;width&#34;], self.params[&#34;height&#34;], torus=self.params[&#34;torus&#34;]
    )</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, res_steps: int = None, school_steps: int = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Performs #res_steps of residential steps and #school_steps of school
steps.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of residential steps.</dd>
<dt><strong><code>school_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of school steps.</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an initial school step needs to be
done, False (default) means a school step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, res_steps: int = None, school_steps: int = None) -&gt; None:
    &#34;&#34;&#34;
    Performs #res_steps of residential steps and #school_steps of school
    steps.
    Args:
        res_steps (int): Number of residential steps.
        school_steps (int): Number of school steps.
        initial_schools (bool): True if an initial school step needs to be
            done, False (default) means a school step.
    &#34;&#34;&#34;

    if not res_steps:
        res_steps = self.params[&#34;max_res_steps&#34;]

    if not school_steps:
        school_steps = self.params[&#34;max_school_steps&#34;]

    while self.scheduler.get_time(&#34;residential&#34;) &lt; res_steps and not self.res_ended:

        if self.verbose:
            f = (
                &#34;Residential process: step &#34;
                + str(self.scheduler.get_time(&#34;residential&#34;) + 1)
                + &#34; from &#34;
                + str(res_steps)
            )
            sys.stdout.write(&#34;\r&#34; + f)
            sys.stdout.flush()

        self.res_ended = self.convergence_check()
        if not self.res_ended:
            self.step(residential=True)
        else:
            break

    if self.verbose:
        print()

    while (
        self.scheduler.get_time(&#34;school&#34;) &lt; school_steps and not self.school_ended
    ):

        if self.verbose:
            f = (
                &#34;School process: step &#34;
                + str(self.scheduler.get_time(&#34;school&#34;) + 1)
                + &#34; from &#34;
                + str(school_steps)
            )
            sys.stdout.write(&#34;\r&#34; + f)
            sys.stdout.flush()

        self.school_ended = self.convergence_check()

        if self.scheduler.school_steps == 0:
            self.step(residential=False, initial_schools=True)
        else:
            if not self.school_ended:
                self.step(residential=False, initial_schools=False)
            else:
                break

    if self.verbose:
        print()
        print(&#34;Processes ended&#34;)
    self.export_data(self.export)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, residential: bool = False, initial_schools: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Perform model steps.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>residential</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if a residential step needs to be done,
False (default) means a school step.</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an initial school step needs to be
done, False (default) means a school step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, residential: bool = False, initial_schools: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Perform model steps.
    Args:
        residential (bool): True if a residential step needs to be done,
            False (default) means a school step.
        initial_schools (bool): True if an initial school step needs to be
            done, False (default) means a school step.
    &#34;&#34;&#34;

    # Perform school or residential step.
    self.scheduler.step(residential=residential, initial_schools=initial_schools)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.switch_attrs"><code class="name flex">
<span>def <span class="ident">switch_attrs</span></span>(<span>self, pos1: tuple[float, float], pos2: tuple[float, float]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Switches two attribute vectors in the attribute grid by making a copy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos1</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
<dt><strong><code>pos2</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch_attrs(
    self, pos1: tuple[float, float], pos2: tuple[float, float]
) -&gt; None:
    &#34;&#34;&#34;
    Switches two attribute vectors in the attribute grid by making a copy.
    Args:
        pos1 (tuple): (x,y) coordinates.
        pos2 (tuple): (x,y) coordinates.
    &#34;&#34;&#34;
    temp = np.copy(self.household_attrs[pos1])
    self.household_attrs[pos1] = self.household_attrs[pos2]
    self.household_attrs[pos2] = temp</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="compass" href="index.html">compass</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="compass.model.read_households" href="#compass.model.read_households">read_households</a></code></li>
<li><code><a title="compass.model.record_time" href="#compass.model.record_time">record_time</a></code></li>
<li><code><a title="compass.model.trunc_normal_sample" href="#compass.model.trunc_normal_sample">trunc_normal_sample</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="compass.model.CompassModel" href="#compass.model.CompassModel">CompassModel</a></code></h4>
<ul class="">
<li><code><a title="compass.model.CompassModel.calc_res_utilities" href="#compass.model.CompassModel.calc_res_utilities">calc_res_utilities</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_residential_compositions" href="#compass.model.CompassModel.calc_residential_compositions">calc_residential_compositions</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_school_compositions" href="#compass.model.CompassModel.calc_school_compositions">calc_school_compositions</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_school_rankings" href="#compass.model.CompassModel.calc_school_rankings">calc_school_rankings</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_school_utilities" href="#compass.model.CompassModel.calc_school_utilities">calc_school_utilities</a></code></li>
<li><code><a title="compass.model.CompassModel.choose_locations" href="#compass.model.CompassModel.choose_locations">choose_locations</a></code></li>
<li><code><a title="compass.model.CompassModel.compute_closest_neighbourhoods" href="#compass.model.CompassModel.compute_closest_neighbourhoods">compute_closest_neighbourhoods</a></code></li>
<li><code><a title="compass.model.CompassModel.compute_school_distances" href="#compass.model.CompassModel.compute_school_distances">compute_school_distances</a></code></li>
<li><code><a title="compass.model.CompassModel.convergence_check" href="#compass.model.CompassModel.convergence_check">convergence_check</a></code></li>
<li><code><a title="compass.model.CompassModel.create_agents" href="#compass.model.CompassModel.create_agents">create_agents</a></code></li>
<li><code><a title="compass.model.CompassModel.create_households" href="#compass.model.CompassModel.create_households">create_households</a></code></li>
<li><code><a title="compass.model.CompassModel.create_neighbourhoods" href="#compass.model.CompassModel.create_neighbourhoods">create_neighbourhoods</a></code></li>
<li><code><a title="compass.model.CompassModel.create_schools" href="#compass.model.CompassModel.create_schools">create_schools</a></code></li>
<li><code><a title="compass.model.CompassModel.export_data" href="#compass.model.CompassModel.export_data">export_data</a></code></li>
<li><code><a title="compass.model.CompassModel.get_agents" href="#compass.model.CompassModel.get_agents">get_agents</a></code></li>
<li><code><a title="compass.model.CompassModel.get_attributes" href="#compass.model.CompassModel.get_attributes">get_attributes</a></code></li>
<li><code><a title="compass.model.CompassModel.households" href="#compass.model.CompassModel.households">households</a></code></li>
<li><code><a title="compass.model.CompassModel.increment_agent_count" href="#compass.model.CompassModel.increment_agent_count">increment_agent_count</a></code></li>
<li><code><a title="compass.model.CompassModel.load_agents" href="#compass.model.CompassModel.load_agents">load_agents</a></code></li>
<li><code><a title="compass.model.CompassModel.location_to_agent" href="#compass.model.CompassModel.location_to_agent">location_to_agent</a></code></li>
<li><code><a title="compass.model.CompassModel.neighbourhoods" href="#compass.model.CompassModel.neighbourhoods">neighbourhoods</a></code></li>
<li><code><a title="compass.model.CompassModel.schools" href="#compass.model.CompassModel.schools">schools</a></code></li>
<li><code><a title="compass.model.CompassModel.set_agent_parameters" href="#compass.model.CompassModel.set_agent_parameters">set_agent_parameters</a></code></li>
<li><code><a title="compass.model.CompassModel.set_attributes" href="#compass.model.CompassModel.set_attributes">set_attributes</a></code></li>
<li><code><a title="compass.model.CompassModel.simulate" href="#compass.model.CompassModel.simulate">simulate</a></code></li>
<li><code><a title="compass.model.CompassModel.step" href="#compass.model.CompassModel.step">step</a></code></li>
<li><code><a title="compass.model.CompassModel.switch_attrs" href="#compass.model.CompassModel.switch_attrs">switch_attrs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>