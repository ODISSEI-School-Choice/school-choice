<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>compass.model API documentation</title>
<meta name="description" content="The Model class which initialises the system and all of its components." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>compass.model</code></h1>
</header>
<section id="section-intro">
<p>The Model class which initialises the system and all of its components.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Model class which initialises the system and all of its components.
&#34;&#34;&#34;

import os
import sys
import random
import pickle
import logging
import numpy as np
from mesa import Model
from utils import Measurements
from scipy.stats import truncnorm
from scipy.ndimage import convolve
from agents_household import Household
from mesa.space import ContinuousSpace
from shapely.geometry import Point, box
from scheduler import ThreeStagedActivation
from agents_spatial import School, Neighbourhood


class CompassModel(Model):
    &#34;&#34;&#34;
    Model class for school segregation dynamics.

    Args:
        params (Argparser): containing all parameter values.

    Attributes:
        params (dict):
        grid (MultiGrid): MultiGrid object from Mesa.
        scheduler (ThreeStagedActivation): ThreeStagedActivation object.
        agents (list): all agents in the model.
        measurements (Measurements): Measurements object.
        global_composition (dict): containing the total system compositions.
        distance_matrix (list): all the Euclidean distances from one grid cell
            to another.
        nearness_matrix (list): same as above but with normalized distances.
        global_composition_normalized (dict): normalized system compositions.
    &#34;&#34;&#34;
    def __init__(self, params, export=False):

        super().__init__()

        # Initialise the model attributes
        self.set_attributes(params=params, export=export)

        # Initialise agents
        if self.logging_enabled:
            logging.debug(&#39;Initialising agents&#39;)
        if self.params[&#39;case&#39;].lower() != &#39;lattice&#39;:
            self.load_agents(self.params[&#39;case&#39;].lower())
        else:
            self.create_agents()

        # Get values of the initial configuration
        self.measurements.end_step(residential=True)

        # Calculate global compositions for the segregation calculations
        self.global_composition = self.measurements.neighbourhoods[
            0, :, :2].sum(axis=0)
        self.global_composition_normalized = self.global_composition / \
            self.global_composition.sum()

        text = f&#34;&#34;&#34; Model initialised:
            NR AGENTS:  Households: {self.params[&#39;n_households&#39;]}
            Neighbourhoods: {self.params[&#39;n_neighbourhoods&#39;]}
            Schools: {self.params[&#39;n_schools&#39;]}
            In scheduler: {self.scheduler.get_agent_count()}&#34;&#34;&#34;
        print(text)
        if self.logging_enabled:
            logging.debug(text)


    def set_attributes(self, params, export=False):
        &#34;&#34;&#34;
        Sets or calculates all attributes used in the Compass class.

        Args:
            params (Argparser): containing all parameter values.
            export (bool): True if the data needs to be exported or not.
        &#34;&#34;&#34;

        # Calculate number of households and students
        
        params[&#34;n_households&#34;] = int(params[&#34;household_density&#34;]
            * (params[&#34;width&#34;] * params[&#34;height&#34;]
            - params[&#34;n_neighbourhoods&#34;] - params[&#34;n_schools&#34;]))
        params[&#39;n_students&#39;] = int(params[&#34;n_households&#34;] * 
                params[&#34;student_density&#34;])
        self.params = dict(params)

        # Set up logger
        self.logging_enabled = params[&#39;logging_enabled&#39;]
        if self.logging_enabled:     
            self.logger(log_path=&#39;logs/&#39;, filename=&#39;model.log&#39;)
            logging.debug(&#39;Starting new model&#39;)

        # Precalculate shocks
        self.uniform_shocks = np.random.random(1000)
        self.shocks = np.random.normal(0, 0.05, 1000)

        # Set tracking attributes
        self.export = export
        self.segregation = []       # Track segregation over time
        self.res_ended = False
        self.school_ended = False
        self.composition = self.composition_normalized = None
        self.agents = {&#34;amount&#34;: 0, &#34;households&#34;: [], &#34;schools&#34;: [],
            &#34;neighbourhoods&#34;: []}
        
        # Initialise other objects
        self.measurements = Measurements(self)
        self.scheduler = ThreeStagedActivation(self)
        self.grid = ContinuousSpace(self.params[&#34;width&#34;], self.params[&#34;height&#34;],
                                torus=self.params[&#34;torus&#34;])


    def create_agents(self):
        &#34;&#34;&#34;
        Creates the agents when no case study is provided.
        &#34;&#34;&#34;
        self.neighbourhoods()
        self.schools()
        self.location_to_agent()

        # Compute distance matrix 
        self.distances, \
        self.closest_schools, \
        self.furthest_schools, \
        self.closest_neighbourhoods = self.compute_distances()

        # Compute normalised distances (nearness matrix)
        self.norm_distances = self.compute_norm_distances(
            self.distances, 
            self.closest_schools, 
            self.furthest_schools,
            self.closest_neighbourhoods)

        if self.logging_enabled:
            logging.debug(&#39;Placing households and creating attribute matrix&#39;)
        self.households()

    
    def set_agent_parameters(self, params, households):
        &#34;&#34;&#34;
        Puts the agent parameters in numpy arrays for faster computations. 

        Args:
            params (dict): Model parameters which could differ from
                the agent params!
            households (list): list of Household objects. Students should
                inherit their parameters from the Household object.

        Todo:
            Parameters should be imported from a config file in the future.
        &#34;&#34;&#34;

        # to remember the index in the array of the specific household
        array_index = 0

        n_agents = len(households)
        self.local_compositions = []
        self.neighbourhood_compositions = []

        self.utility_at_max = np.repeat(params[&#39;utility_at_max&#39;][0][0], 
            n_agents)
        self.neighbourhood_mixture = np.repeat(params[&#39;neighbourhood_mixture&#39;], 
            n_agents)
        self.alpha = np.repeat(params[&#39;alpha&#39;], n_agents)
        self.optimal_fraction = np.repeat(params[&#39;optimal_fraction&#39;][0][0], 
            n_agents)

        if self.params[&#39;case&#39;].lower() == &#39;lattice&#39;:
            local_compositions = self.normalized_compositions
        
        for household in households:
            household.array_index = array_index
            x,y = household.pos

            # Currently only convolution (assumes every household has the same
            # radius) for composition calculations within the lattice case.
            if self.params[&#39;case&#39;].lower() == &#39;lattice&#39;:
                self.local_compositions.append(
                    local_compositions[x,y,household.category])

            self.neighbourhood_compositions.append(
                household.neighbourhood.composition_normalized[household.category])
            array_index += 1

        self.agent_distances = np.zeros(n_agents)
        self.school_compositions = np.zeros(n_agents)
        self.vectorise_functions() # for element-wise operations


    def vectorise_functions(self):
        &#34;&#34;&#34;
        Vectorises functions using numpy.vectorize for use in 
        array computations.
        &#34;&#34;&#34;
        self.calc_comp_utility_v = np.vectorize(self.calc_comp_utility)


    def calc_comp_utility(self, x, M, f):
        &#34;&#34;&#34;
        Calculates the utility given a normalised composition (0&lt;=x&lt;=1), an 
        optimal fraction (0&lt;=f&lt;=1) and utility at homogeneity (0&lt;=M&lt;=1).
        &#34;&#34;&#34;
        if x &lt;= f:
            utility =  x / f
        else:
            utility =  M + (1-x)*(1-M) / (1-f)
        return utility


    def logger(self, log_path, filename):
        &#34;&#34;&#34;
        Sets up the logger.
        &#34;&#34;&#34;

        self.log_path = log_path
        # Check if folder exist, otherwise create it.
        if not os.path.exists(log_path):
            os.makedirs(log_path)

        fileh = logging.FileHandler(log_path + filename, &#39;a&#39;)
        formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - &#39; + \
            &#39;%(levelname)s - %(message)s&#39;)
        fileh.setFormatter(formatter)

        log = logging.getLogger()  # root logger
        for hdlr in log.handlers[:]:  # remove all old handlers
            if isinstance(hdlr, logging.FileHandler):
                log.removeHandler(hdlr)
        log.setLevel(self.params[&#39;loglevel&#39;])
        log.addHandler(fileh)      # set the new handler


    def neighbourhoods(self):
        &#34;&#34;&#34;
        Adds the neighbourhood objects to the environment.
        &#34;&#34;&#34;

        n_neighs = self.params[&#34;n_neighbourhoods&#34;]

        # Add neighbourhoods if necessary
        if n_neighs:
            locations = self.choose_locations(n_neighs,
                                self.params[&#34;neighbourhoods_placement&#34;])
            for i in range(n_neighs):
                
                x, y = locations[i]
                location = (x, y)
                size = self.params[&#39;width&#39;] / float(n_neighs**0.5 * 2)
                minx, miny = x - size, y - size
                maxx, maxy = x + size, y + size
                shape = box(minx, miny, maxx, maxy)

                # Create the Neighbourhood object and place it on the grid and
                # add it to the scheduler
                neighbourhood = Neighbourhood(self.get_agents(&#34;amount&#34;),
                                        location, shape, self, 
                                        self.params)
                self.get_agents(&#34;neighbourhoods&#34;).append(neighbourhood)
                self.scheduler.add(neighbourhood)
                self.grid.place_agent(neighbourhood, locations[i])


    def schools(self):
        &#34;&#34;&#34;
        Adds the school objects to the environment.
        &#34;&#34;&#34;

        # Add schools if necessary
        if self.params[&#34;n_schools&#34;]:
            locations = self.choose_locations(self.params[&#34;n_schools&#34;],
                                self.params[&#34;schools_placement&#34;])
            for i in range(self.params[&#34;n_schools&#34;]):
                x, y = locations[i]
                location = (x, y)

                # Create the School object and place it on the grid and add it
                # to the scheduler
                school = School(self.get_agents(&#34;amount&#34;),
                    location, self, self.params)
                self.get_agents(&#34;schools&#34;).append(school)
                self.scheduler.add(school)
                self.grid.place_agent(school, location)


    def households(self):
        &#34;&#34;&#34;
        Adds the household objects to the environment.

        Todo:
            * Place household specific parameters in a attribute called params
        &#34;&#34;&#34;

        params = self.params
        self.household_attrs = np.zeros(shape=(params[&#34;width&#34;],
            params[&#39;height&#39;], len(params[&#39;group_types&#39;][0])))

        # Create group types, empty spots and shuffle them both
        n_groups = len(params[&#34;group_categories&#34;])
        groups = [np.random.choice(list(range(0,
            len(params[&#34;group_types&#34;][i]))), size=params[&#34;n_households&#34;],
            p=params[&#34;group_dist&#34;][i]) for i in range(n_groups)]

        self.grid.empties = set(
            [(x,y) for x in range(params[&#39;width&#39;]) 
            for y in range(params[&#39;height&#39;])])
        empties = list(self.grid.empties)
        np.random.shuffle(empties)

        # Sample tolerances
        tolerances0, tolerances1 = self.sample_tolerances(
            params[&#34;optimal_fraction&#34;][0],
            scale=params[&#39;homophily_std&#39;],
            size=params[&#34;n_households&#34;])


        for i, position in enumerate(empties[0:params[&#34;n_households&#34;]]):
            household = Household(self.get_agents(&#34;amount&#34;), position, self,
                params, groups[0][i])

            # Find according group and group specific information
            for j in range(len(groups)):
                category = groups[j][i]
                if category == 0:
                    tolerance = tolerances0[i]
                elif category == 1:
                    tolerance = tolerances1[i]

                # Save household specific parameters
                household.groups.append({
                    &#34;group_name&#34;:       params[&#34;group_categories&#34;][j],
                    &#34;type_index&#34;:       groups[j][i],
                    &#34;group_size&#34;:       len(params[&#34;group_types&#34;][j]),
                    &#34;group_type&#34;:       params[&#34;group_types&#34;][j][groups[j][i]],
                    &#34;threshold&#34;:        params[&#34;category_thresholds&#34;][j][groups[j][i]],
                    &#34;utility_at_max&#34;:   params[&#34;utility_at_max&#34;][j][groups[j][i]],
                    &#34;optimal_fraction&#34;: tolerance
                    })

            # Place households on the grid and add them to the scheduler
            self.get_agents(&#34;households&#34;).append(household)
            self.grid.place_agent(household, position)
            self.grid.empties.discard(position)
            self.scheduler.add(household)
            self.household_attrs[position[0], position[1], :] = household.attributes

        
        # Calculate AFTER all agents are placed
        all_households = self.get_agents(&#39;households&#39;)
        self.calc_residential_compositions()
        self.set_agent_parameters(params, all_households)
        self.calc_res_utilities()
        [household.update_utilities() for household in all_households]


    def load_agents(self, case=&#39;Amsterdam&#39;):
        &#34;&#34;&#34;
        Load the agents from a pickle.

        Note:
            This function is in progress and works only for the Amsterdam and
            IJburg case currently. In the future agents should be able to be 
            imported in a general manner.
        &#34;&#34;&#34;

        if case.lower()==&#39;ijburg&#39;:
            file = open(r&#39;compass/maps/ijburg/agents_ijburg.pickle&#39;, &#39;rb&#39;)
        elif case.lower()==&#39;amsterdam&#39;:
            file = open(r&#39;compass/maps/amsterdam/agents_10p.pickle&#39;, &#39;rb&#39;)

        data = pickle.load(file)

        # Create grid
        xmin, ymin, xmax, ymax = data[&#39;neighbourhoods_gpd&#39;].total_bounds
        self.grid = ContinuousSpace(xmax, ymax, self.params[&#34;torus&#34;],
            xmin, ymin)
        self.params[&#39;max_res_steps&#39;] = 0
        self.grid.empties = [(0,0)]
        self.closest_neighbourhoods = {}

        agents = data[&#39;agents&#39;]
        self.params[&#39;n_neighbourhoods&#39;] = len(agents[agents.object==&#39;Neighbourhood&#39;])
        self.params[&#39;n_schools&#39;] = len(agents[agents.object==&#39;School&#39;])
        self.params[&#39;n_households&#39;] = len(agents[agents.object==&#39;Household&#39;])
        self.params[&#39;n_students&#39;] = int(self.params[&#34;n_households&#34;] * 
                self.params[&#34;student_density&#34;])

        for index, agent in agents.iterrows():
    
            if agent.object==&#39;Neighbourhood&#39;:
                neighbourhood = Neighbourhood(index, (agent.x, agent.y),
                                    agent.geometry, self, self.params)
                self.get_agents(&#34;neighbourhoods&#34;).append(neighbourhood)
                self.scheduler.add(neighbourhood)
                pos = neighbourhood.shape.centroid
                self.grid.place_agent(neighbourhood, (pos.x, pos.y))

            elif agent.object==&#39;School&#39;:
                school = School(index, (agent.x, agent.y), self, self.params)
                self.get_agents(&#34;schools&#34;).append(school)
                self.scheduler.add(school)
                self.grid.place_agent(school, (agent.x, agent.y))

            elif agent.object==&#39;Household&#39;:
                pos = (agent.x, agent.y)
                for nhood in self.get_agents(&#39;neighbourhoods&#39;):
                    if nhood.shape.contains(Point(pos)):
                        self.closest_neighbourhoods[str(pos)] = nhood
                        
                        household = Household(index, (agent.x, agent.y), 
                                                self, self.params,
                                                category=int(agent.group),
                                                nhood=nhood)
                        self.get_agents(&#34;households&#34;).append(household)
                        self.scheduler.add(household)
                        self.grid.place_agent(household, (agent.x, agent.y))
                        break            
        
        self.location_to_agent()
        households = self.get_agents(&#39;households&#39;)

        self.distances = data[&#39;distances&#39;]
        self.closest_schools = data[&#39;closest_schools&#39;]
        self.furthest_schools = data[&#39;furthest_schools&#39;]
        self.norm_distances = self.compute_norm_distances(
            self.distances, 
            self.closest_schools, 
            self.furthest_schools, {})

        self.set_agent_parameters(self.params, households)

        self.local_compositions = self.neighbourhood_compositions
        self.calc_res_utilities()

        # Initial compositions need to be calculated
        for household in households:
            # Only bounded calculation
            household.params[&#39;neighbourhood_mixture&#39;] = 1
            household.update_utilities()


    def location_to_agent(self):
        &#34;&#34;&#34;
        Creates a dictionary with the location of the neighbourhoods as key and
        the object itself as value. Schools are not included as they can have 
        the same position as a neighbourhood (centroid).
        &#34;&#34;&#34;

        agents = self.get_agents(&#39;neighbourhoods&#39;)
        self.location_to_agent = {str(agent.pos):agent for agent in agents}


    def sample_tolerances(self, means, scale, size):
        &#34;&#34;&#34;
        Sample tolerance levels from a truncated normal distribution.
        &#34;&#34;&#34;
        tolerances = [0]*len(means)
        for index, mu in enumerate(means):

            # All tolerances are equal if the scale is zero.
            if scale==0:
                tolerances[index] = np.repeat(mu, size)
            else:
                tolerances[index] = truncnorm.rvs((0-mu)/scale, (1-mu)/scale,
                                                loc=mu, scale=scale, size=size)
        return tolerances


    def calc_residential_compositions(self):
        &#34;&#34;&#34;
        Updates all local residential compositions assuming all households have
        the SAME RADIUS.
        &#34;&#34;&#34;

        # Determine the kernel of the convolution
        radius = self.params[&#39;radius&#39;]
        dim = radius*2 + 1
        self.kernel = np.ones((dim, dim))
        self.kernel[radius, radius] = 0

        # Should it wrap around the edges or not?
        if self.params[&#39;torus&#39;]:
            mode=&#39;wrap&#39;
        else:
            mode=&#39;constant&#39;

        summed = 0
        num_attrs = self.household_attrs.shape[2]
        compositions = np.zeros(shape=self.household_attrs.shape)

        # Convolution for every household attribute.
        for attr in range(num_attrs):
            compositions[:,:,attr] = convolve(
                self.household_attrs[:,:,attr],
                self.kernel, mode=mode)
            summed += compositions[:,:,attr]
        self.compositions = compositions
        self.normalized_compositions = np.nan_to_num(
            compositions / np.repeat(summed[:, :, np.newaxis],
                num_attrs, axis=2))


    def calc_school_compositions(self):
        &#34;&#34;&#34;
        Calculate the new school compositions for every household and only for 
        the first student!

        Note:
            Currently only for the first student!!!
        &#34;&#34;&#34;

        for household in self.get_agents(&#39;households&#39;):
            category = household.category
            array_index = household.array_index
            self.agent_distances[array_index] = household.distance
            self.school_compositions[array_index] = \
                household.students[0].school.composition_normalized[category]
            

    def calc_res_utilities(self):
        &#34;&#34;&#34;
        Calculates residential utility at a household its current position and 
        given its parameter values. 
        &#34;&#34;&#34;
        
        b = self.neighbourhood_mixture
        f = self.optimal_fraction
        M = self.utility_at_max
        x = (1-b)*self.local_compositions + \
            b*self.neighbourhood_compositions
        self.res_utilities = self.calc_comp_utility_v(x, M, f)


    def calc_school_utilities(self):
        &#34;&#34;&#34;
        Calculates school utilities at a student its current school, given 
        distance and its other parameter values. 
        &#34;&#34;&#34;

        alpha = self.alpha
        f = self.optimal_fraction
        M = self.utility_at_max
        x = self.school_compositions
        distances = self.agent_distances
        self.school_composition_utilities = self.calc_comp_utility_v(x, M, f)
        self.school_utilities = (self.school_composition_utilities ** alpha) * \
            (distances ** (1 - alpha))


    def calc_school_rankings(self, households, schools):
        &#34;&#34;&#34;
        Ranks the schools according to utility.

        Args:
            households (list): list of households the rankings need to be
                calculated for.
            schools (list): list of schools that need to be ranked.

        Todo:
            Schools can differ per household if we only want to look at the 
            n-closest schools for example?
        &#34;&#34;&#34;
        
        compositions = np.array(
            [school.composition_normalized for school in schools])

        for household in households:
            
            # Get the normalised distance to every school
            category = household.category
            nearness = self.get_norm_distances(household.pos)
            distances = np.array([nearness[str(school.pos)] for school in schools])

            # Composition utility calculations
            f = household.params[&#39;optimal_fraction&#39;][0][category]
            M = household.params[&#39;utility_at_max&#39;][0][category]
            x = compositions[:, category]
            composition_utilities = self.calc_comp_utility_v(x, M, f)

            # Combined
            alpha = household.params[&#39;alpha&#39;]
            utilities = (composition_utilities ** alpha) * \
                (distances ** (1 - alpha))
            utility_dict = dict(zip(schools, utilities))
            ranking = sorted(utility_dict, key=utility_dict.get, reverse=True)
            
            # Set the same ranking for every student
            [student.set_school_preference(ranking) for student in household.students]


    def get_attributes(self, pos):
        &#34;&#34;&#34;
        Returns the attribute vector of a given position

        Args:
            pos (tuple): (x,y) coordinates.

        Returns:
            Numpy array: containing all the attributes (all zeros if empty)
        &#34;&#34;&#34;
        return self.household_attrs[pos[0], pos[1], :]


    def switch_attrs(self, pos1, pos2):
        &#34;&#34;&#34;
        Switches two attribute vectors in the attribute grid by making a copy.

        Args:
            pos1 (tuple): (x,y) coordinates.
            pos2 (tuple): (x,y) coordinates.
        &#34;&#34;&#34;
        temp = np.copy(self.household_attrs[pos1])
        self.household_attrs[pos1] = self.household_attrs[pos2]
        self.household_attrs[pos2] = temp


    def step(self, residential=False, initial_schools=False):
        &#34;&#34;&#34;
        Perform model steps.

        Args:
            residential (bool): True if a residential step needs to be done,
                False (default) means a school step.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;

        # Perform school or residential step.
        message = f&#39;Perform model step, residential = {residential}, initial schools = {initial_schools}&#39;
        if self.logging_enabled:
            logging.debug(message)
        self.scheduler.step(residential=residential,
                            initial_schools=initial_schools)


    def simulate(self, res_steps=None, school_steps=None):
        &#34;&#34;&#34;
        Performs #res_steps of residential steps and #school_steps of school
        steps.

        Args:
            res_steps (int): Number of residential steps.
            school_steps (int): Number of school steps.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;
        if not res_steps:
            res_steps = self.params[&#39;max_res_steps&#39;]

        if not school_steps:
            school_steps = self.params[&#39;max_school_steps&#39;]

        logging_level = logging.root.level
        while (self.scheduler.get_time(&#39;residential&#39;) &lt; res_steps \
            and not self.res_ended):

            if logging_level &gt;= 10:
                f = &#34;Residential process: step &#34; + str(
                self.scheduler.get_time(&#39;residential&#39;)+1) + &#34; from &#34; + \
                    str(res_steps)
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()
                if self.logging_enabled:
                    logging.debug(f)

            self.res_ended = self.convergence_check()
            if not self.res_ended:
                self.step(residential=True)
            else:
                if logging_level &gt;= 10:
                    if self.logging_enabled:
                        logging.debug(&#34;\nResidential process converged&#34;)
                break
        
        if self.logging_enabled:
            logging.debug(&#34;Residential process ended.&#34;)
        print()
        while (self.scheduler.get_time(&#39;school&#39;) &lt; school_steps \
            and not self.school_ended):

            if logging_level &gt;= 10:
                f = &#34;School process: step &#34; + str(
                self.scheduler.get_time(&#39;school&#39;)+1) + &#34; from &#34; + \
                    str(school_steps)
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()
                if self.logging_enabled:
                    logging.debug(f)

            self.school_ended = self.convergence_check()
            if self.scheduler.school_steps == 0:
                self.step(residential=False, initial_schools=True)
            else:
                if not self.school_ended:
                    self.step(residential=False, initial_schools=False)
                else:
                    if logging_level &gt;= 10:
                        if self.logging_enabled:
                            logging.debug(&#34;School process converged&#34;)
                    break

        if self.logging_enabled:
            logging.debug(&#34;School process ended.&#34;)
        if self.logging_enabled:
            logging.debug(&#39;Export data&#39;)
        self.export_data(self.export)


    def convergence_check(self):
        &#34;&#34;&#34;
        Checks if the processes have converged.

        Returns: True if converged.
        &#34;&#34;&#34;
        window_size = self.params[&#39;window_size&#39;]
        time = self.scheduler.get_time()
        school_time = self.scheduler.get_time(&#39;school&#39;)

        # Check what type of segregation to calculate (i.e., which of the
        # processes is running)
        if not self.res_ended:
            self.segregation.append(self.measurements.calculate_segregation(
                type=&#34;bounded_neighbourhood&#34;, index=&#34;Theil&#34;))
        else:
            self.segregation.append(self.measurements.calculate_segregation(
                type=&#34;school&#34;, index=&#34;Theil&#34;))

        # Wait until there is enough steps in the school process
        if (self.res_ended and school_time&lt;window_size):
            return False

        # Check all metrics in the window size and check if they are below
        # the convergence threshold
        if time &gt;= window_size-1:
            utilities = self.measurements.households[
                time-window_size+1:time+1, :, 4]
            means = utilities.mean(axis=1)
            stds = utilities.std(axis=1)

            metrics = np.vstack((means, stds,
                self.segregation[time-window_size+1:time+1]))
            
            metric_means = np.repeat(metrics.mean(axis=1)[:, np.newaxis],
                window_size, axis=1)
            mad = np.abs(metrics - metric_means)
            if np.all(mad &lt; self.params[&#34;conv_threshold&#34;]):
                # Start over if the residential process has converged
                self.res_ended=True
                return True

        return False


    def choose_locations(self, amount, method=&#34;evenly_spaced&#34;):
        &#34;&#34;&#34;
        Compute a number of locations to place school and neighbourhood objects.
        Currently, only random and evenly spaced locations are allowed.

        Args:
            amount (int): the number of agents to place.
            method (str): &#39;evenly_spaced&#39; only supported method for now.

        Returns:
            list: containing all the locations in tuple (x,y) format.
        &#34;&#34;&#34;

        if amount == 0:
            return []

        else:
            
            # Evenly spaced is also used in &#39;random_per_neighbourhood&#39;
            per_side = np.sqrt(amount)
            if per_side % 1 != 0:
                print(&#34;Unable to place amount of locations using given method&#34;)
                sys.exit(1)

            # Compute locations
            per_side = int(per_side)
            xs = np.linspace(0, self.params[&#39;width&#39;], per_side*2+1)[1::2]
            ys = np.linspace(0, self.params[&#39;height&#39;], per_side*2+1)[1::2]
            locations = [(x,y) for x in xs for y in ys]

        if method == &#34;random&#34;:
            locations = []
            i = 0
            while i &lt; amount:
                x_coord = np.random.randint(low=0, high=self.params[&#39;width&#39;])
                y_coord = np.random.randint(low=0, high=self.params[&#39;height&#39;])
                if (x_coord, y_coord) not in locations:
                    locations.append((x_coord, y_coord))
                    i += 1

        elif method == &#34;random_per_neighbourhood&#34;:

            width, height = self.params[&#34;width&#34;], self.params[&#39;height&#39;]
            n_schools = self.params[&#39;n_schools&#39;]
            n_neighbourhoods = self.params[&#39;n_neighbourhoods&#39;]
            per_side = int(np.sqrt(n_neighbourhoods))
            location_width = width / per_side
            location_height = height / per_side

            # Draw a random sample per neighbourhood as long as there are
            # schools to place
            locations = []
            i = 0
            while i &lt; max(n_neighbourhoods, n_schools):
                y_low = 0
                for col in range(per_side):
                    x_low = 0
                    y_high = int((1 + col) * location_height)

                    for row in range(per_side):

                        x_high = int((1 + row) * location_width)

                        if x_high &gt;= width:
                            x_high = width - 1
                        elif y_high &gt;= height:
                            y_high = height - 1

                        x_coord = np.random.randint(low=x_low, high=x_high)
                        y_coord = np.random.randint(low=y_low, high=y_high)

                        # Check if the coordinates haven&#39;t already been sampled
                        while (x_coord, y_coord) in locations:
                            x_coord = np.random.randint(low=x_low, high=x_high)
                            y_coord = np.random.randint(low=y_low, high=y_high)

                        locations.append((x_coord, y_coord))
                        x_low = x_high + 1
                        i += 1
                    y_low = y_high + 1

            # Shuffle all locations if n_schools &lt;= n_neighbourhoods, otherwise
            # shuffle only the remainder
            if n_schools &lt;= n_neighbourhoods:
                random.shuffle(locations)
            else:
                divider = int(n_schools / n_neighbourhoods)
                remainder = n_schools % n_neighbourhoods
                first_locations = locations[:n_neighbourhoods*divider]
                rest_locations = locations[n_neighbourhoods*divider:]
                random.shuffle(rest_locations)
                locations = first_locations + rest_locations[:remainder]

        return locations


    def compute_distances(self):
        &#34;&#34;&#34;
        Compute distance from all grid cells to all schools and all
        neighbourhood objects.

        Returns:
            dict: of dicts containing all Euclidean distances
        &#34;&#34;&#34;
        
        EPS = 1.2e-6
        distances = {}
        closest_schools = {}
        furthest_schools = {}
        closest_neighbourhoods = {}
        for x in range(self.params[&#34;width&#34;]):

            for y in range(self.params[&#34;height&#34;]):
                
                max_dist_school = 0
                min_dist_school = 10e10
                loc_distances = {}

                # Loop over all neighbourhoods, calculate distance and save
                # closest
                point = Point(x,y)
                for neighbourhood in self.get_agents(&#34;neighbourhoods&#34;):
                    shape = neighbourhood.shape.buffer(EPS)
                    if shape.contains(point):
                        closest_neighbourhoods[str((x,y))] = str(neighbourhood.pos)
                        break

                # Loop over all schools, calculate distance and save furthest
                # and closest
                for school in self.get_agents(&#34;schools&#34;):

                    distance = self.calculate_distance(school.pos,(x, y))
                    loc_distances[str(school.pos)] = distance

                    if distance &lt; min_dist_school:
                        min_dist_school = distance
                        closest_school = str(school.pos)

                    if distance &gt; max_dist_school:
                        max_dist_school = distance
                        furthest_school = str(school.pos)

                closest_schools[str((x,y))] = (closest_school, min_dist_school)
                furthest_schools[str((x,y))] = (furthest_school, max_dist_school)
                distances[str((x,y))] = loc_distances

        return distances, closest_schools, furthest_schools, \
            closest_neighbourhoods


    def compute_norm_distances(self, distances, closest_schools, 
        furthest_schools, closest_neighbourhoods):
        &#34;&#34;&#34;
        Compute normalised distance from all grid cells to all schools and all
        neighbourhood objects.

        Args:
            distances (dict): distances per position to every school/neighb.
            closest_schools (dict): closest schools per position
            furthest_schools (dict): furthest schools per position
            closest_neighbourhoods (dict): closest neighbourhood per position

        Returns:
            dict: of dicts containing all normalised school distances

        Note:
            * Neighbourhood distances are not normalised!
        &#34;&#34;&#34;
        norm_dists = {}
        for pos in distances.keys():
            normalised = {}
            for location in distances[pos].keys():
                
                if (location!=&#39;closest_school&#39; and location!=&#39;furthest_school&#39;):
                    
                    # Get the min and max distance to a school and normalise
                    minimum = closest_schools[pos][1]
                    maximum = furthest_schools[pos][1]
                    normalised[location] = (maximum - distances[pos][location]) / \
                        (maximum - minimum)

                else:
                    normalised[location] = distances[pos][location]

            norm_dists[pos] = normalised
        return norm_dists


    def calculate_distance(self, pos_1, pos_2):
        &#34;&#34;&#34;
        Calculates the distance between two points, accounting for toroidal space.
        This function is borrowed from the ContinuousSpace class definition
        by MESA.

        Args:
            pos_1 (tuple): (x,y) coordinates.
            pos_2 (tuple): (x,y) coordinates.

        Returns:
            float: Euclidean distance between the two points.

        &#34;&#34;&#34;
        x1, y1 = pos_1
        x2, y2 = pos_2

        dx = np.abs(x1 - x2)
        dy = np.abs(y1 - y2)
        if self.params[&#34;torus&#34;]:
            dx = min(dx, self.params[&#34;width&#34;] - dx)
            dy = min(dy, self.params[&#34;height&#34;] - dy)
        return np.sqrt(dx * dx + dy * dy)


    def get_distances(self, pos):
        &#34;&#34;&#34;
        Returns distances from a given position to all school and neighbourhood
        objects.

        Args:
            pos (tuple): (x,y) coordinates.

        Returns:
            list: containing all the Euclidean distances.
        &#34;&#34;&#34;
        return self.distances[str(pos)]


    def get_norm_distances(self, pos):
        &#34;&#34;&#34;
        Returns nearness from a given position to all school and neighbourhood
        objects.

        Args:
            pos (tuple): (x,y) coordinates.

        Returns:
            list: containing all the normalized Euclidean distances.
        &#34;&#34;&#34;
        return self.norm_distances[str(pos)]


    def get_agents(self, type):
        &#34;&#34;&#34;
        Returns list of agents of given type.

        Args:
            type (str): either &#39;School&#39;, &#39;Neighbourhood&#39;, &#39;Household&#39; or
            &#39;Student&#39;.

        Returns:
            list: containing all the objects of the specified type.
        &#34;&#34;&#34;
        return self.agents[type]


    def export_data(self, export=False):
        &#34;&#34;&#34;
        Export data for visualization.
        &#34;&#34;&#34;
        if export:
            self.measurements.export_data()


    def get_shock(self, N=1):
        &#34;&#34;&#34;
        Returns a small random value around zero used as perturbation in value
        determinations to make deterministic processes random.

        Checks if shocks are available. Returns the front value, creates a
        new array of shocks if not available.
        &#34;&#34;&#34;

        # If empty
        sigma, size = 0.01, 1000
        if len(self.shocks) &lt;= N:
            self.shocks = np.random.normal(0, scale=sigma, size=size)

        # Pop front value
        val = self.shocks[0:N]
        self.shocks = self.shocks[N:-1]
        return val


    def get_uniform_shock(self, N=1):
        &#34;&#34;&#34;
        Returns a small random value around zero used as perturbation in value
        determinations to make deterministic processes random.

        Checks if shocks are available. Returns the front value, creates a
        new array of shocks if not available.
        &#34;&#34;&#34;

        # If empty
        size = 1000
        if len(self.uniform_shocks) &lt;= N:
            self.uniform_shocks = np.random.random(size=size)

        # Pop front value
        val = self.uniform_shocks[0:N]
        self.uniform_shocks = self.uniform_shocks[N:-1]
        return val


    def close_school(self, choice=&#34;most_segregated&#34;):
        &#34;&#34;&#34;
        Close a school randomly, or the most segregated.

        Args:
            choice (str): either &#39;most_segregated&#39; (default) or &#39;random&#39;.

        &#34;&#34;&#34;

        if choice == &#34;most_segregated&#34;:
            segregation = self.measurements.calculate_segregation(
                per_location=True)
            max_segregated = np.argmax(segregation)
            school = self.get_agents(&#34;schools&#34;)[max_segregated]
        elif choice == &#34;random&#34;:
            school_index = np.random.randint(len(self.get_agents(&#34;schools&#34;)))
            school = self.get_agents(&#34;schools&#34;)[school_index]
        else:
            print(&#34;School closure method is not supported&#34;)
            sys.exit(1)

        self.get_agents(&#34;schools&#34;).remove(school)
        self.scheduler.remove(school)
        self.grid.remove_agent(school)


    def increment_agent_count(self):
        &#34;&#34;&#34;
        Increment agent count by one.
        &#34;&#34;&#34;
        self.agents[&#34;amount&#34;] += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="compass.model.CompassModel"><code class="flex name class">
<span>class <span class="ident">CompassModel</span></span>
<span>(</span><span>params, export=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Model class for school segregation dynamics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>Argparser</code></dt>
<dd>containing all parameter values.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>params (dict):</dt>
<dt><strong><code>grid</code></strong> :&ensp;<code>MultiGrid</code></dt>
<dd>MultiGrid object from Mesa.</dd>
<dt><strong><code>scheduler</code></strong> :&ensp;<code>ThreeStagedActivation</code></dt>
<dd>ThreeStagedActivation object.</dd>
<dt><strong><code>agents</code></strong> :&ensp;<code>list</code></dt>
<dd>all agents in the model.</dd>
<dt><strong><code>measurements</code></strong> :&ensp;<code>Measurements</code></dt>
<dd>Measurements object.</dd>
<dt><strong><code>global_composition</code></strong> :&ensp;<code>dict</code></dt>
<dd>containing the total system compositions.</dd>
<dt><strong><code>distance_matrix</code></strong> :&ensp;<code>list</code></dt>
<dd>all the Euclidean distances from one grid cell
to another.</dd>
<dt><strong><code>nearness_matrix</code></strong> :&ensp;<code>list</code></dt>
<dd>same as above but with normalized distances.</dd>
<dt><strong><code>global_composition_normalized</code></strong> :&ensp;<code>dict</code></dt>
<dd>normalized system compositions.</dd>
</dl>
<p>Create a new model. Overload this method with the actual code to
start the model.</p>
<h2 id="attributes_1">Attributes</h2>
<dl>
<dt><strong><code>schedule</code></strong></dt>
<dd>schedule object</dd>
<dt><strong><code>running</code></strong></dt>
<dd>a bool indicating if the model should continue running</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompassModel(Model):
    &#34;&#34;&#34;
    Model class for school segregation dynamics.

    Args:
        params (Argparser): containing all parameter values.

    Attributes:
        params (dict):
        grid (MultiGrid): MultiGrid object from Mesa.
        scheduler (ThreeStagedActivation): ThreeStagedActivation object.
        agents (list): all agents in the model.
        measurements (Measurements): Measurements object.
        global_composition (dict): containing the total system compositions.
        distance_matrix (list): all the Euclidean distances from one grid cell
            to another.
        nearness_matrix (list): same as above but with normalized distances.
        global_composition_normalized (dict): normalized system compositions.
    &#34;&#34;&#34;
    def __init__(self, params, export=False):

        super().__init__()

        # Initialise the model attributes
        self.set_attributes(params=params, export=export)

        # Initialise agents
        if self.logging_enabled:
            logging.debug(&#39;Initialising agents&#39;)
        if self.params[&#39;case&#39;].lower() != &#39;lattice&#39;:
            self.load_agents(self.params[&#39;case&#39;].lower())
        else:
            self.create_agents()

        # Get values of the initial configuration
        self.measurements.end_step(residential=True)

        # Calculate global compositions for the segregation calculations
        self.global_composition = self.measurements.neighbourhoods[
            0, :, :2].sum(axis=0)
        self.global_composition_normalized = self.global_composition / \
            self.global_composition.sum()

        text = f&#34;&#34;&#34; Model initialised:
            NR AGENTS:  Households: {self.params[&#39;n_households&#39;]}
            Neighbourhoods: {self.params[&#39;n_neighbourhoods&#39;]}
            Schools: {self.params[&#39;n_schools&#39;]}
            In scheduler: {self.scheduler.get_agent_count()}&#34;&#34;&#34;
        print(text)
        if self.logging_enabled:
            logging.debug(text)


    def set_attributes(self, params, export=False):
        &#34;&#34;&#34;
        Sets or calculates all attributes used in the Compass class.

        Args:
            params (Argparser): containing all parameter values.
            export (bool): True if the data needs to be exported or not.
        &#34;&#34;&#34;

        # Calculate number of households and students
        
        params[&#34;n_households&#34;] = int(params[&#34;household_density&#34;]
            * (params[&#34;width&#34;] * params[&#34;height&#34;]
            - params[&#34;n_neighbourhoods&#34;] - params[&#34;n_schools&#34;]))
        params[&#39;n_students&#39;] = int(params[&#34;n_households&#34;] * 
                params[&#34;student_density&#34;])
        self.params = dict(params)

        # Set up logger
        self.logging_enabled = params[&#39;logging_enabled&#39;]
        if self.logging_enabled:     
            self.logger(log_path=&#39;logs/&#39;, filename=&#39;model.log&#39;)
            logging.debug(&#39;Starting new model&#39;)

        # Precalculate shocks
        self.uniform_shocks = np.random.random(1000)
        self.shocks = np.random.normal(0, 0.05, 1000)

        # Set tracking attributes
        self.export = export
        self.segregation = []       # Track segregation over time
        self.res_ended = False
        self.school_ended = False
        self.composition = self.composition_normalized = None
        self.agents = {&#34;amount&#34;: 0, &#34;households&#34;: [], &#34;schools&#34;: [],
            &#34;neighbourhoods&#34;: []}
        
        # Initialise other objects
        self.measurements = Measurements(self)
        self.scheduler = ThreeStagedActivation(self)
        self.grid = ContinuousSpace(self.params[&#34;width&#34;], self.params[&#34;height&#34;],
                                torus=self.params[&#34;torus&#34;])


    def create_agents(self):
        &#34;&#34;&#34;
        Creates the agents when no case study is provided.
        &#34;&#34;&#34;
        self.neighbourhoods()
        self.schools()
        self.location_to_agent()

        # Compute distance matrix 
        self.distances, \
        self.closest_schools, \
        self.furthest_schools, \
        self.closest_neighbourhoods = self.compute_distances()

        # Compute normalised distances (nearness matrix)
        self.norm_distances = self.compute_norm_distances(
            self.distances, 
            self.closest_schools, 
            self.furthest_schools,
            self.closest_neighbourhoods)

        if self.logging_enabled:
            logging.debug(&#39;Placing households and creating attribute matrix&#39;)
        self.households()

    
    def set_agent_parameters(self, params, households):
        &#34;&#34;&#34;
        Puts the agent parameters in numpy arrays for faster computations. 

        Args:
            params (dict): Model parameters which could differ from
                the agent params!
            households (list): list of Household objects. Students should
                inherit their parameters from the Household object.

        Todo:
            Parameters should be imported from a config file in the future.
        &#34;&#34;&#34;

        # to remember the index in the array of the specific household
        array_index = 0

        n_agents = len(households)
        self.local_compositions = []
        self.neighbourhood_compositions = []

        self.utility_at_max = np.repeat(params[&#39;utility_at_max&#39;][0][0], 
            n_agents)
        self.neighbourhood_mixture = np.repeat(params[&#39;neighbourhood_mixture&#39;], 
            n_agents)
        self.alpha = np.repeat(params[&#39;alpha&#39;], n_agents)
        self.optimal_fraction = np.repeat(params[&#39;optimal_fraction&#39;][0][0], 
            n_agents)

        if self.params[&#39;case&#39;].lower() == &#39;lattice&#39;:
            local_compositions = self.normalized_compositions
        
        for household in households:
            household.array_index = array_index
            x,y = household.pos

            # Currently only convolution (assumes every household has the same
            # radius) for composition calculations within the lattice case.
            if self.params[&#39;case&#39;].lower() == &#39;lattice&#39;:
                self.local_compositions.append(
                    local_compositions[x,y,household.category])

            self.neighbourhood_compositions.append(
                household.neighbourhood.composition_normalized[household.category])
            array_index += 1

        self.agent_distances = np.zeros(n_agents)
        self.school_compositions = np.zeros(n_agents)
        self.vectorise_functions() # for element-wise operations


    def vectorise_functions(self):
        &#34;&#34;&#34;
        Vectorises functions using numpy.vectorize for use in 
        array computations.
        &#34;&#34;&#34;
        self.calc_comp_utility_v = np.vectorize(self.calc_comp_utility)


    def calc_comp_utility(self, x, M, f):
        &#34;&#34;&#34;
        Calculates the utility given a normalised composition (0&lt;=x&lt;=1), an 
        optimal fraction (0&lt;=f&lt;=1) and utility at homogeneity (0&lt;=M&lt;=1).
        &#34;&#34;&#34;
        if x &lt;= f:
            utility =  x / f
        else:
            utility =  M + (1-x)*(1-M) / (1-f)
        return utility


    def logger(self, log_path, filename):
        &#34;&#34;&#34;
        Sets up the logger.
        &#34;&#34;&#34;

        self.log_path = log_path
        # Check if folder exist, otherwise create it.
        if not os.path.exists(log_path):
            os.makedirs(log_path)

        fileh = logging.FileHandler(log_path + filename, &#39;a&#39;)
        formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - &#39; + \
            &#39;%(levelname)s - %(message)s&#39;)
        fileh.setFormatter(formatter)

        log = logging.getLogger()  # root logger
        for hdlr in log.handlers[:]:  # remove all old handlers
            if isinstance(hdlr, logging.FileHandler):
                log.removeHandler(hdlr)
        log.setLevel(self.params[&#39;loglevel&#39;])
        log.addHandler(fileh)      # set the new handler


    def neighbourhoods(self):
        &#34;&#34;&#34;
        Adds the neighbourhood objects to the environment.
        &#34;&#34;&#34;

        n_neighs = self.params[&#34;n_neighbourhoods&#34;]

        # Add neighbourhoods if necessary
        if n_neighs:
            locations = self.choose_locations(n_neighs,
                                self.params[&#34;neighbourhoods_placement&#34;])
            for i in range(n_neighs):
                
                x, y = locations[i]
                location = (x, y)
                size = self.params[&#39;width&#39;] / float(n_neighs**0.5 * 2)
                minx, miny = x - size, y - size
                maxx, maxy = x + size, y + size
                shape = box(minx, miny, maxx, maxy)

                # Create the Neighbourhood object and place it on the grid and
                # add it to the scheduler
                neighbourhood = Neighbourhood(self.get_agents(&#34;amount&#34;),
                                        location, shape, self, 
                                        self.params)
                self.get_agents(&#34;neighbourhoods&#34;).append(neighbourhood)
                self.scheduler.add(neighbourhood)
                self.grid.place_agent(neighbourhood, locations[i])


    def schools(self):
        &#34;&#34;&#34;
        Adds the school objects to the environment.
        &#34;&#34;&#34;

        # Add schools if necessary
        if self.params[&#34;n_schools&#34;]:
            locations = self.choose_locations(self.params[&#34;n_schools&#34;],
                                self.params[&#34;schools_placement&#34;])
            for i in range(self.params[&#34;n_schools&#34;]):
                x, y = locations[i]
                location = (x, y)

                # Create the School object and place it on the grid and add it
                # to the scheduler
                school = School(self.get_agents(&#34;amount&#34;),
                    location, self, self.params)
                self.get_agents(&#34;schools&#34;).append(school)
                self.scheduler.add(school)
                self.grid.place_agent(school, location)


    def households(self):
        &#34;&#34;&#34;
        Adds the household objects to the environment.

        Todo:
            * Place household specific parameters in a attribute called params
        &#34;&#34;&#34;

        params = self.params
        self.household_attrs = np.zeros(shape=(params[&#34;width&#34;],
            params[&#39;height&#39;], len(params[&#39;group_types&#39;][0])))

        # Create group types, empty spots and shuffle them both
        n_groups = len(params[&#34;group_categories&#34;])
        groups = [np.random.choice(list(range(0,
            len(params[&#34;group_types&#34;][i]))), size=params[&#34;n_households&#34;],
            p=params[&#34;group_dist&#34;][i]) for i in range(n_groups)]

        self.grid.empties = set(
            [(x,y) for x in range(params[&#39;width&#39;]) 
            for y in range(params[&#39;height&#39;])])
        empties = list(self.grid.empties)
        np.random.shuffle(empties)

        # Sample tolerances
        tolerances0, tolerances1 = self.sample_tolerances(
            params[&#34;optimal_fraction&#34;][0],
            scale=params[&#39;homophily_std&#39;],
            size=params[&#34;n_households&#34;])


        for i, position in enumerate(empties[0:params[&#34;n_households&#34;]]):
            household = Household(self.get_agents(&#34;amount&#34;), position, self,
                params, groups[0][i])

            # Find according group and group specific information
            for j in range(len(groups)):
                category = groups[j][i]
                if category == 0:
                    tolerance = tolerances0[i]
                elif category == 1:
                    tolerance = tolerances1[i]

                # Save household specific parameters
                household.groups.append({
                    &#34;group_name&#34;:       params[&#34;group_categories&#34;][j],
                    &#34;type_index&#34;:       groups[j][i],
                    &#34;group_size&#34;:       len(params[&#34;group_types&#34;][j]),
                    &#34;group_type&#34;:       params[&#34;group_types&#34;][j][groups[j][i]],
                    &#34;threshold&#34;:        params[&#34;category_thresholds&#34;][j][groups[j][i]],
                    &#34;utility_at_max&#34;:   params[&#34;utility_at_max&#34;][j][groups[j][i]],
                    &#34;optimal_fraction&#34;: tolerance
                    })

            # Place households on the grid and add them to the scheduler
            self.get_agents(&#34;households&#34;).append(household)
            self.grid.place_agent(household, position)
            self.grid.empties.discard(position)
            self.scheduler.add(household)
            self.household_attrs[position[0], position[1], :] = household.attributes

        
        # Calculate AFTER all agents are placed
        all_households = self.get_agents(&#39;households&#39;)
        self.calc_residential_compositions()
        self.set_agent_parameters(params, all_households)
        self.calc_res_utilities()
        [household.update_utilities() for household in all_households]


    def load_agents(self, case=&#39;Amsterdam&#39;):
        &#34;&#34;&#34;
        Load the agents from a pickle.

        Note:
            This function is in progress and works only for the Amsterdam and
            IJburg case currently. In the future agents should be able to be 
            imported in a general manner.
        &#34;&#34;&#34;

        if case.lower()==&#39;ijburg&#39;:
            file = open(r&#39;compass/maps/ijburg/agents_ijburg.pickle&#39;, &#39;rb&#39;)
        elif case.lower()==&#39;amsterdam&#39;:
            file = open(r&#39;compass/maps/amsterdam/agents_10p.pickle&#39;, &#39;rb&#39;)

        data = pickle.load(file)

        # Create grid
        xmin, ymin, xmax, ymax = data[&#39;neighbourhoods_gpd&#39;].total_bounds
        self.grid = ContinuousSpace(xmax, ymax, self.params[&#34;torus&#34;],
            xmin, ymin)
        self.params[&#39;max_res_steps&#39;] = 0
        self.grid.empties = [(0,0)]
        self.closest_neighbourhoods = {}

        agents = data[&#39;agents&#39;]
        self.params[&#39;n_neighbourhoods&#39;] = len(agents[agents.object==&#39;Neighbourhood&#39;])
        self.params[&#39;n_schools&#39;] = len(agents[agents.object==&#39;School&#39;])
        self.params[&#39;n_households&#39;] = len(agents[agents.object==&#39;Household&#39;])
        self.params[&#39;n_students&#39;] = int(self.params[&#34;n_households&#34;] * 
                self.params[&#34;student_density&#34;])

        for index, agent in agents.iterrows():
    
            if agent.object==&#39;Neighbourhood&#39;:
                neighbourhood = Neighbourhood(index, (agent.x, agent.y),
                                    agent.geometry, self, self.params)
                self.get_agents(&#34;neighbourhoods&#34;).append(neighbourhood)
                self.scheduler.add(neighbourhood)
                pos = neighbourhood.shape.centroid
                self.grid.place_agent(neighbourhood, (pos.x, pos.y))

            elif agent.object==&#39;School&#39;:
                school = School(index, (agent.x, agent.y), self, self.params)
                self.get_agents(&#34;schools&#34;).append(school)
                self.scheduler.add(school)
                self.grid.place_agent(school, (agent.x, agent.y))

            elif agent.object==&#39;Household&#39;:
                pos = (agent.x, agent.y)
                for nhood in self.get_agents(&#39;neighbourhoods&#39;):
                    if nhood.shape.contains(Point(pos)):
                        self.closest_neighbourhoods[str(pos)] = nhood
                        
                        household = Household(index, (agent.x, agent.y), 
                                                self, self.params,
                                                category=int(agent.group),
                                                nhood=nhood)
                        self.get_agents(&#34;households&#34;).append(household)
                        self.scheduler.add(household)
                        self.grid.place_agent(household, (agent.x, agent.y))
                        break            
        
        self.location_to_agent()
        households = self.get_agents(&#39;households&#39;)

        self.distances = data[&#39;distances&#39;]
        self.closest_schools = data[&#39;closest_schools&#39;]
        self.furthest_schools = data[&#39;furthest_schools&#39;]
        self.norm_distances = self.compute_norm_distances(
            self.distances, 
            self.closest_schools, 
            self.furthest_schools, {})

        self.set_agent_parameters(self.params, households)

        self.local_compositions = self.neighbourhood_compositions
        self.calc_res_utilities()

        # Initial compositions need to be calculated
        for household in households:
            # Only bounded calculation
            household.params[&#39;neighbourhood_mixture&#39;] = 1
            household.update_utilities()


    def location_to_agent(self):
        &#34;&#34;&#34;
        Creates a dictionary with the location of the neighbourhoods as key and
        the object itself as value. Schools are not included as they can have 
        the same position as a neighbourhood (centroid).
        &#34;&#34;&#34;

        agents = self.get_agents(&#39;neighbourhoods&#39;)
        self.location_to_agent = {str(agent.pos):agent for agent in agents}


    def sample_tolerances(self, means, scale, size):
        &#34;&#34;&#34;
        Sample tolerance levels from a truncated normal distribution.
        &#34;&#34;&#34;
        tolerances = [0]*len(means)
        for index, mu in enumerate(means):

            # All tolerances are equal if the scale is zero.
            if scale==0:
                tolerances[index] = np.repeat(mu, size)
            else:
                tolerances[index] = truncnorm.rvs((0-mu)/scale, (1-mu)/scale,
                                                loc=mu, scale=scale, size=size)
        return tolerances


    def calc_residential_compositions(self):
        &#34;&#34;&#34;
        Updates all local residential compositions assuming all households have
        the SAME RADIUS.
        &#34;&#34;&#34;

        # Determine the kernel of the convolution
        radius = self.params[&#39;radius&#39;]
        dim = radius*2 + 1
        self.kernel = np.ones((dim, dim))
        self.kernel[radius, radius] = 0

        # Should it wrap around the edges or not?
        if self.params[&#39;torus&#39;]:
            mode=&#39;wrap&#39;
        else:
            mode=&#39;constant&#39;

        summed = 0
        num_attrs = self.household_attrs.shape[2]
        compositions = np.zeros(shape=self.household_attrs.shape)

        # Convolution for every household attribute.
        for attr in range(num_attrs):
            compositions[:,:,attr] = convolve(
                self.household_attrs[:,:,attr],
                self.kernel, mode=mode)
            summed += compositions[:,:,attr]
        self.compositions = compositions
        self.normalized_compositions = np.nan_to_num(
            compositions / np.repeat(summed[:, :, np.newaxis],
                num_attrs, axis=2))


    def calc_school_compositions(self):
        &#34;&#34;&#34;
        Calculate the new school compositions for every household and only for 
        the first student!

        Note:
            Currently only for the first student!!!
        &#34;&#34;&#34;

        for household in self.get_agents(&#39;households&#39;):
            category = household.category
            array_index = household.array_index
            self.agent_distances[array_index] = household.distance
            self.school_compositions[array_index] = \
                household.students[0].school.composition_normalized[category]
            

    def calc_res_utilities(self):
        &#34;&#34;&#34;
        Calculates residential utility at a household its current position and 
        given its parameter values. 
        &#34;&#34;&#34;
        
        b = self.neighbourhood_mixture
        f = self.optimal_fraction
        M = self.utility_at_max
        x = (1-b)*self.local_compositions + \
            b*self.neighbourhood_compositions
        self.res_utilities = self.calc_comp_utility_v(x, M, f)


    def calc_school_utilities(self):
        &#34;&#34;&#34;
        Calculates school utilities at a student its current school, given 
        distance and its other parameter values. 
        &#34;&#34;&#34;

        alpha = self.alpha
        f = self.optimal_fraction
        M = self.utility_at_max
        x = self.school_compositions
        distances = self.agent_distances
        self.school_composition_utilities = self.calc_comp_utility_v(x, M, f)
        self.school_utilities = (self.school_composition_utilities ** alpha) * \
            (distances ** (1 - alpha))


    def calc_school_rankings(self, households, schools):
        &#34;&#34;&#34;
        Ranks the schools according to utility.

        Args:
            households (list): list of households the rankings need to be
                calculated for.
            schools (list): list of schools that need to be ranked.

        Todo:
            Schools can differ per household if we only want to look at the 
            n-closest schools for example?
        &#34;&#34;&#34;
        
        compositions = np.array(
            [school.composition_normalized for school in schools])

        for household in households:
            
            # Get the normalised distance to every school
            category = household.category
            nearness = self.get_norm_distances(household.pos)
            distances = np.array([nearness[str(school.pos)] for school in schools])

            # Composition utility calculations
            f = household.params[&#39;optimal_fraction&#39;][0][category]
            M = household.params[&#39;utility_at_max&#39;][0][category]
            x = compositions[:, category]
            composition_utilities = self.calc_comp_utility_v(x, M, f)

            # Combined
            alpha = household.params[&#39;alpha&#39;]
            utilities = (composition_utilities ** alpha) * \
                (distances ** (1 - alpha))
            utility_dict = dict(zip(schools, utilities))
            ranking = sorted(utility_dict, key=utility_dict.get, reverse=True)
            
            # Set the same ranking for every student
            [student.set_school_preference(ranking) for student in household.students]


    def get_attributes(self, pos):
        &#34;&#34;&#34;
        Returns the attribute vector of a given position

        Args:
            pos (tuple): (x,y) coordinates.

        Returns:
            Numpy array: containing all the attributes (all zeros if empty)
        &#34;&#34;&#34;
        return self.household_attrs[pos[0], pos[1], :]


    def switch_attrs(self, pos1, pos2):
        &#34;&#34;&#34;
        Switches two attribute vectors in the attribute grid by making a copy.

        Args:
            pos1 (tuple): (x,y) coordinates.
            pos2 (tuple): (x,y) coordinates.
        &#34;&#34;&#34;
        temp = np.copy(self.household_attrs[pos1])
        self.household_attrs[pos1] = self.household_attrs[pos2]
        self.household_attrs[pos2] = temp


    def step(self, residential=False, initial_schools=False):
        &#34;&#34;&#34;
        Perform model steps.

        Args:
            residential (bool): True if a residential step needs to be done,
                False (default) means a school step.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;

        # Perform school or residential step.
        message = f&#39;Perform model step, residential = {residential}, initial schools = {initial_schools}&#39;
        if self.logging_enabled:
            logging.debug(message)
        self.scheduler.step(residential=residential,
                            initial_schools=initial_schools)


    def simulate(self, res_steps=None, school_steps=None):
        &#34;&#34;&#34;
        Performs #res_steps of residential steps and #school_steps of school
        steps.

        Args:
            res_steps (int): Number of residential steps.
            school_steps (int): Number of school steps.
            initial_schools (bool): True if an initial school step needs to be
                done, False (default) means a school step.
        &#34;&#34;&#34;
        if not res_steps:
            res_steps = self.params[&#39;max_res_steps&#39;]

        if not school_steps:
            school_steps = self.params[&#39;max_school_steps&#39;]

        logging_level = logging.root.level
        while (self.scheduler.get_time(&#39;residential&#39;) &lt; res_steps \
            and not self.res_ended):

            if logging_level &gt;= 10:
                f = &#34;Residential process: step &#34; + str(
                self.scheduler.get_time(&#39;residential&#39;)+1) + &#34; from &#34; + \
                    str(res_steps)
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()
                if self.logging_enabled:
                    logging.debug(f)

            self.res_ended = self.convergence_check()
            if not self.res_ended:
                self.step(residential=True)
            else:
                if logging_level &gt;= 10:
                    if self.logging_enabled:
                        logging.debug(&#34;\nResidential process converged&#34;)
                break
        
        if self.logging_enabled:
            logging.debug(&#34;Residential process ended.&#34;)
        print()
        while (self.scheduler.get_time(&#39;school&#39;) &lt; school_steps \
            and not self.school_ended):

            if logging_level &gt;= 10:
                f = &#34;School process: step &#34; + str(
                self.scheduler.get_time(&#39;school&#39;)+1) + &#34; from &#34; + \
                    str(school_steps)
                sys.stdout.write(&#34;\r&#34; + f)
                sys.stdout.flush()
                if self.logging_enabled:
                    logging.debug(f)

            self.school_ended = self.convergence_check()
            if self.scheduler.school_steps == 0:
                self.step(residential=False, initial_schools=True)
            else:
                if not self.school_ended:
                    self.step(residential=False, initial_schools=False)
                else:
                    if logging_level &gt;= 10:
                        if self.logging_enabled:
                            logging.debug(&#34;School process converged&#34;)
                    break

        if self.logging_enabled:
            logging.debug(&#34;School process ended.&#34;)
        if self.logging_enabled:
            logging.debug(&#39;Export data&#39;)
        self.export_data(self.export)


    def convergence_check(self):
        &#34;&#34;&#34;
        Checks if the processes have converged.

        Returns: True if converged.
        &#34;&#34;&#34;
        window_size = self.params[&#39;window_size&#39;]
        time = self.scheduler.get_time()
        school_time = self.scheduler.get_time(&#39;school&#39;)

        # Check what type of segregation to calculate (i.e., which of the
        # processes is running)
        if not self.res_ended:
            self.segregation.append(self.measurements.calculate_segregation(
                type=&#34;bounded_neighbourhood&#34;, index=&#34;Theil&#34;))
        else:
            self.segregation.append(self.measurements.calculate_segregation(
                type=&#34;school&#34;, index=&#34;Theil&#34;))

        # Wait until there is enough steps in the school process
        if (self.res_ended and school_time&lt;window_size):
            return False

        # Check all metrics in the window size and check if they are below
        # the convergence threshold
        if time &gt;= window_size-1:
            utilities = self.measurements.households[
                time-window_size+1:time+1, :, 4]
            means = utilities.mean(axis=1)
            stds = utilities.std(axis=1)

            metrics = np.vstack((means, stds,
                self.segregation[time-window_size+1:time+1]))
            
            metric_means = np.repeat(metrics.mean(axis=1)[:, np.newaxis],
                window_size, axis=1)
            mad = np.abs(metrics - metric_means)
            if np.all(mad &lt; self.params[&#34;conv_threshold&#34;]):
                # Start over if the residential process has converged
                self.res_ended=True
                return True

        return False


    def choose_locations(self, amount, method=&#34;evenly_spaced&#34;):
        &#34;&#34;&#34;
        Compute a number of locations to place school and neighbourhood objects.
        Currently, only random and evenly spaced locations are allowed.

        Args:
            amount (int): the number of agents to place.
            method (str): &#39;evenly_spaced&#39; only supported method for now.

        Returns:
            list: containing all the locations in tuple (x,y) format.
        &#34;&#34;&#34;

        if amount == 0:
            return []

        else:
            
            # Evenly spaced is also used in &#39;random_per_neighbourhood&#39;
            per_side = np.sqrt(amount)
            if per_side % 1 != 0:
                print(&#34;Unable to place amount of locations using given method&#34;)
                sys.exit(1)

            # Compute locations
            per_side = int(per_side)
            xs = np.linspace(0, self.params[&#39;width&#39;], per_side*2+1)[1::2]
            ys = np.linspace(0, self.params[&#39;height&#39;], per_side*2+1)[1::2]
            locations = [(x,y) for x in xs for y in ys]

        if method == &#34;random&#34;:
            locations = []
            i = 0
            while i &lt; amount:
                x_coord = np.random.randint(low=0, high=self.params[&#39;width&#39;])
                y_coord = np.random.randint(low=0, high=self.params[&#39;height&#39;])
                if (x_coord, y_coord) not in locations:
                    locations.append((x_coord, y_coord))
                    i += 1

        elif method == &#34;random_per_neighbourhood&#34;:

            width, height = self.params[&#34;width&#34;], self.params[&#39;height&#39;]
            n_schools = self.params[&#39;n_schools&#39;]
            n_neighbourhoods = self.params[&#39;n_neighbourhoods&#39;]
            per_side = int(np.sqrt(n_neighbourhoods))
            location_width = width / per_side
            location_height = height / per_side

            # Draw a random sample per neighbourhood as long as there are
            # schools to place
            locations = []
            i = 0
            while i &lt; max(n_neighbourhoods, n_schools):
                y_low = 0
                for col in range(per_side):
                    x_low = 0
                    y_high = int((1 + col) * location_height)

                    for row in range(per_side):

                        x_high = int((1 + row) * location_width)

                        if x_high &gt;= width:
                            x_high = width - 1
                        elif y_high &gt;= height:
                            y_high = height - 1

                        x_coord = np.random.randint(low=x_low, high=x_high)
                        y_coord = np.random.randint(low=y_low, high=y_high)

                        # Check if the coordinates haven&#39;t already been sampled
                        while (x_coord, y_coord) in locations:
                            x_coord = np.random.randint(low=x_low, high=x_high)
                            y_coord = np.random.randint(low=y_low, high=y_high)

                        locations.append((x_coord, y_coord))
                        x_low = x_high + 1
                        i += 1
                    y_low = y_high + 1

            # Shuffle all locations if n_schools &lt;= n_neighbourhoods, otherwise
            # shuffle only the remainder
            if n_schools &lt;= n_neighbourhoods:
                random.shuffle(locations)
            else:
                divider = int(n_schools / n_neighbourhoods)
                remainder = n_schools % n_neighbourhoods
                first_locations = locations[:n_neighbourhoods*divider]
                rest_locations = locations[n_neighbourhoods*divider:]
                random.shuffle(rest_locations)
                locations = first_locations + rest_locations[:remainder]

        return locations


    def compute_distances(self):
        &#34;&#34;&#34;
        Compute distance from all grid cells to all schools and all
        neighbourhood objects.

        Returns:
            dict: of dicts containing all Euclidean distances
        &#34;&#34;&#34;
        
        EPS = 1.2e-6
        distances = {}
        closest_schools = {}
        furthest_schools = {}
        closest_neighbourhoods = {}
        for x in range(self.params[&#34;width&#34;]):

            for y in range(self.params[&#34;height&#34;]):
                
                max_dist_school = 0
                min_dist_school = 10e10
                loc_distances = {}

                # Loop over all neighbourhoods, calculate distance and save
                # closest
                point = Point(x,y)
                for neighbourhood in self.get_agents(&#34;neighbourhoods&#34;):
                    shape = neighbourhood.shape.buffer(EPS)
                    if shape.contains(point):
                        closest_neighbourhoods[str((x,y))] = str(neighbourhood.pos)
                        break

                # Loop over all schools, calculate distance and save furthest
                # and closest
                for school in self.get_agents(&#34;schools&#34;):

                    distance = self.calculate_distance(school.pos,(x, y))
                    loc_distances[str(school.pos)] = distance

                    if distance &lt; min_dist_school:
                        min_dist_school = distance
                        closest_school = str(school.pos)

                    if distance &gt; max_dist_school:
                        max_dist_school = distance
                        furthest_school = str(school.pos)

                closest_schools[str((x,y))] = (closest_school, min_dist_school)
                furthest_schools[str((x,y))] = (furthest_school, max_dist_school)
                distances[str((x,y))] = loc_distances

        return distances, closest_schools, furthest_schools, \
            closest_neighbourhoods


    def compute_norm_distances(self, distances, closest_schools, 
        furthest_schools, closest_neighbourhoods):
        &#34;&#34;&#34;
        Compute normalised distance from all grid cells to all schools and all
        neighbourhood objects.

        Args:
            distances (dict): distances per position to every school/neighb.
            closest_schools (dict): closest schools per position
            furthest_schools (dict): furthest schools per position
            closest_neighbourhoods (dict): closest neighbourhood per position

        Returns:
            dict: of dicts containing all normalised school distances

        Note:
            * Neighbourhood distances are not normalised!
        &#34;&#34;&#34;
        norm_dists = {}
        for pos in distances.keys():
            normalised = {}
            for location in distances[pos].keys():
                
                if (location!=&#39;closest_school&#39; and location!=&#39;furthest_school&#39;):
                    
                    # Get the min and max distance to a school and normalise
                    minimum = closest_schools[pos][1]
                    maximum = furthest_schools[pos][1]
                    normalised[location] = (maximum - distances[pos][location]) / \
                        (maximum - minimum)

                else:
                    normalised[location] = distances[pos][location]

            norm_dists[pos] = normalised
        return norm_dists


    def calculate_distance(self, pos_1, pos_2):
        &#34;&#34;&#34;
        Calculates the distance between two points, accounting for toroidal space.
        This function is borrowed from the ContinuousSpace class definition
        by MESA.

        Args:
            pos_1 (tuple): (x,y) coordinates.
            pos_2 (tuple): (x,y) coordinates.

        Returns:
            float: Euclidean distance between the two points.

        &#34;&#34;&#34;
        x1, y1 = pos_1
        x2, y2 = pos_2

        dx = np.abs(x1 - x2)
        dy = np.abs(y1 - y2)
        if self.params[&#34;torus&#34;]:
            dx = min(dx, self.params[&#34;width&#34;] - dx)
            dy = min(dy, self.params[&#34;height&#34;] - dy)
        return np.sqrt(dx * dx + dy * dy)


    def get_distances(self, pos):
        &#34;&#34;&#34;
        Returns distances from a given position to all school and neighbourhood
        objects.

        Args:
            pos (tuple): (x,y) coordinates.

        Returns:
            list: containing all the Euclidean distances.
        &#34;&#34;&#34;
        return self.distances[str(pos)]


    def get_norm_distances(self, pos):
        &#34;&#34;&#34;
        Returns nearness from a given position to all school and neighbourhood
        objects.

        Args:
            pos (tuple): (x,y) coordinates.

        Returns:
            list: containing all the normalized Euclidean distances.
        &#34;&#34;&#34;
        return self.norm_distances[str(pos)]


    def get_agents(self, type):
        &#34;&#34;&#34;
        Returns list of agents of given type.

        Args:
            type (str): either &#39;School&#39;, &#39;Neighbourhood&#39;, &#39;Household&#39; or
            &#39;Student&#39;.

        Returns:
            list: containing all the objects of the specified type.
        &#34;&#34;&#34;
        return self.agents[type]


    def export_data(self, export=False):
        &#34;&#34;&#34;
        Export data for visualization.
        &#34;&#34;&#34;
        if export:
            self.measurements.export_data()


    def get_shock(self, N=1):
        &#34;&#34;&#34;
        Returns a small random value around zero used as perturbation in value
        determinations to make deterministic processes random.

        Checks if shocks are available. Returns the front value, creates a
        new array of shocks if not available.
        &#34;&#34;&#34;

        # If empty
        sigma, size = 0.01, 1000
        if len(self.shocks) &lt;= N:
            self.shocks = np.random.normal(0, scale=sigma, size=size)

        # Pop front value
        val = self.shocks[0:N]
        self.shocks = self.shocks[N:-1]
        return val


    def get_uniform_shock(self, N=1):
        &#34;&#34;&#34;
        Returns a small random value around zero used as perturbation in value
        determinations to make deterministic processes random.

        Checks if shocks are available. Returns the front value, creates a
        new array of shocks if not available.
        &#34;&#34;&#34;

        # If empty
        size = 1000
        if len(self.uniform_shocks) &lt;= N:
            self.uniform_shocks = np.random.random(size=size)

        # Pop front value
        val = self.uniform_shocks[0:N]
        self.uniform_shocks = self.uniform_shocks[N:-1]
        return val


    def close_school(self, choice=&#34;most_segregated&#34;):
        &#34;&#34;&#34;
        Close a school randomly, or the most segregated.

        Args:
            choice (str): either &#39;most_segregated&#39; (default) or &#39;random&#39;.

        &#34;&#34;&#34;

        if choice == &#34;most_segregated&#34;:
            segregation = self.measurements.calculate_segregation(
                per_location=True)
            max_segregated = np.argmax(segregation)
            school = self.get_agents(&#34;schools&#34;)[max_segregated]
        elif choice == &#34;random&#34;:
            school_index = np.random.randint(len(self.get_agents(&#34;schools&#34;)))
            school = self.get_agents(&#34;schools&#34;)[school_index]
        else:
            print(&#34;School closure method is not supported&#34;)
            sys.exit(1)

        self.get_agents(&#34;schools&#34;).remove(school)
        self.scheduler.remove(school)
        self.grid.remove_agent(school)


    def increment_agent_count(self):
        &#34;&#34;&#34;
        Increment agent count by one.
        &#34;&#34;&#34;
        self.agents[&#34;amount&#34;] += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mesa.model.Model</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="compass.model.CompassModel.calc_comp_utility"><code class="name flex">
<span>def <span class="ident">calc_comp_utility</span></span>(<span>self, x, M, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the utility given a normalised composition (0&lt;=x&lt;=1), an
optimal fraction (0&lt;=f&lt;=1) and utility at homogeneity (0&lt;=M&lt;=1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_comp_utility(self, x, M, f):
    &#34;&#34;&#34;
    Calculates the utility given a normalised composition (0&lt;=x&lt;=1), an 
    optimal fraction (0&lt;=f&lt;=1) and utility at homogeneity (0&lt;=M&lt;=1).
    &#34;&#34;&#34;
    if x &lt;= f:
        utility =  x / f
    else:
        utility =  M + (1-x)*(1-M) / (1-f)
    return utility</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_res_utilities"><code class="name flex">
<span>def <span class="ident">calc_res_utilities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates residential utility at a household its current position and
given its parameter values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_res_utilities(self):
    &#34;&#34;&#34;
    Calculates residential utility at a household its current position and 
    given its parameter values. 
    &#34;&#34;&#34;
    
    b = self.neighbourhood_mixture
    f = self.optimal_fraction
    M = self.utility_at_max
    x = (1-b)*self.local_compositions + \
        b*self.neighbourhood_compositions
    self.res_utilities = self.calc_comp_utility_v(x, M, f)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_residential_compositions"><code class="name flex">
<span>def <span class="ident">calc_residential_compositions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates all local residential compositions assuming all households have
the SAME RADIUS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_residential_compositions(self):
    &#34;&#34;&#34;
    Updates all local residential compositions assuming all households have
    the SAME RADIUS.
    &#34;&#34;&#34;

    # Determine the kernel of the convolution
    radius = self.params[&#39;radius&#39;]
    dim = radius*2 + 1
    self.kernel = np.ones((dim, dim))
    self.kernel[radius, radius] = 0

    # Should it wrap around the edges or not?
    if self.params[&#39;torus&#39;]:
        mode=&#39;wrap&#39;
    else:
        mode=&#39;constant&#39;

    summed = 0
    num_attrs = self.household_attrs.shape[2]
    compositions = np.zeros(shape=self.household_attrs.shape)

    # Convolution for every household attribute.
    for attr in range(num_attrs):
        compositions[:,:,attr] = convolve(
            self.household_attrs[:,:,attr],
            self.kernel, mode=mode)
        summed += compositions[:,:,attr]
    self.compositions = compositions
    self.normalized_compositions = np.nan_to_num(
        compositions / np.repeat(summed[:, :, np.newaxis],
            num_attrs, axis=2))</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_school_compositions"><code class="name flex">
<span>def <span class="ident">calc_school_compositions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the new school compositions for every household and only for
the first student!</p>
<h2 id="note">Note</h2>
<p>Currently only for the first student!!!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_school_compositions(self):
    &#34;&#34;&#34;
    Calculate the new school compositions for every household and only for 
    the first student!

    Note:
        Currently only for the first student!!!
    &#34;&#34;&#34;

    for household in self.get_agents(&#39;households&#39;):
        category = household.category
        array_index = household.array_index
        self.agent_distances[array_index] = household.distance
        self.school_compositions[array_index] = \
            household.students[0].school.composition_normalized[category]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_school_rankings"><code class="name flex">
<span>def <span class="ident">calc_school_rankings</span></span>(<span>self, households, schools)</span>
</code></dt>
<dd>
<div class="desc"><p>Ranks the schools according to utility.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>households</code></strong> :&ensp;<code>list</code></dt>
<dd>list of households the rankings need to be
calculated for.</dd>
<dt><strong><code>schools</code></strong> :&ensp;<code>list</code></dt>
<dd>list of schools that need to be ranked.</dd>
</dl>
<h2 id="todo">Todo</h2>
<p>Schools can differ per household if we only want to look at the
n-closest schools for example?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_school_rankings(self, households, schools):
    &#34;&#34;&#34;
    Ranks the schools according to utility.

    Args:
        households (list): list of households the rankings need to be
            calculated for.
        schools (list): list of schools that need to be ranked.

    Todo:
        Schools can differ per household if we only want to look at the 
        n-closest schools for example?
    &#34;&#34;&#34;
    
    compositions = np.array(
        [school.composition_normalized for school in schools])

    for household in households:
        
        # Get the normalised distance to every school
        category = household.category
        nearness = self.get_norm_distances(household.pos)
        distances = np.array([nearness[str(school.pos)] for school in schools])

        # Composition utility calculations
        f = household.params[&#39;optimal_fraction&#39;][0][category]
        M = household.params[&#39;utility_at_max&#39;][0][category]
        x = compositions[:, category]
        composition_utilities = self.calc_comp_utility_v(x, M, f)

        # Combined
        alpha = household.params[&#39;alpha&#39;]
        utilities = (composition_utilities ** alpha) * \
            (distances ** (1 - alpha))
        utility_dict = dict(zip(schools, utilities))
        ranking = sorted(utility_dict, key=utility_dict.get, reverse=True)
        
        # Set the same ranking for every student
        [student.set_school_preference(ranking) for student in household.students]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calc_school_utilities"><code class="name flex">
<span>def <span class="ident">calc_school_utilities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates school utilities at a student its current school, given
distance and its other parameter values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_school_utilities(self):
    &#34;&#34;&#34;
    Calculates school utilities at a student its current school, given 
    distance and its other parameter values. 
    &#34;&#34;&#34;

    alpha = self.alpha
    f = self.optimal_fraction
    M = self.utility_at_max
    x = self.school_compositions
    distances = self.agent_distances
    self.school_composition_utilities = self.calc_comp_utility_v(x, M, f)
    self.school_utilities = (self.school_composition_utilities ** alpha) * \
        (distances ** (1 - alpha))</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.calculate_distance"><code class="name flex">
<span>def <span class="ident">calculate_distance</span></span>(<span>self, pos_1, pos_2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the distance between two points, accounting for toroidal space.
This function is borrowed from the ContinuousSpace class definition
by MESA.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos_1</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
<dt><strong><code>pos_2</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Euclidean distance between the two points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_distance(self, pos_1, pos_2):
    &#34;&#34;&#34;
    Calculates the distance between two points, accounting for toroidal space.
    This function is borrowed from the ContinuousSpace class definition
    by MESA.

    Args:
        pos_1 (tuple): (x,y) coordinates.
        pos_2 (tuple): (x,y) coordinates.

    Returns:
        float: Euclidean distance between the two points.

    &#34;&#34;&#34;
    x1, y1 = pos_1
    x2, y2 = pos_2

    dx = np.abs(x1 - x2)
    dy = np.abs(y1 - y2)
    if self.params[&#34;torus&#34;]:
        dx = min(dx, self.params[&#34;width&#34;] - dx)
        dy = min(dy, self.params[&#34;height&#34;] - dy)
    return np.sqrt(dx * dx + dy * dy)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.choose_locations"><code class="name flex">
<span>def <span class="ident">choose_locations</span></span>(<span>self, amount, method='evenly_spaced')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a number of locations to place school and neighbourhood objects.
Currently, only random and evenly spaced locations are allowed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of agents to place.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>'evenly_spaced' only supported method for now.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing all the locations in tuple (x,y) format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_locations(self, amount, method=&#34;evenly_spaced&#34;):
    &#34;&#34;&#34;
    Compute a number of locations to place school and neighbourhood objects.
    Currently, only random and evenly spaced locations are allowed.

    Args:
        amount (int): the number of agents to place.
        method (str): &#39;evenly_spaced&#39; only supported method for now.

    Returns:
        list: containing all the locations in tuple (x,y) format.
    &#34;&#34;&#34;

    if amount == 0:
        return []

    else:
        
        # Evenly spaced is also used in &#39;random_per_neighbourhood&#39;
        per_side = np.sqrt(amount)
        if per_side % 1 != 0:
            print(&#34;Unable to place amount of locations using given method&#34;)
            sys.exit(1)

        # Compute locations
        per_side = int(per_side)
        xs = np.linspace(0, self.params[&#39;width&#39;], per_side*2+1)[1::2]
        ys = np.linspace(0, self.params[&#39;height&#39;], per_side*2+1)[1::2]
        locations = [(x,y) for x in xs for y in ys]

    if method == &#34;random&#34;:
        locations = []
        i = 0
        while i &lt; amount:
            x_coord = np.random.randint(low=0, high=self.params[&#39;width&#39;])
            y_coord = np.random.randint(low=0, high=self.params[&#39;height&#39;])
            if (x_coord, y_coord) not in locations:
                locations.append((x_coord, y_coord))
                i += 1

    elif method == &#34;random_per_neighbourhood&#34;:

        width, height = self.params[&#34;width&#34;], self.params[&#39;height&#39;]
        n_schools = self.params[&#39;n_schools&#39;]
        n_neighbourhoods = self.params[&#39;n_neighbourhoods&#39;]
        per_side = int(np.sqrt(n_neighbourhoods))
        location_width = width / per_side
        location_height = height / per_side

        # Draw a random sample per neighbourhood as long as there are
        # schools to place
        locations = []
        i = 0
        while i &lt; max(n_neighbourhoods, n_schools):
            y_low = 0
            for col in range(per_side):
                x_low = 0
                y_high = int((1 + col) * location_height)

                for row in range(per_side):

                    x_high = int((1 + row) * location_width)

                    if x_high &gt;= width:
                        x_high = width - 1
                    elif y_high &gt;= height:
                        y_high = height - 1

                    x_coord = np.random.randint(low=x_low, high=x_high)
                    y_coord = np.random.randint(low=y_low, high=y_high)

                    # Check if the coordinates haven&#39;t already been sampled
                    while (x_coord, y_coord) in locations:
                        x_coord = np.random.randint(low=x_low, high=x_high)
                        y_coord = np.random.randint(low=y_low, high=y_high)

                    locations.append((x_coord, y_coord))
                    x_low = x_high + 1
                    i += 1
                y_low = y_high + 1

        # Shuffle all locations if n_schools &lt;= n_neighbourhoods, otherwise
        # shuffle only the remainder
        if n_schools &lt;= n_neighbourhoods:
            random.shuffle(locations)
        else:
            divider = int(n_schools / n_neighbourhoods)
            remainder = n_schools % n_neighbourhoods
            first_locations = locations[:n_neighbourhoods*divider]
            rest_locations = locations[n_neighbourhoods*divider:]
            random.shuffle(rest_locations)
            locations = first_locations + rest_locations[:remainder]

    return locations</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.close_school"><code class="name flex">
<span>def <span class="ident">close_school</span></span>(<span>self, choice='most_segregated')</span>
</code></dt>
<dd>
<div class="desc"><p>Close a school randomly, or the most segregated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>str</code></dt>
<dd>either 'most_segregated' (default) or 'random'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_school(self, choice=&#34;most_segregated&#34;):
    &#34;&#34;&#34;
    Close a school randomly, or the most segregated.

    Args:
        choice (str): either &#39;most_segregated&#39; (default) or &#39;random&#39;.

    &#34;&#34;&#34;

    if choice == &#34;most_segregated&#34;:
        segregation = self.measurements.calculate_segregation(
            per_location=True)
        max_segregated = np.argmax(segregation)
        school = self.get_agents(&#34;schools&#34;)[max_segregated]
    elif choice == &#34;random&#34;:
        school_index = np.random.randint(len(self.get_agents(&#34;schools&#34;)))
        school = self.get_agents(&#34;schools&#34;)[school_index]
    else:
        print(&#34;School closure method is not supported&#34;)
        sys.exit(1)

    self.get_agents(&#34;schools&#34;).remove(school)
    self.scheduler.remove(school)
    self.grid.remove_agent(school)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.compute_distances"><code class="name flex">
<span>def <span class="ident">compute_distances</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute distance from all grid cells to all schools and all
neighbourhood objects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>of dicts containing all Euclidean distances</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_distances(self):
    &#34;&#34;&#34;
    Compute distance from all grid cells to all schools and all
    neighbourhood objects.

    Returns:
        dict: of dicts containing all Euclidean distances
    &#34;&#34;&#34;
    
    EPS = 1.2e-6
    distances = {}
    closest_schools = {}
    furthest_schools = {}
    closest_neighbourhoods = {}
    for x in range(self.params[&#34;width&#34;]):

        for y in range(self.params[&#34;height&#34;]):
            
            max_dist_school = 0
            min_dist_school = 10e10
            loc_distances = {}

            # Loop over all neighbourhoods, calculate distance and save
            # closest
            point = Point(x,y)
            for neighbourhood in self.get_agents(&#34;neighbourhoods&#34;):
                shape = neighbourhood.shape.buffer(EPS)
                if shape.contains(point):
                    closest_neighbourhoods[str((x,y))] = str(neighbourhood.pos)
                    break

            # Loop over all schools, calculate distance and save furthest
            # and closest
            for school in self.get_agents(&#34;schools&#34;):

                distance = self.calculate_distance(school.pos,(x, y))
                loc_distances[str(school.pos)] = distance

                if distance &lt; min_dist_school:
                    min_dist_school = distance
                    closest_school = str(school.pos)

                if distance &gt; max_dist_school:
                    max_dist_school = distance
                    furthest_school = str(school.pos)

            closest_schools[str((x,y))] = (closest_school, min_dist_school)
            furthest_schools[str((x,y))] = (furthest_school, max_dist_school)
            distances[str((x,y))] = loc_distances

    return distances, closest_schools, furthest_schools, \
        closest_neighbourhoods</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.compute_norm_distances"><code class="name flex">
<span>def <span class="ident">compute_norm_distances</span></span>(<span>self, distances, closest_schools, furthest_schools, closest_neighbourhoods)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute normalised distance from all grid cells to all schools and all
neighbourhood objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>distances</code></strong> :&ensp;<code>dict</code></dt>
<dd>distances per position to every school/neighb.</dd>
<dt><strong><code>closest_schools</code></strong> :&ensp;<code>dict</code></dt>
<dd>closest schools per position</dd>
<dt><strong><code>furthest_schools</code></strong> :&ensp;<code>dict</code></dt>
<dd>furthest schools per position</dd>
<dt><strong><code>closest_neighbourhoods</code></strong> :&ensp;<code>dict</code></dt>
<dd>closest neighbourhood per position</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>of dicts containing all normalised school distances</dd>
</dl>
<h2 id="note">Note</h2>
<ul>
<li>Neighbourhood distances are not normalised!</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_norm_distances(self, distances, closest_schools, 
    furthest_schools, closest_neighbourhoods):
    &#34;&#34;&#34;
    Compute normalised distance from all grid cells to all schools and all
    neighbourhood objects.

    Args:
        distances (dict): distances per position to every school/neighb.
        closest_schools (dict): closest schools per position
        furthest_schools (dict): furthest schools per position
        closest_neighbourhoods (dict): closest neighbourhood per position

    Returns:
        dict: of dicts containing all normalised school distances

    Note:
        * Neighbourhood distances are not normalised!
    &#34;&#34;&#34;
    norm_dists = {}
    for pos in distances.keys():
        normalised = {}
        for location in distances[pos].keys():
            
            if (location!=&#39;closest_school&#39; and location!=&#39;furthest_school&#39;):
                
                # Get the min and max distance to a school and normalise
                minimum = closest_schools[pos][1]
                maximum = furthest_schools[pos][1]
                normalised[location] = (maximum - distances[pos][location]) / \
                    (maximum - minimum)

            else:
                normalised[location] = distances[pos][location]

        norm_dists[pos] = normalised
    return norm_dists</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.convergence_check"><code class="name flex">
<span>def <span class="ident">convergence_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the processes have converged.</p>
<p>Returns: True if converged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convergence_check(self):
    &#34;&#34;&#34;
    Checks if the processes have converged.

    Returns: True if converged.
    &#34;&#34;&#34;
    window_size = self.params[&#39;window_size&#39;]
    time = self.scheduler.get_time()
    school_time = self.scheduler.get_time(&#39;school&#39;)

    # Check what type of segregation to calculate (i.e., which of the
    # processes is running)
    if not self.res_ended:
        self.segregation.append(self.measurements.calculate_segregation(
            type=&#34;bounded_neighbourhood&#34;, index=&#34;Theil&#34;))
    else:
        self.segregation.append(self.measurements.calculate_segregation(
            type=&#34;school&#34;, index=&#34;Theil&#34;))

    # Wait until there is enough steps in the school process
    if (self.res_ended and school_time&lt;window_size):
        return False

    # Check all metrics in the window size and check if they are below
    # the convergence threshold
    if time &gt;= window_size-1:
        utilities = self.measurements.households[
            time-window_size+1:time+1, :, 4]
        means = utilities.mean(axis=1)
        stds = utilities.std(axis=1)

        metrics = np.vstack((means, stds,
            self.segregation[time-window_size+1:time+1]))
        
        metric_means = np.repeat(metrics.mean(axis=1)[:, np.newaxis],
            window_size, axis=1)
        mad = np.abs(metrics - metric_means)
        if np.all(mad &lt; self.params[&#34;conv_threshold&#34;]):
            # Start over if the residential process has converged
            self.res_ended=True
            return True

    return False</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.create_agents"><code class="name flex">
<span>def <span class="ident">create_agents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the agents when no case study is provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_agents(self):
    &#34;&#34;&#34;
    Creates the agents when no case study is provided.
    &#34;&#34;&#34;
    self.neighbourhoods()
    self.schools()
    self.location_to_agent()

    # Compute distance matrix 
    self.distances, \
    self.closest_schools, \
    self.furthest_schools, \
    self.closest_neighbourhoods = self.compute_distances()

    # Compute normalised distances (nearness matrix)
    self.norm_distances = self.compute_norm_distances(
        self.distances, 
        self.closest_schools, 
        self.furthest_schools,
        self.closest_neighbourhoods)

    if self.logging_enabled:
        logging.debug(&#39;Placing households and creating attribute matrix&#39;)
    self.households()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.export_data"><code class="name flex">
<span>def <span class="ident">export_data</span></span>(<span>self, export=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Export data for visualization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_data(self, export=False):
    &#34;&#34;&#34;
    Export data for visualization.
    &#34;&#34;&#34;
    if export:
        self.measurements.export_data()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_agents"><code class="name flex">
<span>def <span class="ident">get_agents</span></span>(<span>self, type)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of agents of given type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>either 'School', 'Neighbourhood', 'Household' or</dd>
</dl>
<p>'Student'.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing all the objects of the specified type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_agents(self, type):
    &#34;&#34;&#34;
    Returns list of agents of given type.

    Args:
        type (str): either &#39;School&#39;, &#39;Neighbourhood&#39;, &#39;Household&#39; or
        &#39;Student&#39;.

    Returns:
        list: containing all the objects of the specified type.
    &#34;&#34;&#34;
    return self.agents[type]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the attribute vector of a given position</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Numpy array</code></dt>
<dd>containing all the attributes (all zeros if empty)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self, pos):
    &#34;&#34;&#34;
    Returns the attribute vector of a given position

    Args:
        pos (tuple): (x,y) coordinates.

    Returns:
        Numpy array: containing all the attributes (all zeros if empty)
    &#34;&#34;&#34;
    return self.household_attrs[pos[0], pos[1], :]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_distances"><code class="name flex">
<span>def <span class="ident">get_distances</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns distances from a given position to all school and neighbourhood
objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing all the Euclidean distances.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_distances(self, pos):
    &#34;&#34;&#34;
    Returns distances from a given position to all school and neighbourhood
    objects.

    Args:
        pos (tuple): (x,y) coordinates.

    Returns:
        list: containing all the Euclidean distances.
    &#34;&#34;&#34;
    return self.distances[str(pos)]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_norm_distances"><code class="name flex">
<span>def <span class="ident">get_norm_distances</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns nearness from a given position to all school and neighbourhood
objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>containing all the normalized Euclidean distances.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_norm_distances(self, pos):
    &#34;&#34;&#34;
    Returns nearness from a given position to all school and neighbourhood
    objects.

    Args:
        pos (tuple): (x,y) coordinates.

    Returns:
        list: containing all the normalized Euclidean distances.
    &#34;&#34;&#34;
    return self.norm_distances[str(pos)]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_shock"><code class="name flex">
<span>def <span class="ident">get_shock</span></span>(<span>self, N=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a small random value around zero used as perturbation in value
determinations to make deterministic processes random.</p>
<p>Checks if shocks are available. Returns the front value, creates a
new array of shocks if not available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shock(self, N=1):
    &#34;&#34;&#34;
    Returns a small random value around zero used as perturbation in value
    determinations to make deterministic processes random.

    Checks if shocks are available. Returns the front value, creates a
    new array of shocks if not available.
    &#34;&#34;&#34;

    # If empty
    sigma, size = 0.01, 1000
    if len(self.shocks) &lt;= N:
        self.shocks = np.random.normal(0, scale=sigma, size=size)

    # Pop front value
    val = self.shocks[0:N]
    self.shocks = self.shocks[N:-1]
    return val</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.get_uniform_shock"><code class="name flex">
<span>def <span class="ident">get_uniform_shock</span></span>(<span>self, N=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a small random value around zero used as perturbation in value
determinations to make deterministic processes random.</p>
<p>Checks if shocks are available. Returns the front value, creates a
new array of shocks if not available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_uniform_shock(self, N=1):
    &#34;&#34;&#34;
    Returns a small random value around zero used as perturbation in value
    determinations to make deterministic processes random.

    Checks if shocks are available. Returns the front value, creates a
    new array of shocks if not available.
    &#34;&#34;&#34;

    # If empty
    size = 1000
    if len(self.uniform_shocks) &lt;= N:
        self.uniform_shocks = np.random.random(size=size)

    # Pop front value
    val = self.uniform_shocks[0:N]
    self.uniform_shocks = self.uniform_shocks[N:-1]
    return val</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.households"><code class="name flex">
<span>def <span class="ident">households</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the household objects to the environment.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>Place household specific parameters in a attribute called params</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def households(self):
    &#34;&#34;&#34;
    Adds the household objects to the environment.

    Todo:
        * Place household specific parameters in a attribute called params
    &#34;&#34;&#34;

    params = self.params
    self.household_attrs = np.zeros(shape=(params[&#34;width&#34;],
        params[&#39;height&#39;], len(params[&#39;group_types&#39;][0])))

    # Create group types, empty spots and shuffle them both
    n_groups = len(params[&#34;group_categories&#34;])
    groups = [np.random.choice(list(range(0,
        len(params[&#34;group_types&#34;][i]))), size=params[&#34;n_households&#34;],
        p=params[&#34;group_dist&#34;][i]) for i in range(n_groups)]

    self.grid.empties = set(
        [(x,y) for x in range(params[&#39;width&#39;]) 
        for y in range(params[&#39;height&#39;])])
    empties = list(self.grid.empties)
    np.random.shuffle(empties)

    # Sample tolerances
    tolerances0, tolerances1 = self.sample_tolerances(
        params[&#34;optimal_fraction&#34;][0],
        scale=params[&#39;homophily_std&#39;],
        size=params[&#34;n_households&#34;])


    for i, position in enumerate(empties[0:params[&#34;n_households&#34;]]):
        household = Household(self.get_agents(&#34;amount&#34;), position, self,
            params, groups[0][i])

        # Find according group and group specific information
        for j in range(len(groups)):
            category = groups[j][i]
            if category == 0:
                tolerance = tolerances0[i]
            elif category == 1:
                tolerance = tolerances1[i]

            # Save household specific parameters
            household.groups.append({
                &#34;group_name&#34;:       params[&#34;group_categories&#34;][j],
                &#34;type_index&#34;:       groups[j][i],
                &#34;group_size&#34;:       len(params[&#34;group_types&#34;][j]),
                &#34;group_type&#34;:       params[&#34;group_types&#34;][j][groups[j][i]],
                &#34;threshold&#34;:        params[&#34;category_thresholds&#34;][j][groups[j][i]],
                &#34;utility_at_max&#34;:   params[&#34;utility_at_max&#34;][j][groups[j][i]],
                &#34;optimal_fraction&#34;: tolerance
                })

        # Place households on the grid and add them to the scheduler
        self.get_agents(&#34;households&#34;).append(household)
        self.grid.place_agent(household, position)
        self.grid.empties.discard(position)
        self.scheduler.add(household)
        self.household_attrs[position[0], position[1], :] = household.attributes

    
    # Calculate AFTER all agents are placed
    all_households = self.get_agents(&#39;households&#39;)
    self.calc_residential_compositions()
    self.set_agent_parameters(params, all_households)
    self.calc_res_utilities()
    [household.update_utilities() for household in all_households]</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.increment_agent_count"><code class="name flex">
<span>def <span class="ident">increment_agent_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Increment agent count by one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_agent_count(self):
    &#34;&#34;&#34;
    Increment agent count by one.
    &#34;&#34;&#34;
    self.agents[&#34;amount&#34;] += 1</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.load_agents"><code class="name flex">
<span>def <span class="ident">load_agents</span></span>(<span>self, case='Amsterdam')</span>
</code></dt>
<dd>
<div class="desc"><p>Load the agents from a pickle.</p>
<h2 id="note">Note</h2>
<p>This function is in progress and works only for the Amsterdam and
IJburg case currently. In the future agents should be able to be
imported in a general manner.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_agents(self, case=&#39;Amsterdam&#39;):
    &#34;&#34;&#34;
    Load the agents from a pickle.

    Note:
        This function is in progress and works only for the Amsterdam and
        IJburg case currently. In the future agents should be able to be 
        imported in a general manner.
    &#34;&#34;&#34;

    if case.lower()==&#39;ijburg&#39;:
        file = open(r&#39;compass/maps/ijburg/agents_ijburg.pickle&#39;, &#39;rb&#39;)
    elif case.lower()==&#39;amsterdam&#39;:
        file = open(r&#39;compass/maps/amsterdam/agents_10p.pickle&#39;, &#39;rb&#39;)

    data = pickle.load(file)

    # Create grid
    xmin, ymin, xmax, ymax = data[&#39;neighbourhoods_gpd&#39;].total_bounds
    self.grid = ContinuousSpace(xmax, ymax, self.params[&#34;torus&#34;],
        xmin, ymin)
    self.params[&#39;max_res_steps&#39;] = 0
    self.grid.empties = [(0,0)]
    self.closest_neighbourhoods = {}

    agents = data[&#39;agents&#39;]
    self.params[&#39;n_neighbourhoods&#39;] = len(agents[agents.object==&#39;Neighbourhood&#39;])
    self.params[&#39;n_schools&#39;] = len(agents[agents.object==&#39;School&#39;])
    self.params[&#39;n_households&#39;] = len(agents[agents.object==&#39;Household&#39;])
    self.params[&#39;n_students&#39;] = int(self.params[&#34;n_households&#34;] * 
            self.params[&#34;student_density&#34;])

    for index, agent in agents.iterrows():

        if agent.object==&#39;Neighbourhood&#39;:
            neighbourhood = Neighbourhood(index, (agent.x, agent.y),
                                agent.geometry, self, self.params)
            self.get_agents(&#34;neighbourhoods&#34;).append(neighbourhood)
            self.scheduler.add(neighbourhood)
            pos = neighbourhood.shape.centroid
            self.grid.place_agent(neighbourhood, (pos.x, pos.y))

        elif agent.object==&#39;School&#39;:
            school = School(index, (agent.x, agent.y), self, self.params)
            self.get_agents(&#34;schools&#34;).append(school)
            self.scheduler.add(school)
            self.grid.place_agent(school, (agent.x, agent.y))

        elif agent.object==&#39;Household&#39;:
            pos = (agent.x, agent.y)
            for nhood in self.get_agents(&#39;neighbourhoods&#39;):
                if nhood.shape.contains(Point(pos)):
                    self.closest_neighbourhoods[str(pos)] = nhood
                    
                    household = Household(index, (agent.x, agent.y), 
                                            self, self.params,
                                            category=int(agent.group),
                                            nhood=nhood)
                    self.get_agents(&#34;households&#34;).append(household)
                    self.scheduler.add(household)
                    self.grid.place_agent(household, (agent.x, agent.y))
                    break            
    
    self.location_to_agent()
    households = self.get_agents(&#39;households&#39;)

    self.distances = data[&#39;distances&#39;]
    self.closest_schools = data[&#39;closest_schools&#39;]
    self.furthest_schools = data[&#39;furthest_schools&#39;]
    self.norm_distances = self.compute_norm_distances(
        self.distances, 
        self.closest_schools, 
        self.furthest_schools, {})

    self.set_agent_parameters(self.params, households)

    self.local_compositions = self.neighbourhood_compositions
    self.calc_res_utilities()

    # Initial compositions need to be calculated
    for household in households:
        # Only bounded calculation
        household.params[&#39;neighbourhood_mixture&#39;] = 1
        household.update_utilities()</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.location_to_agent"><code class="name flex">
<span>def <span class="ident">location_to_agent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dictionary with the location of the neighbourhoods as key and
the object itself as value. Schools are not included as they can have
the same position as a neighbourhood (centroid).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def location_to_agent(self):
    &#34;&#34;&#34;
    Creates a dictionary with the location of the neighbourhoods as key and
    the object itself as value. Schools are not included as they can have 
    the same position as a neighbourhood (centroid).
    &#34;&#34;&#34;

    agents = self.get_agents(&#39;neighbourhoods&#39;)
    self.location_to_agent = {str(agent.pos):agent for agent in agents}</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.logger"><code class="name flex">
<span>def <span class="ident">logger</span></span>(<span>self, log_path, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the logger.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logger(self, log_path, filename):
    &#34;&#34;&#34;
    Sets up the logger.
    &#34;&#34;&#34;

    self.log_path = log_path
    # Check if folder exist, otherwise create it.
    if not os.path.exists(log_path):
        os.makedirs(log_path)

    fileh = logging.FileHandler(log_path + filename, &#39;a&#39;)
    formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - &#39; + \
        &#39;%(levelname)s - %(message)s&#39;)
    fileh.setFormatter(formatter)

    log = logging.getLogger()  # root logger
    for hdlr in log.handlers[:]:  # remove all old handlers
        if isinstance(hdlr, logging.FileHandler):
            log.removeHandler(hdlr)
    log.setLevel(self.params[&#39;loglevel&#39;])
    log.addHandler(fileh)      # set the new handler</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.neighbourhoods"><code class="name flex">
<span>def <span class="ident">neighbourhoods</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the neighbourhood objects to the environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbourhoods(self):
    &#34;&#34;&#34;
    Adds the neighbourhood objects to the environment.
    &#34;&#34;&#34;

    n_neighs = self.params[&#34;n_neighbourhoods&#34;]

    # Add neighbourhoods if necessary
    if n_neighs:
        locations = self.choose_locations(n_neighs,
                            self.params[&#34;neighbourhoods_placement&#34;])
        for i in range(n_neighs):
            
            x, y = locations[i]
            location = (x, y)
            size = self.params[&#39;width&#39;] / float(n_neighs**0.5 * 2)
            minx, miny = x - size, y - size
            maxx, maxy = x + size, y + size
            shape = box(minx, miny, maxx, maxy)

            # Create the Neighbourhood object and place it on the grid and
            # add it to the scheduler
            neighbourhood = Neighbourhood(self.get_agents(&#34;amount&#34;),
                                    location, shape, self, 
                                    self.params)
            self.get_agents(&#34;neighbourhoods&#34;).append(neighbourhood)
            self.scheduler.add(neighbourhood)
            self.grid.place_agent(neighbourhood, locations[i])</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.sample_tolerances"><code class="name flex">
<span>def <span class="ident">sample_tolerances</span></span>(<span>self, means, scale, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample tolerance levels from a truncated normal distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_tolerances(self, means, scale, size):
    &#34;&#34;&#34;
    Sample tolerance levels from a truncated normal distribution.
    &#34;&#34;&#34;
    tolerances = [0]*len(means)
    for index, mu in enumerate(means):

        # All tolerances are equal if the scale is zero.
        if scale==0:
            tolerances[index] = np.repeat(mu, size)
        else:
            tolerances[index] = truncnorm.rvs((0-mu)/scale, (1-mu)/scale,
                                            loc=mu, scale=scale, size=size)
    return tolerances</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.schools"><code class="name flex">
<span>def <span class="ident">schools</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the school objects to the environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schools(self):
    &#34;&#34;&#34;
    Adds the school objects to the environment.
    &#34;&#34;&#34;

    # Add schools if necessary
    if self.params[&#34;n_schools&#34;]:
        locations = self.choose_locations(self.params[&#34;n_schools&#34;],
                            self.params[&#34;schools_placement&#34;])
        for i in range(self.params[&#34;n_schools&#34;]):
            x, y = locations[i]
            location = (x, y)

            # Create the School object and place it on the grid and add it
            # to the scheduler
            school = School(self.get_agents(&#34;amount&#34;),
                location, self, self.params)
            self.get_agents(&#34;schools&#34;).append(school)
            self.scheduler.add(school)
            self.grid.place_agent(school, location)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.set_agent_parameters"><code class="name flex">
<span>def <span class="ident">set_agent_parameters</span></span>(<span>self, params, households)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts the agent parameters in numpy arrays for faster computations. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Model parameters which could differ from
the agent params!</dd>
<dt><strong><code>households</code></strong> :&ensp;<code>list</code></dt>
<dd>list of Household objects. Students should
inherit their parameters from the Household object.</dd>
</dl>
<h2 id="todo">Todo</h2>
<p>Parameters should be imported from a config file in the future.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_agent_parameters(self, params, households):
    &#34;&#34;&#34;
    Puts the agent parameters in numpy arrays for faster computations. 

    Args:
        params (dict): Model parameters which could differ from
            the agent params!
        households (list): list of Household objects. Students should
            inherit their parameters from the Household object.

    Todo:
        Parameters should be imported from a config file in the future.
    &#34;&#34;&#34;

    # to remember the index in the array of the specific household
    array_index = 0

    n_agents = len(households)
    self.local_compositions = []
    self.neighbourhood_compositions = []

    self.utility_at_max = np.repeat(params[&#39;utility_at_max&#39;][0][0], 
        n_agents)
    self.neighbourhood_mixture = np.repeat(params[&#39;neighbourhood_mixture&#39;], 
        n_agents)
    self.alpha = np.repeat(params[&#39;alpha&#39;], n_agents)
    self.optimal_fraction = np.repeat(params[&#39;optimal_fraction&#39;][0][0], 
        n_agents)

    if self.params[&#39;case&#39;].lower() == &#39;lattice&#39;:
        local_compositions = self.normalized_compositions
    
    for household in households:
        household.array_index = array_index
        x,y = household.pos

        # Currently only convolution (assumes every household has the same
        # radius) for composition calculations within the lattice case.
        if self.params[&#39;case&#39;].lower() == &#39;lattice&#39;:
            self.local_compositions.append(
                local_compositions[x,y,household.category])

        self.neighbourhood_compositions.append(
            household.neighbourhood.composition_normalized[household.category])
        array_index += 1

    self.agent_distances = np.zeros(n_agents)
    self.school_compositions = np.zeros(n_agents)
    self.vectorise_functions() # for element-wise operations</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.set_attributes"><code class="name flex">
<span>def <span class="ident">set_attributes</span></span>(<span>self, params, export=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets or calculates all attributes used in the Compass class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>Argparser</code></dt>
<dd>containing all parameter values.</dd>
<dt><strong><code>export</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the data needs to be exported or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attributes(self, params, export=False):
    &#34;&#34;&#34;
    Sets or calculates all attributes used in the Compass class.

    Args:
        params (Argparser): containing all parameter values.
        export (bool): True if the data needs to be exported or not.
    &#34;&#34;&#34;

    # Calculate number of households and students
    
    params[&#34;n_households&#34;] = int(params[&#34;household_density&#34;]
        * (params[&#34;width&#34;] * params[&#34;height&#34;]
        - params[&#34;n_neighbourhoods&#34;] - params[&#34;n_schools&#34;]))
    params[&#39;n_students&#39;] = int(params[&#34;n_households&#34;] * 
            params[&#34;student_density&#34;])
    self.params = dict(params)

    # Set up logger
    self.logging_enabled = params[&#39;logging_enabled&#39;]
    if self.logging_enabled:     
        self.logger(log_path=&#39;logs/&#39;, filename=&#39;model.log&#39;)
        logging.debug(&#39;Starting new model&#39;)

    # Precalculate shocks
    self.uniform_shocks = np.random.random(1000)
    self.shocks = np.random.normal(0, 0.05, 1000)

    # Set tracking attributes
    self.export = export
    self.segregation = []       # Track segregation over time
    self.res_ended = False
    self.school_ended = False
    self.composition = self.composition_normalized = None
    self.agents = {&#34;amount&#34;: 0, &#34;households&#34;: [], &#34;schools&#34;: [],
        &#34;neighbourhoods&#34;: []}
    
    # Initialise other objects
    self.measurements = Measurements(self)
    self.scheduler = ThreeStagedActivation(self)
    self.grid = ContinuousSpace(self.params[&#34;width&#34;], self.params[&#34;height&#34;],
                            torus=self.params[&#34;torus&#34;])</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, res_steps=None, school_steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs #res_steps of residential steps and #school_steps of school
steps.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>res_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of residential steps.</dd>
<dt><strong><code>school_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of school steps.</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an initial school step needs to be
done, False (default) means a school step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, res_steps=None, school_steps=None):
    &#34;&#34;&#34;
    Performs #res_steps of residential steps and #school_steps of school
    steps.

    Args:
        res_steps (int): Number of residential steps.
        school_steps (int): Number of school steps.
        initial_schools (bool): True if an initial school step needs to be
            done, False (default) means a school step.
    &#34;&#34;&#34;
    if not res_steps:
        res_steps = self.params[&#39;max_res_steps&#39;]

    if not school_steps:
        school_steps = self.params[&#39;max_school_steps&#39;]

    logging_level = logging.root.level
    while (self.scheduler.get_time(&#39;residential&#39;) &lt; res_steps \
        and not self.res_ended):

        if logging_level &gt;= 10:
            f = &#34;Residential process: step &#34; + str(
            self.scheduler.get_time(&#39;residential&#39;)+1) + &#34; from &#34; + \
                str(res_steps)
            sys.stdout.write(&#34;\r&#34; + f)
            sys.stdout.flush()
            if self.logging_enabled:
                logging.debug(f)

        self.res_ended = self.convergence_check()
        if not self.res_ended:
            self.step(residential=True)
        else:
            if logging_level &gt;= 10:
                if self.logging_enabled:
                    logging.debug(&#34;\nResidential process converged&#34;)
            break
    
    if self.logging_enabled:
        logging.debug(&#34;Residential process ended.&#34;)
    print()
    while (self.scheduler.get_time(&#39;school&#39;) &lt; school_steps \
        and not self.school_ended):

        if logging_level &gt;= 10:
            f = &#34;School process: step &#34; + str(
            self.scheduler.get_time(&#39;school&#39;)+1) + &#34; from &#34; + \
                str(school_steps)
            sys.stdout.write(&#34;\r&#34; + f)
            sys.stdout.flush()
            if self.logging_enabled:
                logging.debug(f)

        self.school_ended = self.convergence_check()
        if self.scheduler.school_steps == 0:
            self.step(residential=False, initial_schools=True)
        else:
            if not self.school_ended:
                self.step(residential=False, initial_schools=False)
            else:
                if logging_level &gt;= 10:
                    if self.logging_enabled:
                        logging.debug(&#34;School process converged&#34;)
                break

    if self.logging_enabled:
        logging.debug(&#34;School process ended.&#34;)
    if self.logging_enabled:
        logging.debug(&#39;Export data&#39;)
    self.export_data(self.export)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, residential=False, initial_schools=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform model steps.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>residential</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if a residential step needs to be done,
False (default) means a school step.</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an initial school step needs to be
done, False (default) means a school step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, residential=False, initial_schools=False):
    &#34;&#34;&#34;
    Perform model steps.

    Args:
        residential (bool): True if a residential step needs to be done,
            False (default) means a school step.
        initial_schools (bool): True if an initial school step needs to be
            done, False (default) means a school step.
    &#34;&#34;&#34;

    # Perform school or residential step.
    message = f&#39;Perform model step, residential = {residential}, initial schools = {initial_schools}&#39;
    if self.logging_enabled:
        logging.debug(message)
    self.scheduler.step(residential=residential,
                        initial_schools=initial_schools)</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.switch_attrs"><code class="name flex">
<span>def <span class="ident">switch_attrs</span></span>(<span>self, pos1, pos2)</span>
</code></dt>
<dd>
<div class="desc"><p>Switches two attribute vectors in the attribute grid by making a copy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos1</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
<dt><strong><code>pos2</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch_attrs(self, pos1, pos2):
    &#34;&#34;&#34;
    Switches two attribute vectors in the attribute grid by making a copy.

    Args:
        pos1 (tuple): (x,y) coordinates.
        pos2 (tuple): (x,y) coordinates.
    &#34;&#34;&#34;
    temp = np.copy(self.household_attrs[pos1])
    self.household_attrs[pos1] = self.household_attrs[pos2]
    self.household_attrs[pos2] = temp</code></pre>
</details>
</dd>
<dt id="compass.model.CompassModel.vectorise_functions"><code class="name flex">
<span>def <span class="ident">vectorise_functions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Vectorises functions using numpy.vectorize for use in
array computations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectorise_functions(self):
    &#34;&#34;&#34;
    Vectorises functions using numpy.vectorize for use in 
    array computations.
    &#34;&#34;&#34;
    self.calc_comp_utility_v = np.vectorize(self.calc_comp_utility)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="compass" href="index.html">compass</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="compass.model.CompassModel" href="#compass.model.CompassModel">CompassModel</a></code></h4>
<ul class="">
<li><code><a title="compass.model.CompassModel.calc_comp_utility" href="#compass.model.CompassModel.calc_comp_utility">calc_comp_utility</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_res_utilities" href="#compass.model.CompassModel.calc_res_utilities">calc_res_utilities</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_residential_compositions" href="#compass.model.CompassModel.calc_residential_compositions">calc_residential_compositions</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_school_compositions" href="#compass.model.CompassModel.calc_school_compositions">calc_school_compositions</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_school_rankings" href="#compass.model.CompassModel.calc_school_rankings">calc_school_rankings</a></code></li>
<li><code><a title="compass.model.CompassModel.calc_school_utilities" href="#compass.model.CompassModel.calc_school_utilities">calc_school_utilities</a></code></li>
<li><code><a title="compass.model.CompassModel.calculate_distance" href="#compass.model.CompassModel.calculate_distance">calculate_distance</a></code></li>
<li><code><a title="compass.model.CompassModel.choose_locations" href="#compass.model.CompassModel.choose_locations">choose_locations</a></code></li>
<li><code><a title="compass.model.CompassModel.close_school" href="#compass.model.CompassModel.close_school">close_school</a></code></li>
<li><code><a title="compass.model.CompassModel.compute_distances" href="#compass.model.CompassModel.compute_distances">compute_distances</a></code></li>
<li><code><a title="compass.model.CompassModel.compute_norm_distances" href="#compass.model.CompassModel.compute_norm_distances">compute_norm_distances</a></code></li>
<li><code><a title="compass.model.CompassModel.convergence_check" href="#compass.model.CompassModel.convergence_check">convergence_check</a></code></li>
<li><code><a title="compass.model.CompassModel.create_agents" href="#compass.model.CompassModel.create_agents">create_agents</a></code></li>
<li><code><a title="compass.model.CompassModel.export_data" href="#compass.model.CompassModel.export_data">export_data</a></code></li>
<li><code><a title="compass.model.CompassModel.get_agents" href="#compass.model.CompassModel.get_agents">get_agents</a></code></li>
<li><code><a title="compass.model.CompassModel.get_attributes" href="#compass.model.CompassModel.get_attributes">get_attributes</a></code></li>
<li><code><a title="compass.model.CompassModel.get_distances" href="#compass.model.CompassModel.get_distances">get_distances</a></code></li>
<li><code><a title="compass.model.CompassModel.get_norm_distances" href="#compass.model.CompassModel.get_norm_distances">get_norm_distances</a></code></li>
<li><code><a title="compass.model.CompassModel.get_shock" href="#compass.model.CompassModel.get_shock">get_shock</a></code></li>
<li><code><a title="compass.model.CompassModel.get_uniform_shock" href="#compass.model.CompassModel.get_uniform_shock">get_uniform_shock</a></code></li>
<li><code><a title="compass.model.CompassModel.households" href="#compass.model.CompassModel.households">households</a></code></li>
<li><code><a title="compass.model.CompassModel.increment_agent_count" href="#compass.model.CompassModel.increment_agent_count">increment_agent_count</a></code></li>
<li><code><a title="compass.model.CompassModel.load_agents" href="#compass.model.CompassModel.load_agents">load_agents</a></code></li>
<li><code><a title="compass.model.CompassModel.location_to_agent" href="#compass.model.CompassModel.location_to_agent">location_to_agent</a></code></li>
<li><code><a title="compass.model.CompassModel.logger" href="#compass.model.CompassModel.logger">logger</a></code></li>
<li><code><a title="compass.model.CompassModel.neighbourhoods" href="#compass.model.CompassModel.neighbourhoods">neighbourhoods</a></code></li>
<li><code><a title="compass.model.CompassModel.sample_tolerances" href="#compass.model.CompassModel.sample_tolerances">sample_tolerances</a></code></li>
<li><code><a title="compass.model.CompassModel.schools" href="#compass.model.CompassModel.schools">schools</a></code></li>
<li><code><a title="compass.model.CompassModel.set_agent_parameters" href="#compass.model.CompassModel.set_agent_parameters">set_agent_parameters</a></code></li>
<li><code><a title="compass.model.CompassModel.set_attributes" href="#compass.model.CompassModel.set_attributes">set_attributes</a></code></li>
<li><code><a title="compass.model.CompassModel.simulate" href="#compass.model.CompassModel.simulate">simulate</a></code></li>
<li><code><a title="compass.model.CompassModel.step" href="#compass.model.CompassModel.step">step</a></code></li>
<li><code><a title="compass.model.CompassModel.switch_attrs" href="#compass.model.CompassModel.switch_attrs">switch_attrs</a></code></li>
<li><code><a title="compass.model.CompassModel.vectorise_functions" href="#compass.model.CompassModel.vectorise_functions">vectorise_functions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>