<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>compass.scheduler API documentation</title>
<meta name="description" content="The time handler. The scheduler defined in this file is equivalent to the
SimultaneousActivation scheduler from MESA v0.8.6, with the addition of
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>compass.scheduler</code></h1>
</header>
<section id="section-intro">
<p>The time handler. The scheduler defined in this file is equivalent to the
SimultaneousActivation scheduler from MESA v0.8.6, with the addition of
randomization within the step and advance phase plus the possibility of
parallelization over cores. The execution of the step() and advance() parts in
the agents used, result in a system that is not entirely simultaneous.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The time handler. The scheduler defined in this file is equivalent to the
SimultaneousActivation scheduler from MESA v0.8.6, with the addition of
randomization within the step and advance phase plus the possibility of
parallelization over cores. The execution of the step() and advance() parts in
the agents used, result in a system that is not entirely simultaneous.
&#34;&#34;&#34;

from collections import OrderedDict
import numpy as np
from .allocator import Allocator


class ThreeStagedActivation:
    &#34;&#34;&#34;
    A scheduler to simulate the simultaneous activation of all the agents.

    Args:
        model (CompassModel): CompassModel object.

    Attributes:
        model (CompassModel): CompassModel object.
        steps (int): counts the number of steps.
        time (int): counts the number of time steps.
        moved_agents (int): amount of agents moved in a time step.
        max_movements (int): maximum amount of agents to be moved per time step.
        _agents (dict): contains all the agents to be moved.
        allocater (Allocater): an Allocater object.

    Todo:
        * Parallelization if needed.
    &#34;&#34;&#34;

    def __init__(self, model):

        self.model = model
        self.params = model.params
        (
            self.time,
            self.split_index,
            self.moved_agents,
            self.school_steps,
            self.residential_steps,
        ) = (0, 0, 0, 0, 0)

        # A fraction of 0.40 means three splits as does 0.35 for example.
        self.n_splits = np.ceil(1 / self.params[&#34;max_move_fraction&#34;])
        self.step_size = 1 + int(self.model.params[&#34;n_households&#34;] // self.n_splits)
        self.max_movements = 1 + int(
            self.model.params[&#34;max_move_fraction&#34;] * self.model.params[&#34;n_students&#34;]
        )
        self._agents = dict()
        self.allocator = Allocator()

    def add(self, agent):
        &#34;&#34;&#34;
        Add an Agent object to the schedule.

        Args:
            agent: an Agent to be added to the schedule.

        Note:
            The agent must have a step() method.
        &#34;&#34;&#34;
        if agent.__class__.__name__ not in self._agents:
            self._agents[agent.__class__.__name__] = OrderedDict()
        self._agents[agent.__class__.__name__][agent.unique_id] = agent

    def remove(self, agent):
        &#34;&#34;&#34;
        Remove all instances of a given agent from the schedule.

        Args:
            agent: an Agent object.
        &#34;&#34;&#34;
        del self._agents[agent.__class__.__name__][agent.unique_id]

    def get_agent_count(self):
        &#34;&#34;&#34;
        Returns:
            int: the current number of agents in the queue.
        &#34;&#34;&#34;
        return sum([len(agents) for agents in self._agents.values()])

    def get_time(self, time_type=&#34;time&#34;):
        &#34;&#34;&#34;
        Returns:
            int: current time step (total, residential or school)
        &#34;&#34;&#34;

        if time_type == &#34;time&#34;:
            return self.time
        if time_type == &#34;residential&#34;:
            return self.residential_steps
        if time_type == &#34;school&#34;:
            return self.school_steps

        return None

    def agents_to_move(self, households, initial_schools):
        &#34;&#34;&#34;
        Determine which households need to be moved this step.
        &#34;&#34;&#34;

        # Necessary because of the reset button in the visualisation, it&#39;s too
        # early in the init()
        if self.get_time() == 0:
            # A fraction of 0.40 means three splits as does 0.35 for example.
            self.n_splits = np.ceil(1 / self.params[&#34;max_move_fraction&#34;])
            self.step_size = 1 + int(self.model.params[&#34;n_households&#34;] // self.n_splits)
            self.max_movements = 1 + int(
                self.model.params[&#34;max_move_fraction&#34;] * self.model.params[&#34;n_students&#34;]
            )

        if self.params[&#34;scheduling&#34;] == 0 or initial_schools:
            self.model.random.shuffle(households)
            self.lower_index = 0
            self.upper_index = -1

        # Determine the new splits as everyone has been stepped
        elif self.split_index % self.n_splits == 0:
            self.model.random.shuffle(households)
            self.split_index = 0
            self.lower_index = 0
            self.upper_index = self.step_size
            self.split_index += 1

        else:
            self.lower_index = self.upper_index
            self.upper_index = (1 + self.split_index) * self.step_size
            self.split_index += 1

        return households[self.lower_index : self.upper_index]

    def step(self, residential=False, initial_schools=False):
        &#34;&#34;&#34;
        Steps all agents and then advances them.

        Args:
            residential (bool): True if a residential step needs to be
                performed, False (default) means a school step.
            initial_schools (bool): True if an initial school step needs to be
                performed, False (default) means a school step.
        &#34;&#34;&#34;

        all_households = self.model.get_agents(&#34;households&#34;)
        households_to_move = self.agents_to_move(all_households, initial_schools)

        # FIXME: we shouldnt store this, but is needed for a test
        self.households_to_move = households_to_move  # For testing purposes

        if residential:

            # Rankings are still calculated in the Household object instead of
            # model wide as for the schools.
            for household in households_to_move:
                household.step(residential=residential, initial_schools=initial_schools)

            # UPDATE COMPOSITIONS OF ALL AGENTS AFTER ALL THE MOVES
            self.model.calc_residential_compositions()
            for household in all_households:
                household.update_residential()
            self.model.calc_res_utilities()
            self.residential_steps += 1

        else:

            if initial_schools:

                # Initial allocation for EVERY household
                # Set initial preferences
                if self.params[&#34;case&#34;].lower() == &#34;lattice&#34;:
                    self.model.compute_school_distances()  # execute only in lattice case
                    p = self.params[&#34;p&#34;]
                    q = self.params[&#34;q&#34;]
                    self.model.distance_utilities = 1.0 / (
                        1 + (self.model.all_distances / p) ** q
                    )

                #TODO: remove commented code
                #      initialization happens in new allocator
                #for household in all_households:
                #    for student in household.students:
                #        student.set_school_preference(
                #            household.school_ranking_initial()
                #        )

                # Allocate students after all initial preferences have been set
                self.allocate_schools(all_households, initial_schools)

            else:
                # Normal school step
                self.model.calc_school_rankings(
                    households_to_move, self.model.get_agents(&#34;schools&#34;)
                )
                self.allocate_schools(households_to_move, initial_schools)

            # Calculate the new school compositions:
            #  * Compass.school_compositions
            #  TODO: should this move to in the &#39;residential&#39; below?
            self.model.calc_school_compositions()

            if residential:
                # Set:
                #  * Compass.neighbourhodd_compositions
                #  * Compass.local_compositions
                #  * Household.composition
                for household in all_households:
                    household.update_residential()
            # updating the household.distance is done when moving the student

            # Set:
            #  * Household.school_utility_comp
            #  * Household.school_utility
            self.model.calc_school_utilities()
            self.school_steps += 1

        # Updating of the utilities of ALL agents was done in
        # self.model.calc_school_utilities()

        self.time += 1
        self.model.measurements.end_step(residential)

    def allocate_schools(self, households, initial_schools):
        &#34;&#34;&#34;
        Allocates students to schools.

        Args:
            households (list): list of all the households that need to be
                allocated.
            initial_schools (bool): True if an initial school step needs to be
                performed, False (default) means a school step.
        &#34;&#34;&#34;
        if initial_schools:
            self.allocator.initial_school(households)
        else:
            self.allocator.optimal_school(households)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="compass.scheduler.ThreeStagedActivation"><code class="flex name class">
<span>class <span class="ident">ThreeStagedActivation</span></span>
<span>(</span><span>model)</span>
</code></dt>
<dd>
<div class="desc"><p>A scheduler to simulate the simultaneous activation of all the agents.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>CompassModel</code></dt>
<dd>CompassModel object.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>CompassModel</code></dt>
<dd>CompassModel object.</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
<dd>counts the number of steps.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>int</code></dt>
<dd>counts the number of time steps.</dd>
<dt><strong><code>moved_agents</code></strong> :&ensp;<code>int</code></dt>
<dd>amount of agents moved in a time step.</dd>
<dt><strong><code>max_movements</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum amount of agents to be moved per time step.</dd>
<dt><strong><code>_agents</code></strong> :&ensp;<code>dict</code></dt>
<dd>contains all the agents to be moved.</dd>
<dt><strong><code>allocater</code></strong> :&ensp;<code>Allocater</code></dt>
<dd>an Allocater object.</dd>
</dl>
<h2 id="todo">Todo</h2>
<ul>
<li>Parallelization if needed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreeStagedActivation:
    &#34;&#34;&#34;
    A scheduler to simulate the simultaneous activation of all the agents.

    Args:
        model (CompassModel): CompassModel object.

    Attributes:
        model (CompassModel): CompassModel object.
        steps (int): counts the number of steps.
        time (int): counts the number of time steps.
        moved_agents (int): amount of agents moved in a time step.
        max_movements (int): maximum amount of agents to be moved per time step.
        _agents (dict): contains all the agents to be moved.
        allocater (Allocater): an Allocater object.

    Todo:
        * Parallelization if needed.
    &#34;&#34;&#34;

    def __init__(self, model):

        self.model = model
        self.params = model.params
        (
            self.time,
            self.split_index,
            self.moved_agents,
            self.school_steps,
            self.residential_steps,
        ) = (0, 0, 0, 0, 0)

        # A fraction of 0.40 means three splits as does 0.35 for example.
        self.n_splits = np.ceil(1 / self.params[&#34;max_move_fraction&#34;])
        self.step_size = 1 + int(self.model.params[&#34;n_households&#34;] // self.n_splits)
        self.max_movements = 1 + int(
            self.model.params[&#34;max_move_fraction&#34;] * self.model.params[&#34;n_students&#34;]
        )
        self._agents = dict()
        self.allocator = Allocator()

    def add(self, agent):
        &#34;&#34;&#34;
        Add an Agent object to the schedule.

        Args:
            agent: an Agent to be added to the schedule.

        Note:
            The agent must have a step() method.
        &#34;&#34;&#34;
        if agent.__class__.__name__ not in self._agents:
            self._agents[agent.__class__.__name__] = OrderedDict()
        self._agents[agent.__class__.__name__][agent.unique_id] = agent

    def remove(self, agent):
        &#34;&#34;&#34;
        Remove all instances of a given agent from the schedule.

        Args:
            agent: an Agent object.
        &#34;&#34;&#34;
        del self._agents[agent.__class__.__name__][agent.unique_id]

    def get_agent_count(self):
        &#34;&#34;&#34;
        Returns:
            int: the current number of agents in the queue.
        &#34;&#34;&#34;
        return sum([len(agents) for agents in self._agents.values()])

    def get_time(self, time_type=&#34;time&#34;):
        &#34;&#34;&#34;
        Returns:
            int: current time step (total, residential or school)
        &#34;&#34;&#34;

        if time_type == &#34;time&#34;:
            return self.time
        if time_type == &#34;residential&#34;:
            return self.residential_steps
        if time_type == &#34;school&#34;:
            return self.school_steps

        return None

    def agents_to_move(self, households, initial_schools):
        &#34;&#34;&#34;
        Determine which households need to be moved this step.
        &#34;&#34;&#34;

        # Necessary because of the reset button in the visualisation, it&#39;s too
        # early in the init()
        if self.get_time() == 0:
            # A fraction of 0.40 means three splits as does 0.35 for example.
            self.n_splits = np.ceil(1 / self.params[&#34;max_move_fraction&#34;])
            self.step_size = 1 + int(self.model.params[&#34;n_households&#34;] // self.n_splits)
            self.max_movements = 1 + int(
                self.model.params[&#34;max_move_fraction&#34;] * self.model.params[&#34;n_students&#34;]
            )

        if self.params[&#34;scheduling&#34;] == 0 or initial_schools:
            self.model.random.shuffle(households)
            self.lower_index = 0
            self.upper_index = -1

        # Determine the new splits as everyone has been stepped
        elif self.split_index % self.n_splits == 0:
            self.model.random.shuffle(households)
            self.split_index = 0
            self.lower_index = 0
            self.upper_index = self.step_size
            self.split_index += 1

        else:
            self.lower_index = self.upper_index
            self.upper_index = (1 + self.split_index) * self.step_size
            self.split_index += 1

        return households[self.lower_index : self.upper_index]

    def step(self, residential=False, initial_schools=False):
        &#34;&#34;&#34;
        Steps all agents and then advances them.

        Args:
            residential (bool): True if a residential step needs to be
                performed, False (default) means a school step.
            initial_schools (bool): True if an initial school step needs to be
                performed, False (default) means a school step.
        &#34;&#34;&#34;

        all_households = self.model.get_agents(&#34;households&#34;)
        households_to_move = self.agents_to_move(all_households, initial_schools)

        # FIXME: we shouldnt store this, but is needed for a test
        self.households_to_move = households_to_move  # For testing purposes

        if residential:

            # Rankings are still calculated in the Household object instead of
            # model wide as for the schools.
            for household in households_to_move:
                household.step(residential=residential, initial_schools=initial_schools)

            # UPDATE COMPOSITIONS OF ALL AGENTS AFTER ALL THE MOVES
            self.model.calc_residential_compositions()
            for household in all_households:
                household.update_residential()
            self.model.calc_res_utilities()
            self.residential_steps += 1

        else:

            if initial_schools:

                # Initial allocation for EVERY household
                # Set initial preferences
                if self.params[&#34;case&#34;].lower() == &#34;lattice&#34;:
                    self.model.compute_school_distances()  # execute only in lattice case
                    p = self.params[&#34;p&#34;]
                    q = self.params[&#34;q&#34;]
                    self.model.distance_utilities = 1.0 / (
                        1 + (self.model.all_distances / p) ** q
                    )

                #TODO: remove commented code
                #      initialization happens in new allocator
                #for household in all_households:
                #    for student in household.students:
                #        student.set_school_preference(
                #            household.school_ranking_initial()
                #        )

                # Allocate students after all initial preferences have been set
                self.allocate_schools(all_households, initial_schools)

            else:
                # Normal school step
                self.model.calc_school_rankings(
                    households_to_move, self.model.get_agents(&#34;schools&#34;)
                )
                self.allocate_schools(households_to_move, initial_schools)

            # Calculate the new school compositions:
            #  * Compass.school_compositions
            #  TODO: should this move to in the &#39;residential&#39; below?
            self.model.calc_school_compositions()

            if residential:
                # Set:
                #  * Compass.neighbourhodd_compositions
                #  * Compass.local_compositions
                #  * Household.composition
                for household in all_households:
                    household.update_residential()
            # updating the household.distance is done when moving the student

            # Set:
            #  * Household.school_utility_comp
            #  * Household.school_utility
            self.model.calc_school_utilities()
            self.school_steps += 1

        # Updating of the utilities of ALL agents was done in
        # self.model.calc_school_utilities()

        self.time += 1
        self.model.measurements.end_step(residential)

    def allocate_schools(self, households, initial_schools):
        &#34;&#34;&#34;
        Allocates students to schools.

        Args:
            households (list): list of all the households that need to be
                allocated.
            initial_schools (bool): True if an initial school step needs to be
                performed, False (default) means a school step.
        &#34;&#34;&#34;
        if initial_schools:
            self.allocator.initial_school(households)
        else:
            self.allocator.optimal_school(households)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="compass.scheduler.ThreeStagedActivation.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, agent)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an Agent object to the schedule.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent</code></strong></dt>
<dd>an Agent to be added to the schedule.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The agent must have a step() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, agent):
    &#34;&#34;&#34;
    Add an Agent object to the schedule.

    Args:
        agent: an Agent to be added to the schedule.

    Note:
        The agent must have a step() method.
    &#34;&#34;&#34;
    if agent.__class__.__name__ not in self._agents:
        self._agents[agent.__class__.__name__] = OrderedDict()
    self._agents[agent.__class__.__name__][agent.unique_id] = agent</code></pre>
</details>
</dd>
<dt id="compass.scheduler.ThreeStagedActivation.agents_to_move"><code class="name flex">
<span>def <span class="ident">agents_to_move</span></span>(<span>self, households, initial_schools)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine which households need to be moved this step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def agents_to_move(self, households, initial_schools):
    &#34;&#34;&#34;
    Determine which households need to be moved this step.
    &#34;&#34;&#34;

    # Necessary because of the reset button in the visualisation, it&#39;s too
    # early in the init()
    if self.get_time() == 0:
        # A fraction of 0.40 means three splits as does 0.35 for example.
        self.n_splits = np.ceil(1 / self.params[&#34;max_move_fraction&#34;])
        self.step_size = 1 + int(self.model.params[&#34;n_households&#34;] // self.n_splits)
        self.max_movements = 1 + int(
            self.model.params[&#34;max_move_fraction&#34;] * self.model.params[&#34;n_students&#34;]
        )

    if self.params[&#34;scheduling&#34;] == 0 or initial_schools:
        self.model.random.shuffle(households)
        self.lower_index = 0
        self.upper_index = -1

    # Determine the new splits as everyone has been stepped
    elif self.split_index % self.n_splits == 0:
        self.model.random.shuffle(households)
        self.split_index = 0
        self.lower_index = 0
        self.upper_index = self.step_size
        self.split_index += 1

    else:
        self.lower_index = self.upper_index
        self.upper_index = (1 + self.split_index) * self.step_size
        self.split_index += 1

    return households[self.lower_index : self.upper_index]</code></pre>
</details>
</dd>
<dt id="compass.scheduler.ThreeStagedActivation.allocate_schools"><code class="name flex">
<span>def <span class="ident">allocate_schools</span></span>(<span>self, households, initial_schools)</span>
</code></dt>
<dd>
<div class="desc"><p>Allocates students to schools.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>households</code></strong> :&ensp;<code>list</code></dt>
<dd>list of all the households that need to be
allocated.</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an initial school step needs to be
performed, False (default) means a school step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allocate_schools(self, households, initial_schools):
    &#34;&#34;&#34;
    Allocates students to schools.

    Args:
        households (list): list of all the households that need to be
            allocated.
        initial_schools (bool): True if an initial school step needs to be
            performed, False (default) means a school step.
    &#34;&#34;&#34;
    if initial_schools:
        self.allocator.initial_school(households)
    else:
        self.allocator.optimal_school(households)</code></pre>
</details>
</dd>
<dt id="compass.scheduler.ThreeStagedActivation.get_agent_count"><code class="name flex">
<span>def <span class="ident">get_agent_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the current number of agents in the queue.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_agent_count(self):
    &#34;&#34;&#34;
    Returns:
        int: the current number of agents in the queue.
    &#34;&#34;&#34;
    return sum([len(agents) for agents in self._agents.values()])</code></pre>
</details>
</dd>
<dt id="compass.scheduler.ThreeStagedActivation.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self, time_type='time')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>current time step (total, residential or school)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self, time_type=&#34;time&#34;):
    &#34;&#34;&#34;
    Returns:
        int: current time step (total, residential or school)
    &#34;&#34;&#34;

    if time_type == &#34;time&#34;:
        return self.time
    if time_type == &#34;residential&#34;:
        return self.residential_steps
    if time_type == &#34;school&#34;:
        return self.school_steps

    return None</code></pre>
</details>
</dd>
<dt id="compass.scheduler.ThreeStagedActivation.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, agent)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all instances of a given agent from the schedule.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent</code></strong></dt>
<dd>an Agent object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, agent):
    &#34;&#34;&#34;
    Remove all instances of a given agent from the schedule.

    Args:
        agent: an Agent object.
    &#34;&#34;&#34;
    del self._agents[agent.__class__.__name__][agent.unique_id]</code></pre>
</details>
</dd>
<dt id="compass.scheduler.ThreeStagedActivation.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, residential=False, initial_schools=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Steps all agents and then advances them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>residential</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if a residential step needs to be
performed, False (default) means a school step.</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if an initial school step needs to be
performed, False (default) means a school step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, residential=False, initial_schools=False):
    &#34;&#34;&#34;
    Steps all agents and then advances them.

    Args:
        residential (bool): True if a residential step needs to be
            performed, False (default) means a school step.
        initial_schools (bool): True if an initial school step needs to be
            performed, False (default) means a school step.
    &#34;&#34;&#34;

    all_households = self.model.get_agents(&#34;households&#34;)
    households_to_move = self.agents_to_move(all_households, initial_schools)

    # FIXME: we shouldnt store this, but is needed for a test
    self.households_to_move = households_to_move  # For testing purposes

    if residential:

        # Rankings are still calculated in the Household object instead of
        # model wide as for the schools.
        for household in households_to_move:
            household.step(residential=residential, initial_schools=initial_schools)

        # UPDATE COMPOSITIONS OF ALL AGENTS AFTER ALL THE MOVES
        self.model.calc_residential_compositions()
        for household in all_households:
            household.update_residential()
        self.model.calc_res_utilities()
        self.residential_steps += 1

    else:

        if initial_schools:

            # Initial allocation for EVERY household
            # Set initial preferences
            if self.params[&#34;case&#34;].lower() == &#34;lattice&#34;:
                self.model.compute_school_distances()  # execute only in lattice case
                p = self.params[&#34;p&#34;]
                q = self.params[&#34;q&#34;]
                self.model.distance_utilities = 1.0 / (
                    1 + (self.model.all_distances / p) ** q
                )

            #TODO: remove commented code
            #      initialization happens in new allocator
            #for household in all_households:
            #    for student in household.students:
            #        student.set_school_preference(
            #            household.school_ranking_initial()
            #        )

            # Allocate students after all initial preferences have been set
            self.allocate_schools(all_households, initial_schools)

        else:
            # Normal school step
            self.model.calc_school_rankings(
                households_to_move, self.model.get_agents(&#34;schools&#34;)
            )
            self.allocate_schools(households_to_move, initial_schools)

        # Calculate the new school compositions:
        #  * Compass.school_compositions
        #  TODO: should this move to in the &#39;residential&#39; below?
        self.model.calc_school_compositions()

        if residential:
            # Set:
            #  * Compass.neighbourhodd_compositions
            #  * Compass.local_compositions
            #  * Household.composition
            for household in all_households:
                household.update_residential()
        # updating the household.distance is done when moving the student

        # Set:
        #  * Household.school_utility_comp
        #  * Household.school_utility
        self.model.calc_school_utilities()
        self.school_steps += 1

    # Updating of the utilities of ALL agents was done in
    # self.model.calc_school_utilities()

    self.time += 1
    self.model.measurements.end_step(residential)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="compass" href="index.html">compass</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="compass.scheduler.ThreeStagedActivation" href="#compass.scheduler.ThreeStagedActivation">ThreeStagedActivation</a></code></h4>
<ul class="two-column">
<li><code><a title="compass.scheduler.ThreeStagedActivation.add" href="#compass.scheduler.ThreeStagedActivation.add">add</a></code></li>
<li><code><a title="compass.scheduler.ThreeStagedActivation.agents_to_move" href="#compass.scheduler.ThreeStagedActivation.agents_to_move">agents_to_move</a></code></li>
<li><code><a title="compass.scheduler.ThreeStagedActivation.allocate_schools" href="#compass.scheduler.ThreeStagedActivation.allocate_schools">allocate_schools</a></code></li>
<li><code><a title="compass.scheduler.ThreeStagedActivation.get_agent_count" href="#compass.scheduler.ThreeStagedActivation.get_agent_count">get_agent_count</a></code></li>
<li><code><a title="compass.scheduler.ThreeStagedActivation.get_time" href="#compass.scheduler.ThreeStagedActivation.get_time">get_time</a></code></li>
<li><code><a title="compass.scheduler.ThreeStagedActivation.remove" href="#compass.scheduler.ThreeStagedActivation.remove">remove</a></code></li>
<li><code><a title="compass.scheduler.ThreeStagedActivation.step" href="#compass.scheduler.ThreeStagedActivation.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>