<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>compass.household API documentation</title>
<meta name="description" content="The Household class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>compass.household</code></h1>
</header>
<section id="section-intro">
<p>The Household class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Household class.
&#34;&#34;&#34;
import sys
from typing import List, ClassVar, Iterable
import numpy as np
from .agents_base import BaseAgent
from .school import School
from .student import Student
from .neighbourhood import Neighbourhood
from .functions import calc_comp_utility

MAX_INITIAL_HOUSEHOLDS = 100


class Household(BaseAgent):
    &#34;&#34;&#34;
    The household object. Creates an expected number of students per
    household according to the student density, joins the closest
    neighbourhood.

    Args:
        unique_id (int): unique identifier of the agent.
        pos (tuple): (x,y) coordinates of the agent in the 2D-grid.
        model (CompassModel): CompassModel object.
        params (Argparser): containing all parameter values.
        category (int): the category [0,n-1] the agent belongs to.

    Attributes:
        unique_id (int): unique identifier of the agent.
        idx (int): index of this Household in lookup arrays
        pos (tuple): (x,y) coordinates of the agent in the 2D-grid.
        model (CompassModel): CompassModel object.
        params (Argparser): containing all (agent) parameter values.
        groups (list): containing all group types.
        attributes (array): array of attributes of the specific agent.
        composition (array): the sum of the attribute arrays of all Households
            in the local composition of this household.
        students (list): the student(s) in the household.
        school_id: the school.unique_id
        school: the school the first student attends
    &#34;&#34;&#34;

    _total_households: ClassVar[int] = 0
    _max_households: ClassVar[int] = 0

    _household_res_utility: ClassVar[np.ndarray] = np.array([])
    _household_school_utility: ClassVar[np.ndarray] = np.array([])
    _household_distance: ClassVar[np.ndarray] = np.array([])
    _household_school_utility_comp: ClassVar[np.ndarray] = np.array([])
    _household_school_id: ClassVar[np.ndarray] = np.array([])

    __slots__ = [&#34;idx&#34;, &#34;category&#34;]

    @classmethod
    def reset(cls, max_households: int = MAX_INITIAL_HOUSEHOLDS) -&gt; None:
        &#34;&#34;&#34;
        Allocates numpy arrays backing the Household data.

        Must be called before any Household objects are created.

        Arguments:
            max_households (int) : maximum number of Household objects that
            will be created.
        &#34;&#34;&#34;
        if cls._total_households &gt; 0:
            print(
                &#34;Warning: resetting households while there already are &#34;
                &#34;Household objects.&#34;
            )
            cls._total_households = 0

        dtype = &#34;float32&#34;
        cls._max_households = max_households

        # was self.utility if residential
        cls._household_res_utility = np.zeros(max_households, dtype=dtype)

        # was self.utility if not residential
        cls._household_school_utility = np.zeros(max_households, dtype=dtype)

        cls._household_distance = np.zeros(max_households, dtype=dtype)
        cls._household_school_utility_comp = np.zeros(max_households, dtype=dtype)
        cls._household_school_id = np.zeros(max_households, dtype=dtype)

    def __init__(
        self,
        unique_id: int,
        pos: tuple[float, float],
        model: &#34;CompassModel&#34;,
        params: dict,
        category: int,
        nhood: Neighbourhood = None,
    ):
        # Store parameters
        super().__init__(unique_id, pos, model, params)

        # Initialize some storage for Household objects
        # Note: this should be done by a call to Household.initialize()
        if Household._max_households == 0:
            print(&#34;Household.reset() not called yet, starting with default value&#34;)
            Household.reset()

        self.idx: int = Household._total_households
        Household._total_households += 1

        if Household._total_households &gt; Household._max_households:
            print(&#34;Too many Household objects!&#34;)
            sys.exit(-1)

        self.category: int = category
        self.params: dict = params
        self.attributes: np.ndarray = self.attribute_array()
        self.composition: np.ndarray = self.new_composition_array()
        self.school_id: int = 0
        self.school: School = None

        # Create students
        self.students: List[Student] = []
        for i in range(int(self.params[&#34;student_density&#34;])):
            self.students.append(Student(self.model.get_agents(&#34;amount&#34;), self))

        # Join closest neighbourhood if applicable
        if self.params[&#34;n_neighbourhoods&#34;]:

            # Join the given neighbourhood or else the closest
            if nhood:
                self.join_neighbourhood(nhood)
            else:
                neighbourhood = self.get_closest_neighbourhood(self.pos)
                self.join_neighbourhood(neighbourhood)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: representing the unique identifier of the agent.
        &#34;&#34;&#34;
        return f&#34;&lt;Household object with unique_id: {self.unique_id}&gt;&#34;

    @property
    def school_id(self) -&gt; float:
        return Household._household_school_id[self.idx]

    @school_id.setter
    def school_id(self, value: float) -&gt; None:
        Household._household_school_id[self.idx] = value

    @property
    def res_utility(self) -&gt; float:
        return Household._household_res_utility[self.idx]

    @res_utility.setter
    def res_utility(self, value: float) -&gt; None:
        Household._household_res_utility[self.idx] = value

    @property
    def school_utility(self) -&gt; float:
        return Household._household_school_utility[self.idx]

    @school_utility.setter
    def school_utility(self, value: float) -&gt; None:
        Household._household_school_utility[self.idx] = value

    @property
    def school_utility_comp(self) -&gt; float:
        return Household._household_school_utility_comp[self.idx]

    @school_utility_comp.setter
    def school_utility_comp(self, value: float) -&gt; None:
        Household._household_school_utility_comp[self.idx] = value

    @property
    def distance(self):
        return Household._household_distance[self.idx]

    @distance.setter
    def distance(self, value):
        Household._household_distance[self.idx] = value

    def attribute_array(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        This function creates the attribute array for the household that is
        used to calculate the local, neighbourhood and school compositions.
        &#34;&#34;&#34;
        attributes = np.zeros(len(self.params[&#34;group_types&#34;][0]))
        attributes[self.category] += 1
        return attributes

    def get_data(self, residential: bool) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Gets the data of a specific agent for storing purposes in utils.py

        Args:
            residential (Bool): True if the model is in the residential process

        Notes:
            Only the school of the first student is used!
        &#34;&#34;&#34;
        data = [
            self.pos[0],
            self.pos[1],
            self.composition[0],
            self.composition[1],
            self.res_utility if residential else self.school_utility,
            self.category,
            self.unique_id,
            self.distance,
            self.neighbourhood.unique_id
            if residential
            else self.students[0].school.unique_id,
        ]

        return np.array(data, dtype=float)

    def move_to_empty(
        self,
        empties: List[tuple[float, float]],
        num_considered: int,
        ranking_method: str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Moves agent to a random empty cell, vacating the agent&#39;s old cell.

        Args:
            empties (list): a list of empty coordinates [(x1,y1),..,(xn,yn)]
            num_considered (int): how many spots are considered for the ranking
            ranking_method (str): one of &#39;highest&#39; or &#39;proportional&#39;
        &#34;&#34;&#34;
        if len(empties) == 0:
            raise Exception(&#34;ERROR: No empty cells&#34;)

        # Pick possible empty locations, rank them and move to the chosen one
        idxs = self.random.choice(range(len(empties)), size=num_considered)
        positions = [empties[idx] for idx in idxs]
        new_pos = self.residential_ranking(positions, ranking_method)
        self.residential_move(old_pos=self.pos, new_pos=new_pos)

    def residential_move(
        self, old_pos: tuple[float, float] = None, new_pos: tuple[float, float] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Moves a household from old position to its new position.

        Args:
            old_pos (tuple): takes a tuple of integers (x,y), x&lt;width, y&lt;height.
            new_pos (tuple): takes a tuple of integers (x,y), x&lt;width, y&lt;height.
        &#34;&#34;&#34;

        # Remove the agent from the old neighbourhood and add to the new one
        self.remove_neighbourhood(self.neighbourhood)
        self.model.grid.move_agent(self, new_pos)

        # Only remove the old position from the set if the agent actually
        # moves to a new position
        if new_pos != old_pos:
            self.model.grid.empties.discard(new_pos)
            self.model.grid.empties.add(old_pos)

        neighbourhood = self.get_closest_neighbourhood(self.pos)
        self.join_neighbourhood(neighbourhood)

        # Switch the attributes to the new location as well.
        self.model.switch_attrs(old_pos, new_pos)

    def step(
        self,
        residential: bool = False,
        initial_schools: bool = False,
        move_allowed: bool = True,
    ) -&gt; int:
        &#34;&#34;&#34;
        Steps the agent in the residential or school choice process.

        Args:
            residential (bool): equals True if the model needs to run a
                residential or a school step (default=False).
            initial_schools (bool): equals True if all schools are empty and
                students need an initial allocation first.
            move_allowed (True): equals True if the agent belongs to the
                percentage of agents that is allowed to move.

        Returns:
            int: boolean integer indicating if an agent was moved, to use in
                tracking of moved agents
        &#34;&#34;&#34;

        # Run advancement for regular residential Schelling model
        if residential:

            # Check if move is allowed
            if not move_allowed:
                return 0

            # Check if there are neighbourhoods to choose from
            if self.params[&#34;n_neighbourhoods&#34;] == 0:
                print(&#34;There are no neighbourhoods to choose from!&#34;)
                return 0

            elif self.params[&#34;household_density&#34;] &lt; 1:
                self.move_to_empty(
                    empties=list(self.model.grid.empties),
                    num_considered=self.params[&#34;num_considered&#34;],
                    ranking_method=self.params[&#34;ranking_method&#34;],
                )

            elif self.params[&#34;household_density&#34;] == 1:
                print(&#34;Future place for switching of agents.&#34;)
                raise NotImplementedError

            return 1

        else:
            # Schools steps are done in the scheduler now for efficiency
            pass

    def update_residential(self) -&gt; None:
        &#34;&#34;&#34;
        Computes the composition and utility at the current residential location
        and sets the attributes to be used in other calculations.
        &#34;&#34;&#34;

        category = self.category
        idx = self.idx
        if self.neighbourhood.total &gt; 0:
            norm = 1.0 / self.neighbourhood.total
        else:
            norm = 1.0
        self.model.neighbourhood_compositions[idx] = (
            self.neighbourhood.composition[category] * norm
        )

        if self.params[&#34;neighbourhood_mixture&#34;] == 1:
            # Only neighbourhood composition necessary, for case studies and
            # non-integer locations (then integer indexing is not possible)
            self.composition = self.neighbourhood.composition
        else:
            x, y = self.pos
            self.composition = self.model.compositions[x, y, :]
            self.model.local_compositions[idx] = self.model.normalized_compositions[
                x, y, :
            ][category]

    def residential_utility(
        self, composition: np.ndarray, neighbourhood_composition: np.ndarray = None
    ) -&gt; float:
        &#34;&#34;&#34;
        Compute residential utility.

        Args:
            composition (array): normalized local composition counts.
            neighbourhood_composition (array, optional): normalized
                neighbourhood composition counts.

        Returns:
            float: residential utility for a households&#39; current location.

        Note:
            Ideally these computations are executed in numpy arrays,
            simultaneously for all agents, but this is not implemented for
            neighbourhoods yet.
        &#34;&#34;&#34;
        params = self.params

        if neighbourhood_composition is not None:
            combined = (
                composition * (1 - params[&#34;neighbourhood_mixture&#34;])
                + neighbourhood_composition * params[&#34;neighbourhood_mixture&#34;]
            )
        else:
            combined = composition

        actual_fraction = combined[self.category]
        utility_at_max = params[&#34;utility_at_max&#34;][0][self.category]
        optimal_fraction = params[&#34;optimal_fraction&#34;][0][self.category]

        result = np.zeros_like(actual_fraction)
        calc_comp_utility(result, actual_fraction, utility_at_max, optimal_fraction)

        return result

    def get_closest_neighbourhood(self, pos: tuple[float, float]) -&gt; Neighbourhood:
        &#34;&#34;&#34;
        Find the closest neighbourhood object.

        Returns:
            neighbourhood: the closest (Euclidean) neighbourhood object.
        &#34;&#34;&#34;
        location = self.model.closest_neighbourhoods[str(pos)]
        neighbourhood = self.model.location_to_agent[location]
        return neighbourhood

    def join_neighbourhood(self, neighbourhood: Neighbourhood) -&gt; None:
        &#34;&#34;&#34;
        Join the given neighbourhood object.

        Args:
            neighbourhood (Neighbourhood): a neighbourhood object.
        &#34;&#34;&#34;
        self.neighbourhood = neighbourhood
        neighbourhood.add_household(self)

    def get_neighbourhood(self):
        &#34;&#34;&#34;
        Return the neighbourhood this household belongs to.
        &#34;&#34;&#34;
        return self.neighbourhood

    def remove_neighbourhood(self, neighbourhood: Neighbourhood) -&gt; None:
        &#34;&#34;&#34;
        Leave a neighbourhood.

        Args:
            neighbourhood (Neighbourhood): a neighbourhood object.
        &#34;&#34;&#34;
        neighbourhood.remove_household(self)
        self.neighbourhood = None

    def school_ranking_initial(self) -&gt; Iterable[School]:
        &#34;&#34;&#34;
        Computes a list containing all schools ranked to preference. The initial
        school ranking is random.

        Note: when the number of steps is small, this function shows up as a bottleneck.
        the choice() function is very slow, probably because to get sufficient
        randomness it makes many calls to a real random number generator.

        At the moment, there are two implementations, one is faster for the test case,
        the other one for much larger cases.

        Returns:
            list: a randomly ordered list of School objects.
        &#34;&#34;&#34;
        schools = self.model.get_agents(&#34;schools&#34;)

        if True:
            # create a list of indices [0 .. n_schools-1]
            idxs = list(range(len(schools)))

            # shuffle it in-place
            self.model.random.shuffle(idxs)

            # create a list with the shuffled school objects
            return [schools[idx] for idx in idxs]

        if False:
            schools = schools.copy()
            self.model.random.shuffle(schools)
            return schools

    def residential_ranking(
        self, positions: List[tuple[float, float]], ranking_method: str
    ) -&gt; tuple[float, float]:
        &#34;&#34;&#34;
        Computes the ranked location prefences of a household.

        Args:
            positions (list): list of (x, y) tuples that are considered.
            ranking_method (str): one of &#39;highest&#39; or &#39;proportional&#39;

        Returns:
            tuple: new position (x, y) of the household.
        &#34;&#34;&#34;

        summed = 0
        max_utility = 0
        params = self.params
        positions = list(positions) + [self.pos]  # Append own position
        utilities = np.zeros(len(positions))
        temperature = params[&#34;temperature&#34;]
        compositions = self.model.compositions
        norm_compositions = self.model.normalized_compositions

        for index, pos in enumerate(positions):

            if pos == self.pos:
                utility = self.res_utility
            else:
                #  ASSUMING AGENTS HAVE THE SAME RADIUS HERE
                x, y = pos
                composition = compositions[x, y, :]
                norm_composition = norm_compositions[x, y, :]
                neighbourhood = self.get_closest_neighbourhood(pos)
                if neighbourhood.total &gt; 0:
                    norm = 1.0 / neighbourhood.total
                else:
                    norm = 1.0
                utility = self.residential_utility(
                    norm_composition, neighbourhood.composition * norm
                )

            if utility &gt;= max_utility:
                max_utility = utility
                new_pos = [pos]

            utility = np.exp(temperature * utility)
            summed += utility
            utilities[index] = utility

        if summed == float(&#34;inf&#34;):
            # we&#39;re having overflow issues
            # FIXME: just create some reasonable weights
            top = np.argmax(utilities)
            utilities[:] = 0.0
            utilities[top] = 1.0
        else:
            utilities = np.nan_to_num(utilities / summed, copy=False)
        if ranking_method == &#34;proportional&#34; or ranking_method:
            idxs = self.random.choice(range(len(positions)), p=utilities, size=1)
            new_pos = [positions[idxs[0]]]

        return new_pos[0]

    def get_student_count(self) -&gt; int:
        &#34;&#34;&#34;
        Calculates the number of students in a household.

        Returns:
            int: the amount of students in the household.
        &#34;&#34;&#34;
        return len(self.students)

    def get_shock(self) -&gt; float:
        &#34;&#34;&#34; &#34; Returns a small random float value&#34;&#34;&#34;
        return self.model.get_shock()

    def get_uniform_shock(self) -&gt; float:
        &#34;&#34;&#34;
        Returns a random value between 0 and 1.
        &#34;&#34;&#34;
        return self.model.get_uniform_shock()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="compass.household.Household"><code class="flex name class">
<span>class <span class="ident">Household</span></span>
<span>(</span><span>unique_id: int, pos: tuple[float, float], model: CompassModel, params: dict, category: int, nhood: <a title="compass.neighbourhood.Neighbourhood" href="neighbourhood.html#compass.neighbourhood.Neighbourhood">Neighbourhood</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The household object. Creates an expected number of students per
household according to the student density, joins the closest
neighbourhood.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unique_id</code></strong> :&ensp;<code>int</code></dt>
<dd>unique identifier of the agent.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates of the agent in the 2D-grid.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>CompassModel</code></dt>
<dd>CompassModel object.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Argparser</code></dt>
<dd>containing all parameter values.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code>int</code></dt>
<dd>the category [0,n-1] the agent belongs to.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>unique_id</code></strong> :&ensp;<code>int</code></dt>
<dd>unique identifier of the agent.</dd>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>index of this Household in lookup arrays</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>(x,y) coordinates of the agent in the 2D-grid.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>CompassModel</code></dt>
<dd>CompassModel object.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Argparser</code></dt>
<dd>containing all (agent) parameter values.</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>list</code></dt>
<dd>containing all group types.</dd>
<dt><strong><code>attributes</code></strong> :&ensp;<code>array</code></dt>
<dd>array of attributes of the specific agent.</dd>
<dt><strong><code>composition</code></strong> :&ensp;<code>array</code></dt>
<dd>the sum of the attribute arrays of all Households
in the local composition of this household.</dd>
<dt><strong><code>students</code></strong> :&ensp;<code>list</code></dt>
<dd>the student(s) in the household.</dd>
<dt><strong><code>school_id</code></strong></dt>
<dd>the school.unique_id</dd>
<dt><strong><code>school</code></strong></dt>
<dd>the school the first student attends</dd>
</dl>
<p>Create a new agent.</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>unique_id</code></strong> :&ensp;<code>int</code></dt>
<dd>A unique numeric identified for the agent</dd>
<dt><strong><code>model</code></strong></dt>
<dd>(Model): Instance of the model that contains the agent</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Household(BaseAgent):
    &#34;&#34;&#34;
    The household object. Creates an expected number of students per
    household according to the student density, joins the closest
    neighbourhood.

    Args:
        unique_id (int): unique identifier of the agent.
        pos (tuple): (x,y) coordinates of the agent in the 2D-grid.
        model (CompassModel): CompassModel object.
        params (Argparser): containing all parameter values.
        category (int): the category [0,n-1] the agent belongs to.

    Attributes:
        unique_id (int): unique identifier of the agent.
        idx (int): index of this Household in lookup arrays
        pos (tuple): (x,y) coordinates of the agent in the 2D-grid.
        model (CompassModel): CompassModel object.
        params (Argparser): containing all (agent) parameter values.
        groups (list): containing all group types.
        attributes (array): array of attributes of the specific agent.
        composition (array): the sum of the attribute arrays of all Households
            in the local composition of this household.
        students (list): the student(s) in the household.
        school_id: the school.unique_id
        school: the school the first student attends
    &#34;&#34;&#34;

    _total_households: ClassVar[int] = 0
    _max_households: ClassVar[int] = 0

    _household_res_utility: ClassVar[np.ndarray] = np.array([])
    _household_school_utility: ClassVar[np.ndarray] = np.array([])
    _household_distance: ClassVar[np.ndarray] = np.array([])
    _household_school_utility_comp: ClassVar[np.ndarray] = np.array([])
    _household_school_id: ClassVar[np.ndarray] = np.array([])

    __slots__ = [&#34;idx&#34;, &#34;category&#34;]

    @classmethod
    def reset(cls, max_households: int = MAX_INITIAL_HOUSEHOLDS) -&gt; None:
        &#34;&#34;&#34;
        Allocates numpy arrays backing the Household data.

        Must be called before any Household objects are created.

        Arguments:
            max_households (int) : maximum number of Household objects that
            will be created.
        &#34;&#34;&#34;
        if cls._total_households &gt; 0:
            print(
                &#34;Warning: resetting households while there already are &#34;
                &#34;Household objects.&#34;
            )
            cls._total_households = 0

        dtype = &#34;float32&#34;
        cls._max_households = max_households

        # was self.utility if residential
        cls._household_res_utility = np.zeros(max_households, dtype=dtype)

        # was self.utility if not residential
        cls._household_school_utility = np.zeros(max_households, dtype=dtype)

        cls._household_distance = np.zeros(max_households, dtype=dtype)
        cls._household_school_utility_comp = np.zeros(max_households, dtype=dtype)
        cls._household_school_id = np.zeros(max_households, dtype=dtype)

    def __init__(
        self,
        unique_id: int,
        pos: tuple[float, float],
        model: &#34;CompassModel&#34;,
        params: dict,
        category: int,
        nhood: Neighbourhood = None,
    ):
        # Store parameters
        super().__init__(unique_id, pos, model, params)

        # Initialize some storage for Household objects
        # Note: this should be done by a call to Household.initialize()
        if Household._max_households == 0:
            print(&#34;Household.reset() not called yet, starting with default value&#34;)
            Household.reset()

        self.idx: int = Household._total_households
        Household._total_households += 1

        if Household._total_households &gt; Household._max_households:
            print(&#34;Too many Household objects!&#34;)
            sys.exit(-1)

        self.category: int = category
        self.params: dict = params
        self.attributes: np.ndarray = self.attribute_array()
        self.composition: np.ndarray = self.new_composition_array()
        self.school_id: int = 0
        self.school: School = None

        # Create students
        self.students: List[Student] = []
        for i in range(int(self.params[&#34;student_density&#34;])):
            self.students.append(Student(self.model.get_agents(&#34;amount&#34;), self))

        # Join closest neighbourhood if applicable
        if self.params[&#34;n_neighbourhoods&#34;]:

            # Join the given neighbourhood or else the closest
            if nhood:
                self.join_neighbourhood(nhood)
            else:
                neighbourhood = self.get_closest_neighbourhood(self.pos)
                self.join_neighbourhood(neighbourhood)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            str: representing the unique identifier of the agent.
        &#34;&#34;&#34;
        return f&#34;&lt;Household object with unique_id: {self.unique_id}&gt;&#34;

    @property
    def school_id(self) -&gt; float:
        return Household._household_school_id[self.idx]

    @school_id.setter
    def school_id(self, value: float) -&gt; None:
        Household._household_school_id[self.idx] = value

    @property
    def res_utility(self) -&gt; float:
        return Household._household_res_utility[self.idx]

    @res_utility.setter
    def res_utility(self, value: float) -&gt; None:
        Household._household_res_utility[self.idx] = value

    @property
    def school_utility(self) -&gt; float:
        return Household._household_school_utility[self.idx]

    @school_utility.setter
    def school_utility(self, value: float) -&gt; None:
        Household._household_school_utility[self.idx] = value

    @property
    def school_utility_comp(self) -&gt; float:
        return Household._household_school_utility_comp[self.idx]

    @school_utility_comp.setter
    def school_utility_comp(self, value: float) -&gt; None:
        Household._household_school_utility_comp[self.idx] = value

    @property
    def distance(self):
        return Household._household_distance[self.idx]

    @distance.setter
    def distance(self, value):
        Household._household_distance[self.idx] = value

    def attribute_array(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        This function creates the attribute array for the household that is
        used to calculate the local, neighbourhood and school compositions.
        &#34;&#34;&#34;
        attributes = np.zeros(len(self.params[&#34;group_types&#34;][0]))
        attributes[self.category] += 1
        return attributes

    def get_data(self, residential: bool) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Gets the data of a specific agent for storing purposes in utils.py

        Args:
            residential (Bool): True if the model is in the residential process

        Notes:
            Only the school of the first student is used!
        &#34;&#34;&#34;
        data = [
            self.pos[0],
            self.pos[1],
            self.composition[0],
            self.composition[1],
            self.res_utility if residential else self.school_utility,
            self.category,
            self.unique_id,
            self.distance,
            self.neighbourhood.unique_id
            if residential
            else self.students[0].school.unique_id,
        ]

        return np.array(data, dtype=float)

    def move_to_empty(
        self,
        empties: List[tuple[float, float]],
        num_considered: int,
        ranking_method: str,
    ) -&gt; None:
        &#34;&#34;&#34;
        Moves agent to a random empty cell, vacating the agent&#39;s old cell.

        Args:
            empties (list): a list of empty coordinates [(x1,y1),..,(xn,yn)]
            num_considered (int): how many spots are considered for the ranking
            ranking_method (str): one of &#39;highest&#39; or &#39;proportional&#39;
        &#34;&#34;&#34;
        if len(empties) == 0:
            raise Exception(&#34;ERROR: No empty cells&#34;)

        # Pick possible empty locations, rank them and move to the chosen one
        idxs = self.random.choice(range(len(empties)), size=num_considered)
        positions = [empties[idx] for idx in idxs]
        new_pos = self.residential_ranking(positions, ranking_method)
        self.residential_move(old_pos=self.pos, new_pos=new_pos)

    def residential_move(
        self, old_pos: tuple[float, float] = None, new_pos: tuple[float, float] = None
    ) -&gt; None:
        &#34;&#34;&#34;
        Moves a household from old position to its new position.

        Args:
            old_pos (tuple): takes a tuple of integers (x,y), x&lt;width, y&lt;height.
            new_pos (tuple): takes a tuple of integers (x,y), x&lt;width, y&lt;height.
        &#34;&#34;&#34;

        # Remove the agent from the old neighbourhood and add to the new one
        self.remove_neighbourhood(self.neighbourhood)
        self.model.grid.move_agent(self, new_pos)

        # Only remove the old position from the set if the agent actually
        # moves to a new position
        if new_pos != old_pos:
            self.model.grid.empties.discard(new_pos)
            self.model.grid.empties.add(old_pos)

        neighbourhood = self.get_closest_neighbourhood(self.pos)
        self.join_neighbourhood(neighbourhood)

        # Switch the attributes to the new location as well.
        self.model.switch_attrs(old_pos, new_pos)

    def step(
        self,
        residential: bool = False,
        initial_schools: bool = False,
        move_allowed: bool = True,
    ) -&gt; int:
        &#34;&#34;&#34;
        Steps the agent in the residential or school choice process.

        Args:
            residential (bool): equals True if the model needs to run a
                residential or a school step (default=False).
            initial_schools (bool): equals True if all schools are empty and
                students need an initial allocation first.
            move_allowed (True): equals True if the agent belongs to the
                percentage of agents that is allowed to move.

        Returns:
            int: boolean integer indicating if an agent was moved, to use in
                tracking of moved agents
        &#34;&#34;&#34;

        # Run advancement for regular residential Schelling model
        if residential:

            # Check if move is allowed
            if not move_allowed:
                return 0

            # Check if there are neighbourhoods to choose from
            if self.params[&#34;n_neighbourhoods&#34;] == 0:
                print(&#34;There are no neighbourhoods to choose from!&#34;)
                return 0

            elif self.params[&#34;household_density&#34;] &lt; 1:
                self.move_to_empty(
                    empties=list(self.model.grid.empties),
                    num_considered=self.params[&#34;num_considered&#34;],
                    ranking_method=self.params[&#34;ranking_method&#34;],
                )

            elif self.params[&#34;household_density&#34;] == 1:
                print(&#34;Future place for switching of agents.&#34;)
                raise NotImplementedError

            return 1

        else:
            # Schools steps are done in the scheduler now for efficiency
            pass

    def update_residential(self) -&gt; None:
        &#34;&#34;&#34;
        Computes the composition and utility at the current residential location
        and sets the attributes to be used in other calculations.
        &#34;&#34;&#34;

        category = self.category
        idx = self.idx
        if self.neighbourhood.total &gt; 0:
            norm = 1.0 / self.neighbourhood.total
        else:
            norm = 1.0
        self.model.neighbourhood_compositions[idx] = (
            self.neighbourhood.composition[category] * norm
        )

        if self.params[&#34;neighbourhood_mixture&#34;] == 1:
            # Only neighbourhood composition necessary, for case studies and
            # non-integer locations (then integer indexing is not possible)
            self.composition = self.neighbourhood.composition
        else:
            x, y = self.pos
            self.composition = self.model.compositions[x, y, :]
            self.model.local_compositions[idx] = self.model.normalized_compositions[
                x, y, :
            ][category]

    def residential_utility(
        self, composition: np.ndarray, neighbourhood_composition: np.ndarray = None
    ) -&gt; float:
        &#34;&#34;&#34;
        Compute residential utility.

        Args:
            composition (array): normalized local composition counts.
            neighbourhood_composition (array, optional): normalized
                neighbourhood composition counts.

        Returns:
            float: residential utility for a households&#39; current location.

        Note:
            Ideally these computations are executed in numpy arrays,
            simultaneously for all agents, but this is not implemented for
            neighbourhoods yet.
        &#34;&#34;&#34;
        params = self.params

        if neighbourhood_composition is not None:
            combined = (
                composition * (1 - params[&#34;neighbourhood_mixture&#34;])
                + neighbourhood_composition * params[&#34;neighbourhood_mixture&#34;]
            )
        else:
            combined = composition

        actual_fraction = combined[self.category]
        utility_at_max = params[&#34;utility_at_max&#34;][0][self.category]
        optimal_fraction = params[&#34;optimal_fraction&#34;][0][self.category]

        result = np.zeros_like(actual_fraction)
        calc_comp_utility(result, actual_fraction, utility_at_max, optimal_fraction)

        return result

    def get_closest_neighbourhood(self, pos: tuple[float, float]) -&gt; Neighbourhood:
        &#34;&#34;&#34;
        Find the closest neighbourhood object.

        Returns:
            neighbourhood: the closest (Euclidean) neighbourhood object.
        &#34;&#34;&#34;
        location = self.model.closest_neighbourhoods[str(pos)]
        neighbourhood = self.model.location_to_agent[location]
        return neighbourhood

    def join_neighbourhood(self, neighbourhood: Neighbourhood) -&gt; None:
        &#34;&#34;&#34;
        Join the given neighbourhood object.

        Args:
            neighbourhood (Neighbourhood): a neighbourhood object.
        &#34;&#34;&#34;
        self.neighbourhood = neighbourhood
        neighbourhood.add_household(self)

    def get_neighbourhood(self):
        &#34;&#34;&#34;
        Return the neighbourhood this household belongs to.
        &#34;&#34;&#34;
        return self.neighbourhood

    def remove_neighbourhood(self, neighbourhood: Neighbourhood) -&gt; None:
        &#34;&#34;&#34;
        Leave a neighbourhood.

        Args:
            neighbourhood (Neighbourhood): a neighbourhood object.
        &#34;&#34;&#34;
        neighbourhood.remove_household(self)
        self.neighbourhood = None

    def school_ranking_initial(self) -&gt; Iterable[School]:
        &#34;&#34;&#34;
        Computes a list containing all schools ranked to preference. The initial
        school ranking is random.

        Note: when the number of steps is small, this function shows up as a bottleneck.
        the choice() function is very slow, probably because to get sufficient
        randomness it makes many calls to a real random number generator.

        At the moment, there are two implementations, one is faster for the test case,
        the other one for much larger cases.

        Returns:
            list: a randomly ordered list of School objects.
        &#34;&#34;&#34;
        schools = self.model.get_agents(&#34;schools&#34;)

        if True:
            # create a list of indices [0 .. n_schools-1]
            idxs = list(range(len(schools)))

            # shuffle it in-place
            self.model.random.shuffle(idxs)

            # create a list with the shuffled school objects
            return [schools[idx] for idx in idxs]

        if False:
            schools = schools.copy()
            self.model.random.shuffle(schools)
            return schools

    def residential_ranking(
        self, positions: List[tuple[float, float]], ranking_method: str
    ) -&gt; tuple[float, float]:
        &#34;&#34;&#34;
        Computes the ranked location prefences of a household.

        Args:
            positions (list): list of (x, y) tuples that are considered.
            ranking_method (str): one of &#39;highest&#39; or &#39;proportional&#39;

        Returns:
            tuple: new position (x, y) of the household.
        &#34;&#34;&#34;

        summed = 0
        max_utility = 0
        params = self.params
        positions = list(positions) + [self.pos]  # Append own position
        utilities = np.zeros(len(positions))
        temperature = params[&#34;temperature&#34;]
        compositions = self.model.compositions
        norm_compositions = self.model.normalized_compositions

        for index, pos in enumerate(positions):

            if pos == self.pos:
                utility = self.res_utility
            else:
                #  ASSUMING AGENTS HAVE THE SAME RADIUS HERE
                x, y = pos
                composition = compositions[x, y, :]
                norm_composition = norm_compositions[x, y, :]
                neighbourhood = self.get_closest_neighbourhood(pos)
                if neighbourhood.total &gt; 0:
                    norm = 1.0 / neighbourhood.total
                else:
                    norm = 1.0
                utility = self.residential_utility(
                    norm_composition, neighbourhood.composition * norm
                )

            if utility &gt;= max_utility:
                max_utility = utility
                new_pos = [pos]

            utility = np.exp(temperature * utility)
            summed += utility
            utilities[index] = utility

        if summed == float(&#34;inf&#34;):
            # we&#39;re having overflow issues
            # FIXME: just create some reasonable weights
            top = np.argmax(utilities)
            utilities[:] = 0.0
            utilities[top] = 1.0
        else:
            utilities = np.nan_to_num(utilities / summed, copy=False)
        if ranking_method == &#34;proportional&#34; or ranking_method:
            idxs = self.random.choice(range(len(positions)), p=utilities, size=1)
            new_pos = [positions[idxs[0]]]

        return new_pos[0]

    def get_student_count(self) -&gt; int:
        &#34;&#34;&#34;
        Calculates the number of students in a household.

        Returns:
            int: the amount of students in the household.
        &#34;&#34;&#34;
        return len(self.students)

    def get_shock(self) -&gt; float:
        &#34;&#34;&#34; &#34; Returns a small random float value&#34;&#34;&#34;
        return self.model.get_shock()

    def get_uniform_shock(self) -&gt; float:
        &#34;&#34;&#34;
        Returns a random value between 0 and 1.
        &#34;&#34;&#34;
        return self.model.get_uniform_shock()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="compass.agents_base.BaseAgent" href="agents_base.html#compass.agents_base.BaseAgent">BaseAgent</a></li>
<li>mesa.agent.Agent</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="compass.household.Household.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>max_households: int = 100) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Allocates numpy arrays backing the Household data.</p>
<p>Must be called before any Household objects are created.</p>
<h2 id="arguments">Arguments</h2>
<p>max_households (int) : maximum number of Household objects that
will be created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def reset(cls, max_households: int = MAX_INITIAL_HOUSEHOLDS) -&gt; None:
    &#34;&#34;&#34;
    Allocates numpy arrays backing the Household data.

    Must be called before any Household objects are created.

    Arguments:
        max_households (int) : maximum number of Household objects that
        will be created.
    &#34;&#34;&#34;
    if cls._total_households &gt; 0:
        print(
            &#34;Warning: resetting households while there already are &#34;
            &#34;Household objects.&#34;
        )
        cls._total_households = 0

    dtype = &#34;float32&#34;
    cls._max_households = max_households

    # was self.utility if residential
    cls._household_res_utility = np.zeros(max_households, dtype=dtype)

    # was self.utility if not residential
    cls._household_school_utility = np.zeros(max_households, dtype=dtype)

    cls._household_distance = np.zeros(max_households, dtype=dtype)
    cls._household_school_utility_comp = np.zeros(max_households, dtype=dtype)
    cls._household_school_id = np.zeros(max_households, dtype=dtype)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="compass.household.Household.category"><code class="name">var <span class="ident">category</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="compass.household.Household.distance"><code class="name">var <span class="ident">distance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distance(self):
    return Household._household_distance[self.idx]</code></pre>
</details>
</dd>
<dt id="compass.household.Household.idx"><code class="name">var <span class="ident">idx</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="compass.household.Household.res_utility"><code class="name">var <span class="ident">res_utility</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def res_utility(self) -&gt; float:
    return Household._household_res_utility[self.idx]</code></pre>
</details>
</dd>
<dt id="compass.household.Household.school_id"><code class="name">var <span class="ident">school_id</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def school_id(self) -&gt; float:
    return Household._household_school_id[self.idx]</code></pre>
</details>
</dd>
<dt id="compass.household.Household.school_utility"><code class="name">var <span class="ident">school_utility</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def school_utility(self) -&gt; float:
    return Household._household_school_utility[self.idx]</code></pre>
</details>
</dd>
<dt id="compass.household.Household.school_utility_comp"><code class="name">var <span class="ident">school_utility_comp</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def school_utility_comp(self) -&gt; float:
    return Household._household_school_utility_comp[self.idx]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="compass.household.Household.attribute_array"><code class="name flex">
<span>def <span class="ident">attribute_array</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates the attribute array for the household that is
used to calculate the local, neighbourhood and school compositions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_array(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    This function creates the attribute array for the household that is
    used to calculate the local, neighbourhood and school compositions.
    &#34;&#34;&#34;
    attributes = np.zeros(len(self.params[&#34;group_types&#34;][0]))
    attributes[self.category] += 1
    return attributes</code></pre>
</details>
</dd>
<dt id="compass.household.Household.get_closest_neighbourhood"><code class="name flex">
<span>def <span class="ident">get_closest_neighbourhood</span></span>(<span>self, pos: tuple[float, float]) ‑> <a title="compass.neighbourhood.Neighbourhood" href="neighbourhood.html#compass.neighbourhood.Neighbourhood">Neighbourhood</a></span>
</code></dt>
<dd>
<div class="desc"><p>Find the closest neighbourhood object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>neighbourhood</code></dt>
<dd>the closest (Euclidean) neighbourhood object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_closest_neighbourhood(self, pos: tuple[float, float]) -&gt; Neighbourhood:
    &#34;&#34;&#34;
    Find the closest neighbourhood object.

    Returns:
        neighbourhood: the closest (Euclidean) neighbourhood object.
    &#34;&#34;&#34;
    location = self.model.closest_neighbourhoods[str(pos)]
    neighbourhood = self.model.location_to_agent[location]
    return neighbourhood</code></pre>
</details>
</dd>
<dt id="compass.household.Household.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, residential: bool) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the data of a specific agent for storing purposes in utils.py</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>residential</code></strong> :&ensp;<code>Bool</code></dt>
<dd>True if the model is in the residential process</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Only the school of the first student is used!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self, residential: bool) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Gets the data of a specific agent for storing purposes in utils.py

    Args:
        residential (Bool): True if the model is in the residential process

    Notes:
        Only the school of the first student is used!
    &#34;&#34;&#34;
    data = [
        self.pos[0],
        self.pos[1],
        self.composition[0],
        self.composition[1],
        self.res_utility if residential else self.school_utility,
        self.category,
        self.unique_id,
        self.distance,
        self.neighbourhood.unique_id
        if residential
        else self.students[0].school.unique_id,
    ]

    return np.array(data, dtype=float)</code></pre>
</details>
</dd>
<dt id="compass.household.Household.get_neighbourhood"><code class="name flex">
<span>def <span class="ident">get_neighbourhood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the neighbourhood this household belongs to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighbourhood(self):
    &#34;&#34;&#34;
    Return the neighbourhood this household belongs to.
    &#34;&#34;&#34;
    return self.neighbourhood</code></pre>
</details>
</dd>
<dt id="compass.household.Household.get_shock"><code class="name flex">
<span>def <span class="ident">get_shock</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>" Returns a small random float value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shock(self) -&gt; float:
    &#34;&#34;&#34; &#34; Returns a small random float value&#34;&#34;&#34;
    return self.model.get_shock()</code></pre>
</details>
</dd>
<dt id="compass.household.Household.get_student_count"><code class="name flex">
<span>def <span class="ident">get_student_count</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the number of students in a household.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the amount of students in the household.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_student_count(self) -&gt; int:
    &#34;&#34;&#34;
    Calculates the number of students in a household.

    Returns:
        int: the amount of students in the household.
    &#34;&#34;&#34;
    return len(self.students)</code></pre>
</details>
</dd>
<dt id="compass.household.Household.get_uniform_shock"><code class="name flex">
<span>def <span class="ident">get_uniform_shock</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random value between 0 and 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_uniform_shock(self) -&gt; float:
    &#34;&#34;&#34;
    Returns a random value between 0 and 1.
    &#34;&#34;&#34;
    return self.model.get_uniform_shock()</code></pre>
</details>
</dd>
<dt id="compass.household.Household.join_neighbourhood"><code class="name flex">
<span>def <span class="ident">join_neighbourhood</span></span>(<span>self, neighbourhood: <a title="compass.neighbourhood.Neighbourhood" href="neighbourhood.html#compass.neighbourhood.Neighbourhood">Neighbourhood</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Join the given neighbourhood object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neighbourhood</code></strong> :&ensp;<code>Neighbourhood</code></dt>
<dd>a neighbourhood object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_neighbourhood(self, neighbourhood: Neighbourhood) -&gt; None:
    &#34;&#34;&#34;
    Join the given neighbourhood object.

    Args:
        neighbourhood (Neighbourhood): a neighbourhood object.
    &#34;&#34;&#34;
    self.neighbourhood = neighbourhood
    neighbourhood.add_household(self)</code></pre>
</details>
</dd>
<dt id="compass.household.Household.move_to_empty"><code class="name flex">
<span>def <span class="ident">move_to_empty</span></span>(<span>self, empties: List[tuple[float, float]], num_considered: int, ranking_method: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Moves agent to a random empty cell, vacating the agent's old cell.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>empties</code></strong> :&ensp;<code>list</code></dt>
<dd>a list of empty coordinates [(x1,y1),..,(xn,yn)]</dd>
<dt><strong><code>num_considered</code></strong> :&ensp;<code>int</code></dt>
<dd>how many spots are considered for the ranking</dd>
<dt><strong><code>ranking_method</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'highest' or 'proportional'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_empty(
    self,
    empties: List[tuple[float, float]],
    num_considered: int,
    ranking_method: str,
) -&gt; None:
    &#34;&#34;&#34;
    Moves agent to a random empty cell, vacating the agent&#39;s old cell.

    Args:
        empties (list): a list of empty coordinates [(x1,y1),..,(xn,yn)]
        num_considered (int): how many spots are considered for the ranking
        ranking_method (str): one of &#39;highest&#39; or &#39;proportional&#39;
    &#34;&#34;&#34;
    if len(empties) == 0:
        raise Exception(&#34;ERROR: No empty cells&#34;)

    # Pick possible empty locations, rank them and move to the chosen one
    idxs = self.random.choice(range(len(empties)), size=num_considered)
    positions = [empties[idx] for idx in idxs]
    new_pos = self.residential_ranking(positions, ranking_method)
    self.residential_move(old_pos=self.pos, new_pos=new_pos)</code></pre>
</details>
</dd>
<dt id="compass.household.Household.remove_neighbourhood"><code class="name flex">
<span>def <span class="ident">remove_neighbourhood</span></span>(<span>self, neighbourhood: <a title="compass.neighbourhood.Neighbourhood" href="neighbourhood.html#compass.neighbourhood.Neighbourhood">Neighbourhood</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Leave a neighbourhood.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>neighbourhood</code></strong> :&ensp;<code>Neighbourhood</code></dt>
<dd>a neighbourhood object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_neighbourhood(self, neighbourhood: Neighbourhood) -&gt; None:
    &#34;&#34;&#34;
    Leave a neighbourhood.

    Args:
        neighbourhood (Neighbourhood): a neighbourhood object.
    &#34;&#34;&#34;
    neighbourhood.remove_household(self)
    self.neighbourhood = None</code></pre>
</details>
</dd>
<dt id="compass.household.Household.residential_move"><code class="name flex">
<span>def <span class="ident">residential_move</span></span>(<span>self, old_pos: tuple[float, float] = None, new_pos: tuple[float, float] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Moves a household from old position to its new position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>old_pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>takes a tuple of integers (x,y), x&lt;width, y&lt;height.</dd>
<dt><strong><code>new_pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>takes a tuple of integers (x,y), x&lt;width, y&lt;height.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residential_move(
    self, old_pos: tuple[float, float] = None, new_pos: tuple[float, float] = None
) -&gt; None:
    &#34;&#34;&#34;
    Moves a household from old position to its new position.

    Args:
        old_pos (tuple): takes a tuple of integers (x,y), x&lt;width, y&lt;height.
        new_pos (tuple): takes a tuple of integers (x,y), x&lt;width, y&lt;height.
    &#34;&#34;&#34;

    # Remove the agent from the old neighbourhood and add to the new one
    self.remove_neighbourhood(self.neighbourhood)
    self.model.grid.move_agent(self, new_pos)

    # Only remove the old position from the set if the agent actually
    # moves to a new position
    if new_pos != old_pos:
        self.model.grid.empties.discard(new_pos)
        self.model.grid.empties.add(old_pos)

    neighbourhood = self.get_closest_neighbourhood(self.pos)
    self.join_neighbourhood(neighbourhood)

    # Switch the attributes to the new location as well.
    self.model.switch_attrs(old_pos, new_pos)</code></pre>
</details>
</dd>
<dt id="compass.household.Household.residential_ranking"><code class="name flex">
<span>def <span class="ident">residential_ranking</span></span>(<span>self, positions: List[tuple[float, float]], ranking_method: str) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the ranked location prefences of a household.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code></dt>
<dd>list of (x, y) tuples that are considered.</dd>
<dt><strong><code>ranking_method</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'highest' or 'proportional'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>new position (x, y) of the household.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residential_ranking(
    self, positions: List[tuple[float, float]], ranking_method: str
) -&gt; tuple[float, float]:
    &#34;&#34;&#34;
    Computes the ranked location prefences of a household.

    Args:
        positions (list): list of (x, y) tuples that are considered.
        ranking_method (str): one of &#39;highest&#39; or &#39;proportional&#39;

    Returns:
        tuple: new position (x, y) of the household.
    &#34;&#34;&#34;

    summed = 0
    max_utility = 0
    params = self.params
    positions = list(positions) + [self.pos]  # Append own position
    utilities = np.zeros(len(positions))
    temperature = params[&#34;temperature&#34;]
    compositions = self.model.compositions
    norm_compositions = self.model.normalized_compositions

    for index, pos in enumerate(positions):

        if pos == self.pos:
            utility = self.res_utility
        else:
            #  ASSUMING AGENTS HAVE THE SAME RADIUS HERE
            x, y = pos
            composition = compositions[x, y, :]
            norm_composition = norm_compositions[x, y, :]
            neighbourhood = self.get_closest_neighbourhood(pos)
            if neighbourhood.total &gt; 0:
                norm = 1.0 / neighbourhood.total
            else:
                norm = 1.0
            utility = self.residential_utility(
                norm_composition, neighbourhood.composition * norm
            )

        if utility &gt;= max_utility:
            max_utility = utility
            new_pos = [pos]

        utility = np.exp(temperature * utility)
        summed += utility
        utilities[index] = utility

    if summed == float(&#34;inf&#34;):
        # we&#39;re having overflow issues
        # FIXME: just create some reasonable weights
        top = np.argmax(utilities)
        utilities[:] = 0.0
        utilities[top] = 1.0
    else:
        utilities = np.nan_to_num(utilities / summed, copy=False)
    if ranking_method == &#34;proportional&#34; or ranking_method:
        idxs = self.random.choice(range(len(positions)), p=utilities, size=1)
        new_pos = [positions[idxs[0]]]

    return new_pos[0]</code></pre>
</details>
</dd>
<dt id="compass.household.Household.residential_utility"><code class="name flex">
<span>def <span class="ident">residential_utility</span></span>(<span>self, composition: numpy.ndarray, neighbourhood_composition: numpy.ndarray = None) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Compute residential utility.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>composition</code></strong> :&ensp;<code>array</code></dt>
<dd>normalized local composition counts.</dd>
<dt><strong><code>neighbourhood_composition</code></strong> :&ensp;<code>array</code>, optional</dt>
<dd>normalized
neighbourhood composition counts.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>residential utility for a households' current location.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Ideally these computations are executed in numpy arrays,
simultaneously for all agents, but this is not implemented for
neighbourhoods yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residential_utility(
    self, composition: np.ndarray, neighbourhood_composition: np.ndarray = None
) -&gt; float:
    &#34;&#34;&#34;
    Compute residential utility.

    Args:
        composition (array): normalized local composition counts.
        neighbourhood_composition (array, optional): normalized
            neighbourhood composition counts.

    Returns:
        float: residential utility for a households&#39; current location.

    Note:
        Ideally these computations are executed in numpy arrays,
        simultaneously for all agents, but this is not implemented for
        neighbourhoods yet.
    &#34;&#34;&#34;
    params = self.params

    if neighbourhood_composition is not None:
        combined = (
            composition * (1 - params[&#34;neighbourhood_mixture&#34;])
            + neighbourhood_composition * params[&#34;neighbourhood_mixture&#34;]
        )
    else:
        combined = composition

    actual_fraction = combined[self.category]
    utility_at_max = params[&#34;utility_at_max&#34;][0][self.category]
    optimal_fraction = params[&#34;optimal_fraction&#34;][0][self.category]

    result = np.zeros_like(actual_fraction)
    calc_comp_utility(result, actual_fraction, utility_at_max, optimal_fraction)

    return result</code></pre>
</details>
</dd>
<dt id="compass.household.Household.school_ranking_initial"><code class="name flex">
<span>def <span class="ident">school_ranking_initial</span></span>(<span>self) ‑> Iterable[<a title="compass.school.School" href="school.html#compass.school.School">School</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a list containing all schools ranked to preference. The initial
school ranking is random.</p>
<p>Note: when the number of steps is small, this function shows up as a bottleneck.
the choice() function is very slow, probably because to get sufficient
randomness it makes many calls to a real random number generator.</p>
<p>At the moment, there are two implementations, one is faster for the test case,
the other one for much larger cases.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>a randomly ordered list of School objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def school_ranking_initial(self) -&gt; Iterable[School]:
    &#34;&#34;&#34;
    Computes a list containing all schools ranked to preference. The initial
    school ranking is random.

    Note: when the number of steps is small, this function shows up as a bottleneck.
    the choice() function is very slow, probably because to get sufficient
    randomness it makes many calls to a real random number generator.

    At the moment, there are two implementations, one is faster for the test case,
    the other one for much larger cases.

    Returns:
        list: a randomly ordered list of School objects.
    &#34;&#34;&#34;
    schools = self.model.get_agents(&#34;schools&#34;)

    if True:
        # create a list of indices [0 .. n_schools-1]
        idxs = list(range(len(schools)))

        # shuffle it in-place
        self.model.random.shuffle(idxs)

        # create a list with the shuffled school objects
        return [schools[idx] for idx in idxs]

    if False:
        schools = schools.copy()
        self.model.random.shuffle(schools)
        return schools</code></pre>
</details>
</dd>
<dt id="compass.household.Household.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, residential: bool = False, initial_schools: bool = False, move_allowed: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Steps the agent in the residential or school choice process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>residential</code></strong> :&ensp;<code>bool</code></dt>
<dd>equals True if the model needs to run a
residential or a school step (default=False).</dd>
<dt><strong><code>initial_schools</code></strong> :&ensp;<code>bool</code></dt>
<dd>equals True if all schools are empty and
students need an initial allocation first.</dd>
<dt><strong><code>move_allowed</code></strong> :&ensp;<code>True</code></dt>
<dd>equals True if the agent belongs to the
percentage of agents that is allowed to move.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>boolean integer indicating if an agent was moved, to use in
tracking of moved agents</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(
    self,
    residential: bool = False,
    initial_schools: bool = False,
    move_allowed: bool = True,
) -&gt; int:
    &#34;&#34;&#34;
    Steps the agent in the residential or school choice process.

    Args:
        residential (bool): equals True if the model needs to run a
            residential or a school step (default=False).
        initial_schools (bool): equals True if all schools are empty and
            students need an initial allocation first.
        move_allowed (True): equals True if the agent belongs to the
            percentage of agents that is allowed to move.

    Returns:
        int: boolean integer indicating if an agent was moved, to use in
            tracking of moved agents
    &#34;&#34;&#34;

    # Run advancement for regular residential Schelling model
    if residential:

        # Check if move is allowed
        if not move_allowed:
            return 0

        # Check if there are neighbourhoods to choose from
        if self.params[&#34;n_neighbourhoods&#34;] == 0:
            print(&#34;There are no neighbourhoods to choose from!&#34;)
            return 0

        elif self.params[&#34;household_density&#34;] &lt; 1:
            self.move_to_empty(
                empties=list(self.model.grid.empties),
                num_considered=self.params[&#34;num_considered&#34;],
                ranking_method=self.params[&#34;ranking_method&#34;],
            )

        elif self.params[&#34;household_density&#34;] == 1:
            print(&#34;Future place for switching of agents.&#34;)
            raise NotImplementedError

        return 1

    else:
        # Schools steps are done in the scheduler now for efficiency
        pass</code></pre>
</details>
</dd>
<dt id="compass.household.Household.update_residential"><code class="name flex">
<span>def <span class="ident">update_residential</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the composition and utility at the current residential location
and sets the attributes to be used in other calculations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_residential(self) -&gt; None:
    &#34;&#34;&#34;
    Computes the composition and utility at the current residential location
    and sets the attributes to be used in other calculations.
    &#34;&#34;&#34;

    category = self.category
    idx = self.idx
    if self.neighbourhood.total &gt; 0:
        norm = 1.0 / self.neighbourhood.total
    else:
        norm = 1.0
    self.model.neighbourhood_compositions[idx] = (
        self.neighbourhood.composition[category] * norm
    )

    if self.params[&#34;neighbourhood_mixture&#34;] == 1:
        # Only neighbourhood composition necessary, for case studies and
        # non-integer locations (then integer indexing is not possible)
        self.composition = self.neighbourhood.composition
    else:
        x, y = self.pos
        self.composition = self.model.compositions[x, y, :]
        self.model.local_compositions[idx] = self.model.normalized_compositions[
            x, y, :
        ][category]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="compass.agents_base.BaseAgent" href="agents_base.html#compass.agents_base.BaseAgent">BaseAgent</a></b></code>:
<ul class="hlist">
<li><code><a title="compass.agents_base.BaseAgent.advance" href="agents_base.html#compass.agents_base.BaseAgent.advance">advance</a></code></li>
<li><code><a title="compass.agents_base.BaseAgent.new_composition_array" href="agents_base.html#compass.agents_base.BaseAgent.new_composition_array">new_composition_array</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="compass" href="index.html">compass</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="compass.household.Household" href="#compass.household.Household">Household</a></code></h4>
<ul class="">
<li><code><a title="compass.household.Household.attribute_array" href="#compass.household.Household.attribute_array">attribute_array</a></code></li>
<li><code><a title="compass.household.Household.category" href="#compass.household.Household.category">category</a></code></li>
<li><code><a title="compass.household.Household.distance" href="#compass.household.Household.distance">distance</a></code></li>
<li><code><a title="compass.household.Household.get_closest_neighbourhood" href="#compass.household.Household.get_closest_neighbourhood">get_closest_neighbourhood</a></code></li>
<li><code><a title="compass.household.Household.get_data" href="#compass.household.Household.get_data">get_data</a></code></li>
<li><code><a title="compass.household.Household.get_neighbourhood" href="#compass.household.Household.get_neighbourhood">get_neighbourhood</a></code></li>
<li><code><a title="compass.household.Household.get_shock" href="#compass.household.Household.get_shock">get_shock</a></code></li>
<li><code><a title="compass.household.Household.get_student_count" href="#compass.household.Household.get_student_count">get_student_count</a></code></li>
<li><code><a title="compass.household.Household.get_uniform_shock" href="#compass.household.Household.get_uniform_shock">get_uniform_shock</a></code></li>
<li><code><a title="compass.household.Household.idx" href="#compass.household.Household.idx">idx</a></code></li>
<li><code><a title="compass.household.Household.join_neighbourhood" href="#compass.household.Household.join_neighbourhood">join_neighbourhood</a></code></li>
<li><code><a title="compass.household.Household.move_to_empty" href="#compass.household.Household.move_to_empty">move_to_empty</a></code></li>
<li><code><a title="compass.household.Household.remove_neighbourhood" href="#compass.household.Household.remove_neighbourhood">remove_neighbourhood</a></code></li>
<li><code><a title="compass.household.Household.res_utility" href="#compass.household.Household.res_utility">res_utility</a></code></li>
<li><code><a title="compass.household.Household.reset" href="#compass.household.Household.reset">reset</a></code></li>
<li><code><a title="compass.household.Household.residential_move" href="#compass.household.Household.residential_move">residential_move</a></code></li>
<li><code><a title="compass.household.Household.residential_ranking" href="#compass.household.Household.residential_ranking">residential_ranking</a></code></li>
<li><code><a title="compass.household.Household.residential_utility" href="#compass.household.Household.residential_utility">residential_utility</a></code></li>
<li><code><a title="compass.household.Household.school_id" href="#compass.household.Household.school_id">school_id</a></code></li>
<li><code><a title="compass.household.Household.school_ranking_initial" href="#compass.household.Household.school_ranking_initial">school_ranking_initial</a></code></li>
<li><code><a title="compass.household.Household.school_utility" href="#compass.household.Household.school_utility">school_utility</a></code></li>
<li><code><a title="compass.household.Household.school_utility_comp" href="#compass.household.Household.school_utility_comp">school_utility_comp</a></code></li>
<li><code><a title="compass.household.Household.step" href="#compass.household.Household.step">step</a></code></li>
<li><code><a title="compass.household.Household.update_residential" href="#compass.household.Household.update_residential">update_residential</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>